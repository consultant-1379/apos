#!/bin/bash
##
# ------------------------------------------------------------------------
#     Copyright (C) 2013 Ericsson AB. All rights reserved.
# ------------------------------------------------------------------------
##
# Name:
#       raidmgr
# Description:
#   A script to handle the DRBD resource drbd1 in APG43L.
#	This script is also used to manage DRBD resource drbd1 from COM-CLI.	
##
# Usage:
#       call: raidmgr --help
##
# Changelog:
# - Tue Mar 25 2022 -Dharma Teja (XDHATEJ)
#   - added fix for TR HZ60443 Improving raidmgr -k option
# - Fri Feb 11 2021 -Dharma Teja (XDHATEJ)
#   - added fix for TR HZ60448 DNDR failing in GEP5 and GEP7 when raid structure is wrong.
# - Mon 03 Jan 2022 - Dharma Teja (xdhatej)
#     Added performance related logs for "busy filesystem issue"
# - Fri 03 Sep 2021 - Swapnika Baradi (xswapba)
#   Revert the TR fix HY86941
# - Thu 17 Jun 2021 - Roshini Chilukoti (zchiros)
#	Fix for TR HY86941 Issue with raidmgr -k option
# - Mon 02 Nov 2020 -Swapnika Baradi (xswapba)
#     Fix for TR HY31808
# - Wed 14 Nov 2018 - Dharma Teja (xdhatej)
#   Fix for LVMSIZE
# - Tue 22 May 2018 - Sindhura Chintakindi (zchisin)  
#     Fix for raidmgr -U and raidmgr -r option
# - Fri 23 Mar 2018 - Pratap Reddy Uppada (xpraupp)
#     Fix for TR HW73269: volume group size truncated 
#     if data disk size is larger than 1 TB
# - Wed 28 Feb 2018 - Raghavendra Koduri (XKODRAG)
#     Fix for TR HW63257 raidmgr -a showing Disk on AP node A/B NOT OK on GEP5 and GEP7 
# - Wed 14 Feb 2018 - Raghavendra Koduri (XKODRAG)
#     support for GEP7_128_1600 
# - Wed 09 Aug 2017 - Swapnika Baradi (XSWAPBA)
#       Fix for TR HW18352 (raidmgr incorrect variable leads to wrong execution)
# - Tue 29 Aug 2017 - Raghavendra Koduri (XKODRAG)
#     support for GEP7L_400 and GEP7L_1600
# - Wed 27 Sep 2017 - Pranshu Sinha (XPRANSI)
#               Adoption of changes for SLES12 SP2
# - Fri 11 Nov 2016 - Swapnika Baradi (XSWAPBA)
#       Fix for TR HU79440(Adding ETX character at confirmation)
# - Tue Feb 02 2015 - Swetha Baratam (xswebar)
#		updated for disk_finder for GEp5-64-1200
# - Wed Nov 5 2014 - Usha Manne (xushman)
#	Added GetHwType function and restrict -a|--smartctl option in VM
# - Wed May 14 2014 - Pratap Reddy (xpraupp)
#				updated do_sync and do_speed
# - Sun Feb 23 2014 - Malangsha Shaik (xmalsha)
#       Added --add-peer-disk option
# - Thu Aug 29 2013 - Pratap Reddy Uppada (xpraupp)
#       Updated usage and printouts
# - Tue May 14 2013 - Pratap Reddy Uppada (xpraupp)
#		Added do_lvm function to support LVM's
# - Thu May 02 2013 - Phaninder Gattu (xphagat)
#		Added '-H' and '-k' options
# - Fri Mar 22 2013 - Malangsha Shaik (xmalsha)
#       First version.
##

# command-set
CMD_LOGGER=''
CMD_RM=''
CMD_CAT=''
CMD_GETOPT=''
CMD_GREP=''
CMD_WC=''
CMD_TR=''
CMD_SED=''
CMD_MKFS_EXT3=''
CMD_AWK=''
CMD_MOUNT=''
CMD_UMOUNT=''
CMD_MKDIR=''
CMD_FUSER=''
CMD_PS=''
CMD_FIND=''
CMD_HWTYPE=''
CMD_DIRNAME=''
CMD_DD=''
CMD_LS=''
CMD_PARTPROBE=''
CMD_BLOCKDEV=''
CMD_UDEVADM=''
CMD_E2FSCK=''
CMD_DRBDADM=''
CMD_DRBD_OVERVIEW=''
CMD_PING=''
CMD_SSH=''
CMD_DRBDMGR=''
CMD_PARTED=''
CMD_PVCREATE=''
CMD_PVS=''
CMD_VGS=''
CMD_LVS=''
CMD_VGCREATE=''
CMD_DMSETUP=''
CMD_LVCREATE=''
CMD_BLKID=''
CMD_LVCHANGE=''
CMD_VGREMOVE=''
CMD_PVREMOVE=''
CMD_LVREMOVE=''
CMD_VGREDUCE=''
CMD_KILLALL=''

# ap command-set
CMD_CONFIGAP=''
CMD_VDIRCONF=''
CMD_DRBDMGR=''

# global variable-set
TRUE=$( true; echo $? )
FALSE=$( false; echo $? )
DRBD_RESOURCE='drbd1'
DRBD_DEVICE=''
MOUNT_POINT='/data'
MOUNT_POINT_MOD="755"
SYSTM_DISK='/dev/eri_disk'
PARTBLE_DISKS=''
DUBLE_PART_DISK=''
SNGLE_PART_DISK=''
DRBD_DATA_DISKS=''
DRBD_META_DISK=''
PEER_SYSTEM_DISK=''
PEER_DATA_DISK=''
PEER_META_DISK=''
PEER_DISK_C=''
PEER_DISK_D=''
ETC_DIR='/etc'
OUT_TMP=''
ERR_TMP=''
SCRIPT_NAME='raidmgr'
SCRIPT_OPTS=''
ROOT_USER=$FALSE
LOG_TAG='-t raidmgr'
META_SIZE_MB=''
NODE_ONE=1
NODE_TWO=2
FILE_SYS='ext3'
HW_TYPE=''
PART_DATA_LV='/dev/eri-data-vg/eri-data-lv'
PART_META_SLINK='/dev/eri-meta-part'
FSTAB_OPTIONS='rw,grpjquota=aquota.group,jqfmt=vfsv0'
FSTAB_LINE="$DRBD_DEVICE $MOUNT_POINT ext3 $FSTAB_OPTIONS 0 0"
BUSYFS_LOG="/var/log/acs/tra/logging/apos_raid.log"
# Option variable set
FULL_OPT_LIST=''
OPT_ADD=$FALSE;
OPT_ADD_PEER=$FALSE;
OPT_ADD_ARG=''
OPT_ASSEMBLE=$FALSE
OPT_CREATE=$FALSE
OPT_FOLDER=$FALSE
OPT_DISABLE=$FALSE
OPT_FORMAT=$FALSE
OPT_FORCE=$FALSE
OPT_HELP=$FALSE
OPT_MIGRATION=$FALSE
OPT_IS_MOUNTED=$FALSE
OPT_MOUNT=$FALSE
OPT_LVM=$FALSE
OPT_ROLE=$FALSE
OPT_ROLE_ARG=''
OPT_PART=$FALSE
OPT_PART_ARG=''
OPT_RECOVER=$FALSE
OPT_REMOVE=$FALSE
OPT_SYNC=$FALSE
OPT_SYNC_ARG=''
OPT_STATUS=$FALSE
OPT_ACTIVATE=$FALSE
OPT_DEACTIVATE=$FALSE
OPT_SYNC_SPEED=$FALSE
OPT_SYNC_SPEED_ARG=''
OPT_UNMOUNT=$FALSE
OPT_VERBOSE=$FALSE
OPT_USER_ARG=$FALSE
RESET_SPEED=$FALSE
CMPTBLE_OPTS=$TRUE
OPT_SMRTCTL=$FALSE
OPT_FSCK=$FALSE
DBLE_PARAM=$FALSE
THIS_DISK=''
REMOTE_DISK=''

# exit codes set
exit_sucs=0
exit_fail=1
exit_usge=2
exit_cmnd_abrt=3

# do_sync
exit_sync_conf=4
exit_sync_csrs=4
exit_sync_resm=5
exit_sync_cspa=6
exit_sync_paus=7

# do_status
exit_stat_conf=8
exit_stat_drbd=9

# do_part
exit_part_conf=10
exit_part_disb=11
exit_part_invd=12
exit_part_part=13
exit_part_ddxx=14
exit_part_fdsk=15
exit_part_upxx=16
exit_part_labl=67
exit_part_prm1=68
exit_part_prm2=69

# do_remove 
exit_rmve_conf=17
exit_rlcl_actv=18
exit_rlcl_sync=19
exit_rper_sync=20
exit_rper_rmve=21
exit_rlcl_cste=22
exit_rcvr_invd=23

# do_folder 
exit_fold_mntx=23
exit_fold_cfig=24
exit_fold_vdir=25

# create_md 
exit_cret_mdxx=26

# do_deactivate 
exit_dact_forc=27
exit_dact_scon=28
exit_dact_down=29

# do_unmount
exit_umnt_bsyf=30

# do_mount
exit_mntx_fail=31

# do_activate 
exit_actv_upxx=32
exit_actv_sync=33

# do_create
exit_crte_prim=34
exit_crte_dmgr=35

# do_fomat
exit_frmt_conf=36
exit_frmt_prim=37
exit_frmt_fail=38
exit_frmt_mntx=39

# do_mount
exit_mntx_fail=40

# general exit codes
exit_dskf_eror=41
exit_cdsk_part=42
exit_slnk_part=43

# do_speed
exit_sped_conf=44
exit_sped_prim=45
exit_sped_setx=46
exit_sped_rset=47

# do_recover
exit_rcvy_conf=48
exit_rcvy_disb=49
exit_rcvr_actv=50
exit_rcvy_disk=51

# do_add
exit_addx_conf=52
exit_addx_prim=53
exit_addx_peer=54
exit_addx_addx=55
exit_addx_sync=56

# do_role
exit_role_conf=57
exit_role_dste=58
exit_role_role=59
exit_role_invd=60
exit_role_eror=61
exit_asmb_eror=62
exit_rcvy_prim=63

# do_disable
exit_disb_conf=64
exit_disb_forc=65
exit_disb_scon=66

#do_smrtctl
exit_smrt_eror=67

#do_fsck
exit_fsck_eror=68
exit_dsfk_eror=69
	
#do_lvm
exit_lvmx_eror=70
exit_rmlv_eror=71

# Function definitions start from here =====>>
# ------------------------------------------------------------------------
# The function will return $TRUE if the --verbose option has been specified,
# $FALSE otherwise.
function is_verbose(){
	if [ $OPT_VERBOSE -eq $TRUE ]; then
		return $TRUE
	else
		return $FALSE
	fi
}

# ------------------------------------------------------------------------
function is_traceon(){
	# trace option is only available for root-user for now.
	local TRACE_FILE='/tmp/raidmgr.trace'
	is_rootuser && {
		if [ -f $TRACE_FILE ]; then
			return $TRUE
		else
			return $FALSE
		fi
	}
}

# ------------------------------------------------------------------------
function log(){
    local PRIO='-p user.notice'
    local MESSAGE="${*:-notice}"
    $CMD_LOGGER $PRIO $LOG_TAG "$MESSAGE" >$OUT_TMP 2>$ERR_TMP
}

#--------------------------------------------------------------------------
function busyfs_log(){
        echo "[$(date --utc)] $@" >> $BUSYFS_LOG
}

# ------------------------------------------------------------------------
# The function will log an error message in the system log. If the --verbose
# option has been specified, it will print the same message on stderr too.
function log_error(){
    local PRIO='-p user.err'
    local MESSAGE="${*:-error}"
    $CMD_LOGGER $PRIO $LOG_TAG "$MESSAGE" >$OUT_TMP 2>$ERR_TMP    
}

# ------------------------------------------------------------------------
# The function will log the function start and the parameter list only
# if the --verbose option have been specified.
function trace_enter(){
	is_traceon && echo -e "(TRACE:) START: [$*]"
}

# ------------------------------------------------------------------------
# The function will log the function end only if the --verbose option
# have been specified.
function trace_leave(){
	is_traceon && echo -e "(TRACE:) END: [$1]"
}

# ------------------------------------------------------------------------
function console_print(){
    echo -e
    echo -e "$1"
    echo -e
}
	
# ------------------------------------------------------------------------
function abort(){
	is_rootuser && {
		console_print "$1"
		is_traceon && {
			echo -e "(TRACE:)"
			$CMD_CAT $ERR_TMP
		}
		log_error "ABORTING: <"$1">"
		exit $exit_fail
	}
	
	! is_rootuser && {
		log_error "$1"
		console_print "$1"		
		exit $2
	}  
}

# ------------------------------------------------------------------------
function abort_v1(){
		abort "$@"
}

# ------------------------------------------------------------------------
function abort_v2(){
		console_print "Error when executing (general fault)"
		log_error "ABORTING: <"$1">"
		exit $exit_fail
}

# ------------------------------------------------------------------------
function sanity_check(){
    OUT_TMP=$(mktemp --tmpdir raidmgr_log_XXXXX)
    ERR_TMP=$OUT_TMP
	
    # command-section
    CMD_LOGGER='/bin/logger'
    CMD_RM='/bin/rm'
    CMD_CAT='/bin/cat'
    CMD_GETOPT='/usr/bin/getopt'
    CMD_GREP='/usr/bin/grep'
    CMD_WC='/usr/bin/wc'
    CMD_TR='/usr/bin/tr'
    CMD_SED='/usr/bin/sed'
    CMD_MKFS_EXT3='/sbin/mkfs.ext3'
    CMD_AWK='/usr/bin/awk'
    CMD_MOUNT='/bin/mount'
    CMD_UMOUNT='/bin/umount'
    CMD_MKDIR='/bin/mkdir'
    CMD_FUSER='/bin/fuser'
    CMD_PS='/bin/ps'
    CMD_FIND='/usr/bin/find'
    CMD_HWTYPE='/opt/ap/apos/conf/apos_hwtype.sh'
    CMD_DIRNAME='/usr/bin/dirname'
    CMD_DD='/bin/dd'
	CMD_LS='/bin/ls'
    CMD_PARTPROBE='/usr/sbin/partprobe'
    CMD_BLOCKDEV='/sbin/blockdev'
    CMD_UDEVADM='/sbin/udevadm'
    CMD_E2FSCK='/sbin/e2fsck'
    CMD_DRBDADM='/sbin/drbdadm'
    CMD_DRBD_OVERVIEW='/sbin/drbd-overview'
    CMD_PING='/bin/ping'
    CMD_SSH='/usr/bin/ssh'	
    CMD_SMARTCTL='/usr/sbin/smartctl'
    CMD_PARTED='/usr/sbin/parted'	
    CMD_PVCREATE='/sbin/pvcreate'
    CMD_PVS='/sbin/pvs'
    CMD_VGS='/sbin/vgs'
    CMD_LVS='/sbin/lvs'
    CMD_VGCREATE='/sbin/vgcreate'
    CMD_DMSETUP='/sbin/dmsetup'
    CMD_LVCREATE='/sbin/lvcreate'
    CMD_BLKID='/sbin/blkid'
    CMD_LVCHANGE='/sbin/lvchange'
    CMD_VGREMOVE='/sbin/vgremove'
    CMD_PVREMOVE='/sbin/pvremove'
    CMD_LVREMOVE='/sbin/lvremove'
	CMD_VGREDUCE='/sbin/vgreduce'
	CMD_KILLALL='/usr/bin/killall'
    CMD_STAT='/usr/bin/stat' 
    CMD_CHMOD='/bin/chmod'
 
    # ap command-sections
    CMD_CONFIGAP='/opt/ap/acs/bin/acs_lct_configap.sh'
    CMD_VDIRCONF='/opt/ap/apos/conf/apos_vdirconf.sh'
    CMD_DRBDMGR='/opt/ap/apos/bin/raidmgr'
    CMD_DRBD_STATUS='/opt/ap/apos/conf/apos_drbd_status'

    # General checks
	[ ! -d $ETC_DIR ] && abort_v2 "folder $ETC_DIR not found!"
    [ ! -d $MOUNT_POINT ] && {
        $CMD_MKDIR -m $MOUNT_POINT_MOD -p $MOUNT_POINT >$OUT_TMP 2>$ERR_TMP
        [ $? -ne $TRUE ] && abort_v2 "failure while creating the mount point $MOUNT_POINT"
        log "created folder: \"$MOUNT_POINT\""
    }
    local DATA_PERMISSION=$($CMD_STAT -c "%a" $MOUNT_POINT) || abort "failure while reading $MOUNT_POINT permissions"
    if [ $DATA_PERMISSION -ne $MOUNT_POINT_MOD ]; then
      $CMD_CHMOD $MOUNT_POINT_MOD $MOUNT_POINT
      [ $? -ne $TRUE ] && abort "failure while setting permissions $MOUNT_POINT_MOD to $MOUNT_POINT"
    fi
#	[ ! -e "$PROC_DRBD" ] && abort_v2 "DRBD is not configured on the node"
	HW_TYPE=$(GetHwType)
	DRBD_DEVICE=$($CMD_DRBDADM sh-dev $DRBD_RESOURCE 2>/dev/null)
	NODE_ID=$(</etc/cluster/nodes/this/id)
	[ -z $NODE_ID ] && abort_v2 "NODE_ID received null,exiting..."
	#[ "$NODE_ID" == "$NODE_TWO" ] && SYSTM_DISK="/dev/eri_diskB"
	if [ -b $SYSTM_DISK ];then
            SYSTM_DISK="/dev/$(${CMD_LS} -l $SYSTM_DISK | ${CMD_AWK} '{print $NF}')"
    else
        abort_v2 "failure while fetching system disk $SYSTM_DISK"
    fi
}

# ------------------------------------------------------------------------
# This function, returns hardware type if the user invoked this command
function GetHwType() {
	local HW_TYPE=$(${CMD_HWTYPE}  --verbose | $CMD_AWK -F"=" '/hw-type/{print $2}')
        echo $HW_TYPE
}

# ------------------------------------------------------------------------
# This function, returns true if the user invoked this command is
# an ts-user
function is_rootuser(){
	if [ $ROOT_USER -eq $TRUE ]; then
		return $TRUE
	else
		return $FALSE
	fi
}

# ------------------------------------------------------------------------
# This function, returns true if the peer node exist, false otherwise
function is_peerexist(){
	local RHOST=$(</etc/cluster/nodes/peer/hostname)
	[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
	
	${CMD_PING} -c 1 -W 1 $RHOST &>/dev/null
	if [ $? -eq 0 ]; then  
		return $TRUE
	else
		return $FALSE
	fi
}

# ------------------------------------------------------------------------
# This function, authrorizes the user invoked this command.
function authorize(){
    # This command is invoked by
    # 1. LDAP User
    # 2. Trouble shooting User
    # 3. Root User (applicatoins)
    # The first argument of the command is user-name
    # For LDAP user, command is invoked with USER=ldap-user
    # For TS user, command is invoked with USER=ts-user
    # rest of the cases, command is invoked with USER=root-user
	# or no USER argument passed.
    local L_USER=$1

    ROOT_USER=$TRUE
    if [[ "$L_USER" =~ "C_USER=" ]]; then
		OPT_USER_ARG=$TRUE
		if [[ 	"$L_USER" != "C_USER=root-user" &&
				"$L_USER" != "C_USER=ldap-user" &&
				"$L_USER" != "C_USER=ts-user"   ]]; then
			abort_v2 'Autorization Error'
		fi		
        [ ! "$L_USER" == "C_USER=root-user" ] && ROOT_USER=$FALSE
    fi
	return
}

# ------------------------------------------------------------------------
# This function, prints the command usage if the user invoked is 
# ldap user on the stdout.
function usage_ouser(){

$CMD_CAT << HEREDOC
Usage:  
HEREDOC
        if [[ $HW_TYPE != 'VM' ]] ;then
        $CMD_CAT << HEREDOC
	$SCRIPT_NAME -a
HEREDOC
        fi
        $CMD_CAT << HEREDOC
	$SCRIPT_NAME -c [ -f]
	$SCRIPT_NAME -d [ -f]
	$SCRIPT_NAME -h
	$SCRIPT_NAME -k
	$SCRIPT_NAME -m [ -f]
	$SCRIPT_NAME -r [ -f]
	$SCRIPT_NAME -S state [-f]
	$SCRIPT_NAME -s
		
HEREDOC

	# If  help option is invoked, exit command with success code.
	[[ $OPT_HELP -eq $TRUE && $CMPTBLE_OPTS -eq $TRUE ]] && exit $exit_sucs
		
	# If not, exit_usage exit code.	
	exit $exit_usge
}

# ------------------------------------------------------------------------
# This function, prints the command usage if the user invoked is
# ts/root user on the stdout.
function usage_ruser(){
    $CMD_CAT << HEREDOC

Usage: 
	$SCRIPT_NAME --add|-m [--force|-f] [--verbose|-v]
	$SCRIPT_NAME [--assemble|-A ] [--mount|-M][--force|-f] [--verbose|-v]
	$SCRIPT_NAME [--disable|-D] [--unmount|-u] [--verbose|-v]
	$SCRIPT_NAME [--part|-p [<diskA/diskB>] [--lvm|-l] [--format|-F] [--mount|-M] [--force|-f] [--verbose|-v]
	$SCRIPT_NAME [--lvm|-l] [--format|-F] [--mount|-M] [--force|-f] [--verbose|-v]
	$SCRIPT_NAME --role|-o <primary/secondary> [--verbose|-v]
	$SCRIPT_NAME --create|-c [--verbose|-v] [--force|-f]
	$SCRIPT_NAME --is-mounted|-i [--verbose|-v]
	$SCRIPT_NAME --folder|-d [--verbose|-v]
HEREDOC
       	if [[ $HW_TYPE != 'VM' ]] ;then
        $CMD_CAT << HEREDOC
	$SCRIPT_NAME --smart-ctrl|-a
HEREDOC
       	fi
        $CMD_CAT << HEREDOC
	$SCRIPT_NAME --fs-check|-k
	$SCRIPT_NAME --recover|-r [--verbose|-v] [--force|-f]
	$SCRIPT_NAME --status|-s [--verbose|-v]
	$SCRIPT_NAME --sync|-S <pause/resume> [--verbose|-v][--force|-f]
	$SCRIPT_NAME --sync-speed|-U <sync-rate> [--verbose|-v]
	$SCRIPT_NAME --activate|-t [--verbose|-v] [--force|-f]
	$SCRIPT_NAME --deactivate|-T [--verbose|-v] [--force|-f]
	$SCRIPT_NAME --help|-h
	
HEREDOC

	# If  help option is invoked, exit command with success code.
	[[ $OPT_HELP -eq $TRUE && $CMPTBLE_OPTS -eq $TRUE ]] && exit $exit_sucs
		
	# If not, exit_usage exit code.	
	exit $exit_usge
}

# ------------------------------------------------------------------------
# The function invokes the right parse_cmdline function based on the user
# access
function parse_cmdline(){
	local rCode=$FALSE

	# check if the command is invoked with-out any parameter.
	[ $# -eq 0 ] && {	
		echo -e "Incorrect Usage!" 
		usage_ruser
	}

	# extract the hidden-user from the command-line
	authorize $@

	# check if we are root
	is_rootuser
	rCode=$?
	
	[[ $# -eq 1 && $rCode -eq $TRUE && $OPT_USER_ARG -eq $TRUE ]] && {
		echo -e "Incorrect Usage!" 
		usage_ruser
	}
	[[ $# -eq 1 && $rCode -eq $FALSE ]] && {
		echo -e "Incorrect Usage!" 
		usage_ouser
	}	

	is_rootuser   && parse_cmdline_ruser $*
	! is_rootuser && parse_cmdline_ouser $*
}

# ------------------------------------------------------------------------
# This function, parses the command line parameters of ldap-user
function parse_cmdline_ouser(){

    # shift one parameter further to get to the real parameters.
    shift
	
    local PARAMETERS=$*
	SCRIPT_OPTS="$SCRIPT_NAME $*"
    local OPTIONS='a c d f m h k r:: S: s::'
	$CMD_GETOPT --quiet --quiet-output --options="$OPTIONS" -- "$@"
	rCode=$?
	[ $rCode -ne $TRUE ] && { 
		echo -e "Incorrect Usage!" 
		usage_ouser
	}	
	
	local ARGS="$@"
	eval set -- "$ARGS"
	
	# Make sure to handle the cases for all the options listed in OPTIONS
	# and LONG_OPTIONS and to fill up the right script-wide variables.
	while [ $# -gt 0 ]; do		
		case "$1" in
			-a)
		 if [[ $HW_TYPE == 'VM' ]] ;then
                                OPT_SMRTCTL=$FALSE
                                echo -e "Incorrect Usage!"
                                usage_ouser
                                else

                [ $OPT_SMRTCTL -eq $TRUE ] && DBLE_PARAM=$TRUE
                OPT_SMRTCTL=$TRUE
                FULL_OPT_LIST="${FULL_OPT_LIST}smart-ctrl"
		fi
            ;;
			-c)	
				[ $OPT_CREATE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_CREATE=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}create "
			;;
			-d)	
				[ $OPT_FOLDER -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_FOLDER=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}folder "
			;;
			-f)	
				[ $OPT_FORCE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_FORCE=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}force "
			;;
			-h)	
				[ $OPT_HELP -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_HELP=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}help "
			;;
			-k)
				[ $OPT_FSCK -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_FSCK=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}fs-check"
			;;
			-m)
                [ $OPT_ADD -eq $TRUE ] && DBLE_PARAM=$TRUE
                OPT_ADD=$TRUE
                FULL_OPT_LIST="${FULL_OPT_LIST}add "
            ;;
			-r)	
				[ $OPT_RECOVER -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_RECOVER=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}recover "
			;;
			-S)	
				[ $OPT_SYNC -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_SYNC=$TRUE
				if [[ $2 =~ ^-.*$ ]]; then				
					abort "The $1 option needs an argument to be specified."
				else
					OPT_SYNC_ARG=${2:-''}
					OPT_SYNC_ARG=$( echo "$OPT_SYNC_ARG" | $CMD_TR '[:lower:]' '[:upper:]')
					shift				
				fi				
				FULL_OPT_LIST="${FULL_OPT_LIST}sync "
			;;
			-s)	
				[ $OPT_STATUS -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_STATUS=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}status "
			;;
			*)
				echo -e "Incorrect Usage!"
				usage_ouser
			;;
		esac		
		shift
	done
	
	options_check_ouser
	return $?
}

# ------------------------------------------------------------------------
# This function, parses the command line parameters of tsusers as well
# as root user
function parse_cmdline_ruser(){

    # shift one parameter further to get to the real parameters.
	[ $OPT_USER_ARG -eq $TRUE ] && shift

	local PARAMETERS=$*
	local rCode
	local OPTIONS='a:: A c D d F f H h k M m n i o: p:: r S: s t T U:: u v l'
	local LONG_OPTIONS='add add-peer assemble create folder disable format force lvm smart-ctrl help fs-check \
						is-mounted mount role: part:: recover sync: \
						status activate deactivate sync-speed:: unmount verbose'
	
	$CMD_GETOPT --quiet --quiet-output --longoptions="$LONG_OPTIONS" --options="$OPTIONS" -- "$@"
	rCode=$?
	[ $rCode -ne $TRUE ] && {
		echo -e "Incorrect Usage!"
		usage_ruser
	}	
	
	local ARGS="$@"
	eval set -- "$ARGS"
	
	# Make sure to handle the cases for all the options listed in OPTIONS
	# and LONG_OPTIONS and to fill up the right script-wide variables.
	while [ $# -gt 0 ]; do		
		case "$1" in
			--add|-m)
				[ $OPT_ADD -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_ADD=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}add "
			;;
            --add-peer|-n)
				[ $OPT_ADD_PEER -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_ADD_PEER=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}add-peer "
			;;
			--assemble|-A)				
				[ $OPT_ASSEMBLE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_ASSEMBLE=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}assemble "
			;;
			--create|-c)
				[ $OPT_CREATE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_CREATE=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}create "
			;;
			--lvm|-l)
				[ $OPT_LVM -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_LVM=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}lvm "
			;;
			--folder|-d)
				[ $OPT_FOLDER -eq $TRUE ] && DBLE_PARAM=$TRUE	
				OPT_FOLDER=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}folder "
			;;
			--disable|-D)
				[ $OPT_DISABLE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_DISABLE=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}disable "
			;;
			--format|-F)
				[ $OPT_FORMAT -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_FORMAT=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}format "
			;;
			--force|-f)
				[ $OPT_FORCE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_FORCE=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}force "
			;;
			--help|-h)
				[ $OPT_HELP -eq $TRUE ] && DBLE_PARAM=$TRUE	
				OPT_HELP=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}help "
			;;
			--smart-ctrl|-a)
				if [[ $HW_TYPE == 'VM' ]] ;then
				OPT_SMRTCTL=$FALSE
				echo -e "Incorrect Usage!"
                                usage_ruser
				else
				[ $OPT_SMRTCTL -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_SMRTCTL=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}smart-ctrl "
				fi
			;;
			--fs-check|-k)
				[ $OPT_FSCK -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_FSCK=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}fs-check "
			;;
			--is-mounted|-i)
				[ $OPT_IS_MOUNTED -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_IS_MOUNTED=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}is-mounted "
			;;
			--mount|-M)	
				[ $OPT_MOUNT -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_MOUNT=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}mount "
			;;
			--role|-o)	
				[ $OPT_ROLE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_ROLE=$TRUE	
				if [[ $2 =~ ^-.*$ ]]; then				
					abort "The $1 option needs an argument to be specified."
				else
					OPT_ROLE_ARG=${2:-''}
					OPT_ROLE_ARG=$( echo "$OPT_ROLE_ARG" | $CMD_TR '[:lower:]' '[:upper:]')
					shift				
				fi				
				FULL_OPT_LIST="${FULL_OPT_LIST}role "
			;;
			--part|-p)	
				[ $OPT_PART -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_PART=$TRUE
				if [[ $# -gt 1 && -n "$2" && ! $2 =~ ^-.*$ ]]; then
					OPT_PART_ARG=${2:-''}
					OPT_PART_ARG=$( echo "$OPT_PART_ARG" | $CMD_TR '[:lower:]' '[:upper:]')		
					shift
				fi				
				FULL_OPT_LIST="${FULL_OPT_LIST}part "
			;;
			--recover|-r)
				[ $OPT_RECOVER -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_RECOVER=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}recover "
			;;
			--sync|-S)	
				[ $OPT_SYNC -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_SYNC=$TRUE
				if [[ $2 =~ ^-.*$ ]]; then				
					abort "The $1 option needs an argument to be specified."
				else
					OPT_SYNC_ARG=${2:-''}
					OPT_SYNC_ARG=$( echo "$OPT_SYNC_ARG" | $CMD_TR '[:lower:]' '[:upper:]')
					shift				
				fi				
				FULL_OPT_LIST="${FULL_OPT_LIST}sync "
			;;
			--status|-s)
				[ $OPT_STATUS -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_STATUS=$TRUE			
				FULL_OPT_LIST="${FULL_OPT_LIST}status "
			;;
			--activate|-t)	
				[ $OPT_ACTIVATE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_ACTIVATE=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}activate "
			;;
			--deactivate|-T)
				[ $OPT_DEACTIVATE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_DEACTIVATE=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}deactivate "
			;;	
			--sync-speed|-U)
				[ $OPT_SYNC_SPEED -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_SYNC_SPEED=$TRUE
				if [[ $# -gt 1 && -n "$2" && ! $2 =~ ^-.*$ ]]; then				
					OPT_SYNC_SPEED_ARG=${2:-''}					
					shift				
				fi					
				FULL_OPT_LIST="${FULL_OPT_LIST}sync-speed "
			;;			
			--unmount|-u)				
				[ $OPT_UNMOUNT -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_UNMOUNT=$TRUE				
				FULL_OPT_LIST="${FULL_OPT_LIST}unmount "
			;;			
			--verbose|-v)
				[ $OPT_VERBOSE -eq $TRUE ] && DBLE_PARAM=$TRUE
				OPT_VERBOSE=$TRUE
				FULL_OPT_LIST="${FULL_OPT_LIST}verbose "
			;;
			*)
				echo -e "Incorrect Usage!"
				usage_ruser
			;;
		esac		
		shift
	done
	options_check_ruser
	return $?
}

# ------------------------------------------------------------------------
# This funtion checks for the mutually exclusive optoins invoked by the
# ldap user
function options_check_ouser(){
		
	local FULL_OPT_NUMBER=$( echo $FULL_OPT_LIST | $CMD_WC -w 2>$ERR_TMP )
	is_traceon && echo -e "(TRACE:) recognized options: [$FULL_OPT_LIST]"	
	local OPTION
	local COMPATIBLE_OPTIONS=''	
	
	# check if double parameter is in the input.
	[ $DBLE_PARAM -eq $TRUE ] && {
		echo -e "Incorrect Usage!"
		usage_ouser
	}
	
	# raidmgr -m [-f]
	if [ $OPT_ADD -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force'
		OPTION='add'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr -c [-f]
	if [ $OPT_CREATE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force'
		OPTION='create'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr -d [-f]
	if [ $OPT_FOLDER -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force'
		OPTION='folder'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr --help|-h
	if [ $OPT_HELP -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='help'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --smart-ctrl|-a
	if [ $OPT_SMRTCTL -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='smart-ctrl'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr --fs-check|-k
	if [ $OPT_FSCK -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='fs-check'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr -r [-f]
	if [ $OPT_RECOVER -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force'
		OPTION='recover'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr -s
	if [ $OPT_STATUS -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='status'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr -S <pause|resume> [-f]
	if [ $OPT_SYNC -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force'
		OPTION='sync'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	

	[[ $OPT_FORCE -eq $FALSE && $OPT_HELP -eq $FALSE && $OPT_STATUS -eq $FALSE  && $OPT_FSCK -eq $FALSE && $OPT_SMRTCTL -eq $FALSE ]] && {
        if ! confirm; then
            abort "Command aborted by user" $exit_cmnd_abrt
        fi
    }
	
	# check if the input args received are from our list
	options_check_args
	
	# things are good-to-go so-far. launch invoker to process the options
	invoker
}

# ------------------------------------------------------------------------
# This function checks if the options provided by the ts-user or root user 
# are mutually exclusive. 
function options_check_ruser(){
		
	local FULL_OPT_NUMBER=$( echo $FULL_OPT_LIST | $CMD_WC -w 2>$ERR_TMP )
	is_traceon && echo -e "(TRACE:) recognized options: [$FULL_OPT_LIST]"	
	local OPTION
	local COMPATIBLE_OPTIONS=''	
	
	# check if double parameter is in the input.
	[ $DBLE_PARAM -eq $TRUE ] && {
		echo -e "Incorrect Usage!"
		usage_ruser
	}
	# raidmgr --add|-m [--force|-f] [--verbose|-v]
	if [ $OPT_ADD -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force verbose'
		OPTION='add'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
    # raidmgr --add-peer|-n [--force|-f] [--verbose|-v]
	if [ $OPT_ADD_PEER -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='force verbose'
		OPTION='add-peer'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --assemble|-A [--format|-F] [--mount|-M] [--force|-f] [--verbose|-v]
	if [ $OPT_ASSEMBLE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='format mount force verbose'
		OPTION='assemble'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr --unmount|-u [--disable|-d] [--verbose|-v]
	if [ $OPT_UNMOUNT -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='disable verbose'
		OPTION='unmount'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --create|-c  [--verbose|-v] [--force|-f]
	if [ $OPT_CREATE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose force'
		OPTION='create'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr --role|-o <primary/secondary> [--part|-p] [--force|-f] [--verbose|-v]
	if [ $OPT_ROLE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='part lvm force verbose'
		OPTION='role'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --disable|-d [--unmount|-u] [--force|-f] [--verbose|-v]
	if [ $OPT_DISABLE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='unmount force verbose'
		OPTION='disable'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr [--format|-F] [--lvm|-f] [--part|-p] [--assemble|-a] [--mount|-M] [--force|-f] [--verbose|-v]
	if [ $OPT_FORMAT -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='part lvm assemble mount force verbose'
		OPTION='format'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr --help|-h
	if [ $OPT_HELP -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='help'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr --smart-ctrl|-a
	if [ $OPT_SMRTCTL -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='smart-ctrl'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi
	# raidmgr --fs-check|-k
	if [ $OPT_FSCK -eq $TRUE ]; then
		COMPATIBLE_OPTIONS=''
		OPTION='fs-check'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr --is-mounted|-i [--verbose|-v]
	if [ $OPT_IS_MOUNTED -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose'
		OPTION='is-mounted'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --folder|-d [--verbose|-v]
	if [ $OPT_FOLDER -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose'
		OPTION='folder'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --mount|-M [--assemble|-a] [--part|-p][--lvm|-l][--format|-F] [--persistent|-P] [--force|-F] [--verbose|-v]
	if [ $OPT_MOUNT -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='assemble part lvm format persistent force verbose'
		OPTION='mount'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --part|-p [--lvm|-l] [--format|-f] [--mount|-M] [--role|-o] [--force|-f] [--verbose|-v]
	if [ $OPT_PART -eq $TRUE ]; then
		[[ $OPT_FORMAT -eq $FALSE && $OPT_MOUNT -eq $TRUE ]] && abort "Mount option should be allowed on Formated disk"
		COMPATIBLE_OPTIONS='lvm format mount role force verbose'
		OPTION='part'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	if [ $OPT_VERBOSE -eq $TRUE ]; then
		local COUNT=0
		for OPT in $FULL_OPT_LIST;do
			[ $OPT != "verbose" ] && ((COUNT++))
		done
		[[ $COUNT -eq 0 ]] && {
			echo -e "Incorrect Usage!"
			usage_ruser
		}
	fi
	# raidmgr --lvm|-l [--format|-f][--mount|-M] [--force|-f] [--verbose|-v]
	if [ $OPT_LVM -eq $TRUE ]; then
		[[ $OPT_FORMAT -eq $FALSE && $OPT_MOUNT -eq $TRUE ]] && abort "Mount option should be allowed on Formated disk"
		COMPATIBLE_OPTIONS='part format mount role force verbose'
		OPTION='lvm'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
        fi
	# raidmgr --recover|-r [--verbose|-v] [--force|-f]
	if [ $OPT_RECOVER -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose force'
		OPTION='recover'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --sync-speed <rate> [--verbose|-v]
	if [ $OPT_SYNC_SPEED -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose'
		OPTION='sync-speed'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --status|-s [--verbose|-v]
	if [ $OPT_STATUS -eq $TRUE ];then
		COMPATIBLE_OPTIONS='verbose'
		OPTION='status'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr --sync|-S <pause|resume> [--verbose|-v][--force|-f]
	if [ $OPT_SYNC -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose force'
		OPTION='sync'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	# raidmgr --activate|-t [--verbose|-v] [--force|-f]
	if [ $OPT_ACTIVATE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose force'
		OPTION='activate'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi		
	# raidmgr --deactivate|-T [--verbose|-v] [--force|-f]
	if [ $OPT_DEACTIVATE -eq $TRUE ]; then
		COMPATIBLE_OPTIONS='verbose force'
		OPTION='deactivate'
		check_options_compatibility "$OPTION" "$COMPATIBLE_OPTIONS" "$FULL_OPT_LIST"
	fi	
	
	# check if the input args received are from our list
	options_check_args
	
	# things are good-to-go so-far. launch invoker to process the options	
	invoker
}

# ------------------------------------------------------------------------
# The function shall check the parameters received to this command are 
# expected by the command
function options_check_args(){
	if [ $OPT_SYNC -eq $TRUE ]; then	
		[[ "$OPT_SYNC_ARG" != 'RESUME' && "$OPT_SYNC_ARG" != 'PAUSE' ]] && {
			is_rootuser && abort "Invalid parameter [$OPT_SYNC_ARG] received"
			! is_rootuser && {
				echo -e "Incorrect Usage!" 
				usage_ouser
			}	
		}	
	fi
	if [ $OPT_ROLE -eq $TRUE ]; then	
		[[ "$OPT_ROLE_ARG" != 'PRIMARY' && "$OPT_ROLE_ARG" != 'SECONDARY' ]] && {
			is_rootuser && abort "Invalid parameter [$OPT_ROLE_ARG] received"			
		}	
	fi
	if [ $OPT_ADD -eq $TRUE ]; then
		[[ "$OPT_ADD_ARG" != 'DISKA' && "$OPT_ADD_ARG" != 'DISKB' &&
		   "$OPT_ADD_ARG" != ''  ]] && {
		   is_rootuser && abort "Invalid parameter [$OPT_ADD_ARG] received"
		   ! is_rootuser && {
				echo -e "Incorrect Usage!" 
				usage_ouser
			}	
		}
	fi
	if [ $OPT_PART -eq $TRUE ]; then
		[[ "$OPT_PART_ARG" != 'DISKA' && "$OPT_PART_ARG" != 'DISKB' &&
		   "$OPT_PART_ARG" != '' ]] && {
		   is_rootuser && abort "Invalid parameter [$OPT_PART_ARG] received"
		   ! is_rootuser && {
				echo -e "Incorrect Usage!" 
				usage_ouser
			}	
		}
		if [ -n "$OPT_PART_ARG" ]; then
			[[ "$NODE_ID" -eq "$NODE_ONE" && "$OPT_PART_ARG" == 'DISKB' ]] && {
				[ $OPT_LVM -eq $TRUE ] && OPT_LVM=$FALSE
				REMOTE_DISK="DISKB"
			}
			[[ "$NODE_ID" -eq "$NODE_TWO" && "$OPT_PART_ARG" == 'DISKA' ]] && {
				[ $OPT_LVM -eq $TRUE ] && OPT_LVM=$FALSE
				REMOTE_DISK="DISKA"
			}
		fi
		[ "$NODE_ID" -eq "$NODE_ONE" ] && {
			THIS_DISK='diskA'
			PEER_DISK='diskB'
		}
		[ "$NODE_ID" -eq "$NODE_TWO" ] && {
			THIS_DISK='diskB'
			PEER_DISK='diskA'
		}
	fi
	if [ $OPT_SYNC_SPEED -eq $TRUE ]; then
		[ -z "$OPT_SYNC_SPEED_ARG" ] && RESET_SPEED=$TRUE		
		[ ! -z "$OPT_SYNC_SPEED_ARG" ] && {
			local VALID_INPUT=$TRUE
			# extracting the numeric value from the given input.
			# example: In 120K, 120 is extracted
			local NUMERIC=$( echo ${OPT_SYNC_SPEED_ARG%?})
			[ -z "$NUMERIC" ] && VALID_INPUT=$FALSE
			[[ ! "$NUMERIC" =~ ^[0-9]+$ ]] && VALID_INPUT=$FALSE
			
			# extracting the charactor value from the given input.
			# example: In 120K, K is extracted
			local CHAR=${OPT_SYNC_SPEED_ARG##${OPT_SYNC_SPEED_ARG%?}}
			# we shall not accept, if the extracted value is 
			# other than K, M, G.
			CHAR=$( echo "$CHAR" | $CMD_TR '[:lower:]' '[:upper:]')
			[ -z "$CHAR" ] && VALID_INPUT=$FALSE
			[[ ! "$CHAR" =~ ^K$|^M$|^G$|^k$|^m$|^g$ ]] && VALID_INPUT=$FALSE
			
			# check for the valid range
			[[ VALID_INPUT -eq $TRUE && $NUMERIC -lt 1 ]] && VALID_INPUT=$FALSE
			[[ "$CHAR" =~ ^K$|^k$ ]] && {
				if test $NUMERIC -gt 4194304 2>/dev/null; then
					VALID_INPUT=$FALSE
				fi	
			}
			[[ "$CHAR" =~ ^M$|^m$ ]] && {
				if test $NUMERIC -gt 4096 2>/dev/null; then
					VALID_INPUT=$FALSE
				fi	
			}
			[[ "$CHAR" =~ ^G$|^g$ ]] && {
				if test $NUMERIC -gt 4 2>/dev/null; then
					VALID_INPUT=$FALSE
				fi
			}
			[ $VALID_INPUT -eq $FALSE ] && {
				is_rootuser && abort "Invalid parameter [$OPT_SYNC_SPEED_ARG] received"
				# this option is not available for non-root user, anyway adding
				# the check, just in case we would like to give this option to 
				# non-root user as well!
				! is_rootuser && {
					echo -e "Incorrect Usage!"
					usage_ouser
				}
			}	
		}
	fi
}

# ------------------------------------------------------------------------
# The function is used to check if the $DRBD_RESOURCE is configured
function is_configured(){
	trace_enter $FUNCNAME $*
	local rCode=$FALSE
        $CMD_DRBDADM status $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
	[ $? -eq 0 ] &&	rCode=$TRUE
	trace_leave $FUNCNAME
	return $rCode
}

# ------------------------------------------------------------------------
# The function return $TRUE if the drbd configured on the local node is 
# primary, $FALSE otherwise.
function is_primary(){
        local ROLE=$($CMD_DRBD_STATUS role $DRBD_RESOURCE local)
	[[ "$ROLE" =~ ^Primary$ ]] && return $TRUE
	return $FALSE
}

# ------------------------------------------------------------------------
# The function return $TRUE if the drbd configured on the peer node is 
# primary, $FALSE otherwise.
function is_peer_primary(){
        local P_ROLE=$($CMD_DRBD_STATUS role $DRBD_RESOURCE peer)
	[[ "$P_ROLE" =~ ^Primary$ ]] && return $TRUE
	return $FALSE
}

# ------------------------------------------------------------------------
# The function return $TRUE if the drbd configured on the local node 
# has disk state 'UpToDate', $FALSE otherwise.
function is_uptodate(){
        local DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE local)
	[[ "$DSTATE" =~ ^UpToDate$ ]] && return $TRUE
	return $FALSE
}

# ------------------------------------------------------------------------
# The function returns the physical identifiers where to find the datadisks
# on the hardware specified as parameter.
function get_valid_phy(){
	[ $# -lt 2 ] && abort_v2 "function \"$FUNCNAME\": missing parameter"
	[[ ! $1 =~ ^LEFT$|^RIGHT$ ]] && abort_v2 "function \"$FUNCNAME\": parameter \"$1\" in the wrong format"
	local PHY=''
	case "$2" in
		GEP2)
			[ "$1" == 'LEFT'  ] && PHY=7
			[ "$1" == 'RIGHT' ] && PHY=3
		;;
		GEP1)
			[ "$1" == 'LEFT'  ] && PHY=0
			[ "$1" == 'RIGHT' ] && PHY=4
		;;
		VM)
			[ "$1" == 'LEFT'  ] && PHY=0
			[ "$1" == 'RIGHT' ] && PHY=1
		;;
		*)
			abort_v2 "function \"$FUNCNAME\": parameter \"$2\" in the wrong format"
	esac
	echo $PHY
}

# ------------------------------------------------------------------------
function do_force(){
	OPT_FORCE=$TRUE
}

# ------------------------------------------------------------------------
function do_check(){
	trace_enter $FUNCNAME $*
	local rCode=$FALSE
	[ ! -b 	"$1" ] && rCode=$TRUE
	# extra needed checks will be added later-on
	trace_enter $FUNCNAME
	return $rCode
}

# ------------------------------------------------------------------------
function do_lvm() {
	trace_enter $FUNCNAME $*
	local PART_DATA=''
	local VG_SIZE_GB=''
	local VG_SIZE_MB=''
  local LVM_SIZE=''
	local VG_X=''
	local LV_X=''
	# To define volume group and logical volume names
	local LV_X=(eri-data-lv)
	local VG_X=(eri-data-vg)
	local PART_DATA=$PART_DATA_LV
	[ -z "$DRBD_DATA_DISKS" ] && disk_finder

	# cleanup existing logical volumes
	if [ -b $PART_DATA ];then
		${CMD_DMSETUP} remove $PART_DATA --force >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "failed to remove existing Logical volume $PART_DATA" $exit_rmlv_eror
	fi
	${CMD_LVS} $PART_DATA >$OUT_TMP 2>$ERR_TMP
	[ $? -eq 0 ] && {
		${CMD_LVREMOVE} $PART_DATA >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "failed to remove existing Logical volume $PART_DATA" $exit_rmlv_eror
	}

	# cleanup existing Volume Group(VG)
	${CMD_VGS} $VG_X >$OUT_TMP 2>$ERR_TMP
	[ $? -eq 0 ] && {
		${CMD_VGREDUCE}	--removemissing $VG_X >$OUT_TMP 2>$ERR_TMP
		[ $? -eq 0 ] && {
			${CMD_VGREMOVE} $VG_X >$OUT_TMP 2>$ERR_TMP
	  		[ $? -ne 0 ] && abort "failed to remove existing Volume Group $VG_X" $exit_rmlv_eror
		}
	}
	
	# cleanup existing Physical volumes (PV)
	for PV in $DRBD_DATA_DISKS;do
		${CMD_PVS} $PV >$OUT_TMP 2>$ERR_TMP
		[ $? -eq 0 ] && {
			${CMD_PVREMOVE} $PV >$OUT_TMP 2>$ERR_TMP
			[ $? -ne 0 ] && abort "failed to remove existing Physical Volume $PV" $exit_rmlv_eror
		}
	done

	# Partitions sdc1/sdd1/sdb1 are created. First check 
	# if partitioned disk is labled as physical volume.
	# If not create physical volumes by using pvcreate command.
	MESSAGE="Creating physical volume structure..."
	is_verbose && echo -n "$MESSAGE"
	for DD in $DRBD_DATA_DISKS;do
		${CMD_PVCREATE} -ff $DD >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "failed to create physical volume" $exit_lvmx_eror
	done
	MESSAGE=" success"
	log "$MESSAGE"
	is_verbose && echo "$MESSAGE"
	
	# Create Volume groups using "vgcreate" command.Already we 
	# have one or two PV's, we can create a volume group(VG).
	# first check if volume group is exist, If not create VG.
	MESSAGE="Creating volume group structure..."
	is_verbose && echo -n "$MESSAGE"
	${CMD_VGCREATE} $VG_X $DRBD_DATA_DISKS >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && abort "failed to create volume group" $exit_lvmx_eror
	MESSAGE=" success"
	log "$MESSAGE"
	is_verbose && echo "$MESSAGE"

	# claculating volume group size to create LVM
	# vg size will be in GB. and converting into MB
	##### BEGIN TR FIX HW73269 
	VG_SIZE=$( ${CMD_VGS} --units m 2>/dev/null | grep $VG_X | ${CMD_AWK} '{print $6}' )
        if echo $VG_SIZE | grep -q 'm'; then
                LVM_SIZE="$(echo $VG_SIZE | ${CMD_AWK} -F"." '{print $1}')"
                LVM_SIZE=$( expr $LVM_SIZE  - 10 )m
        else
                abort "VGS size type unknown" $exit_lvmx_eror
        fi

	# Create Logical Volume/s using "lvcreate" command.
	MESSAGE="Creating logical volume structure..."
	is_verbose && echo -n "$MESSAGE"
	${CMD_LVCREATE} --size ${LVM_SIZE} --name $LV_X $VG_X --yes >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && abort "failed to create lvm $LV_X" $exit_lvmx_eror
	##### END TR FIX: HW73269
	MESSAGE=" success"
	log "$MESSAGE"
	is_verbose && echo "$MESSAGE"

	${CMD_LVS} $PART_DATA >$OUT_TMP 2>$ERR_TMP
	[ $? -eq 0 ] && {
		${CMD_LVCHANGE} --available y $PART_DATA >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "failed to create lvm" $exit_lvmx_eror
	}

	# check if label created on newly created lvm.
	# Create Filesystem on Logical Volume/s using "mkfs" command
	MESSAGE="Creating File system on Logical Volume..."
	is_verbose && echo -n "$MESSAGE"
	${CMD_BLKID} -o value -s LABEL $PART_DATA | grep eri-data >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && {
		$CMD_MKFS_EXT3 -F -j -L eri-data $PART_DATA >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "failed to create label on lvm $LV_X" $exit_lvmx_eror
	}
	MESSAGE=" success"
	log "$MESSAGE"
	is_verbose && echo "$MESSAGE"

	# trigger udev, to create symlinks part_meta1/2
	check_symlinks

	# clear/create the meta storage device.
	create_md
	
	# activate up the DRBD_RESOURCE
	do_activate

	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_part(){
	trace_enter $FUNCNAME $*
	local MESSAGE=''
	local DISK=''
	local OPTS=$ARGS
	local PART=''
	local SNGLE_PART=''
	local DISK_SIZE_KB=''
	local DISK_SIZE_MB=''
	local DATA_SIZE_MB=''

	if [[ ! -z "$REMOTE_DISK" && "$REMOTE_DISK" == "$OPT_PART_ARG" ]];then
        ! is_peerexist && abort "Peer node is not responding, add operation can not be performed" $exit_addx_peer
        is_peer_primary && abort "Partitioning is not allowed on activated Resource" $exit_addx_peer
        local RHOST=$(</etc/cluster/nodes/peer/hostname)
        [ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
		MESSAGE="Performing disk \"$PEER_DISK\" partitioning..."
		is_verbose && echo -n "$MESSAGE"
		$CMD_SSH $RHOST $CMD_DRBDMGR $OPTS >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "$MESSAGE... failed" $exit_addx_addx
		MESSAGE="  success"
		log "$MESSAGE"
		is_verbose && echo "$MESSAGE"
		trace_leave $FUNCNAME
		return $exit_sucs
	else
		is_configured && {
			[ $OPT_FORCE -eq $FALSE ] && abort "Device already has partition , use the --force switch to force the partitioning" $exit_part_conf
			# Stopping formatting on local node,if peer is already Primary.
			# Here check for FORMAT option is invoked.
			[ $OPT_FORMAT -eq $TRUE ] && {
				is_peer_primary && abort "Format not allowed on activated Resource" $exit_frmt_prim
			}
			is_mounted && do_unmount
			do_deactivate
			[ $? -ne 0 ] && abort "De-Activation of Resource failed" $exit_part_disb
		}	

		disk_finder
		for PART in $PARTBLE_DISKS;do
			do_check $PART
			if [[ $? -eq $FALSE && $OPT_FORCE -eq $FALSE ]]; then 
				abort "Device \"$PART\" already has partition \"$DRBD_DATA_DISKS\", use the --force switch to force the partitioning" $exit_part_part
			fi
		done
		MESSAGE="Performing disk \"$THIS_DISK\" partitioning..."
		is_verbose && echo -n "$MESSAGE"
		# Partitioning of single data disk
		# For single disk PARTBLE_DISKS are sdc/sdd/sdb.
		[ -n  "$DUBLE_PART_DISK" ] && {
			for DISK in $DUBLE_PART_DISK;do
				# Remove the existing partitions
				$CMD_PARTED --script $DISK rm 1 >$OUT_TMP 2>$ERR_TMP
				$CMD_PARTED --script $DISK rm 2 >$OUT_TMP 2>$ERR_TMP

				# Find the data disk size in KB and MB's
				((DISK_SIZE_KB=$($CMD_BLOCKDEV --getsize64 $DISK)/ 1000 ))
				((DISK_SIZE_MB=$($CMD_BLOCKDEV --getsize64 $DISK)/1000/1000))
				((DATA_SIZE_MB=DISK_SIZE_MB - META_SIZE_MB))

				# Clear the data disk partition table and data
				$CMD_DD if=/dev/zero of=$DISK bs=$DISK_SIZE_KB count=1 >$OUT_TMP 2>$ERR_TMP 
				[ $? -ne 0 ] && {
					echo " falied"
					abort "Failure while erasing the partition table of the disk \"$DISK\"" $exit_part_ddxx
				}
				# Create label with the gpt format And check if,
				# gpt partition table is created.
				$CMD_PARTED --script $DISK mklabel gpt >$OUT_TMP 2>$ERR_TMP
				if [ $($CMD_PARTED --script $DISK -ms print | grep :gpt: | wc -l) -ne 1 ];then
					echo " failed"
					abort "Failure while applying lable to the disk \"$DISK\"" $exit_part_labl
				fi
				# create primary partition And check if partition is created
				$CMD_PARTED --script --align optimal $DISK unit MB mkpart primary 1 $DATA_SIZE_MB >$OUT_TMP 2>$ERR_TMP
				if [ $($CMD_PARTED --script $DISK -m print | grep ^1 | wc -l ) -ne 1 ];then
					echo " failed"
					abort "Failure while creating primary partiton of the disk \"$DISK\"" $exit_part_prm1
				fi
				# Create second primary partition for only GEP1/2
				$CMD_PARTED --script --align optimal $DISK unit MB mkpart primary $DATA_SIZE_MB $DISK_SIZE_MB >$OUT_TMP 2>$ERR_TMP
				if [ $($CMD_PARTED --script $DISK -m print | grep ^2 | wc -l ) -ne 1 ];then
					echo " failed"
					abort "Failure while creating second primary partiton of the disk \"$DISK\"" $exit_part_prm2
				fi
			done
		}
		# Partitioning of Multiple disks in case of GEP4/5
		# For multi disk PARTBLE_DISKS are sdc and sdd.
		# Here partitioning will be sdc1 and sdd1 
		[ ! -z "$SNGLE_PART_DISK" ] && {
			for SNGLE_PART in $SNGLE_PART_DISK;do
				# Remove the existing partitions
				$CMD_PARTED --script $SNGLE_PART rm 1 >$OUT_TMP 2>$ERR_TMP
	
				# Find the data disk size in KB and MB's
				((DISK_SIZE_KB=$($CMD_BLOCKDEV --getsize64 $SNGLE_PART)/ 1000 ))
				((DISK_SIZE_MB=$($CMD_BLOCKDEV --getsize64 $SNGLE_PART)/1000/1000))

				# Clear the data disk partition table and data
				$CMD_DD if=/dev/zero of=$SNGLE_PART bs=$DISK_SIZE_KB count=1 >$OUT_TMP 2>$ERR_TMP
				[ $? -ne 0 ] && {
					echo " falied"
					abort "Failure while erasing the partition table of the disk \"$SNGLE_PART\"" $exit_part_ddxx
				}
				# Create label with the gpt format And check if,
				# gpt partition table is created.
				$CMD_PARTED --script $SNGLE_PART mklabel gpt >$OUT_TMP 2>$ERR_TMP
				if [ $($CMD_PARTED --script $SNGLE_PART -ms print | grep :gpt: | wc -l) -ne 1 ];then
					echo " failed"
					abort "Failure while applying lable to the disk \"$SNGLE_PART\"" $exit_part_labl
				fi
				# create primary partition And check if partition is created
				$CMD_PARTED --script --align optimal $SNGLE_PART unit MB mkpart primary 1 $DISK_SIZE_MB >$OUT_TMP 2>$ERR_TMP
				if [ $($CMD_PARTED --script $SNGLE_PART -m print | grep ^1 | wc -l ) -ne 1 ];then
					echo " failed"
					abort "Failure while creating primary partiton of the disk \"$SNGLE_PART\"" $exit_part_prm1
				fi
			done
		}
	fi
	MESSAGE=" success"
	log "$MESSAGE"
	is_verbose && echo "$MESSAGE"
	$CMD_PARTPROBE $DISK >$OUT_TMP 2>$ERR_TMP		
	sync >$OUT_TMP 2>$ERR_TMP
	$CMD_BLOCKDEV --rereadpt $DISK >$OUT_TMP 2>$ERR_TMP
	trace_leave $FUNCNAME
	return $exit_sucs
}
	
# ------------------------------------------------------------------------
function create_md(){
	trace_enter $FUNCNAME $*
	local MESSAGE="Creating the md device after partitioning..."
	$CMD_DRBDADM create-md $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP << COMMANDS
yes
yes
COMMANDS
	[ $? -ne 0 ] && abort "$MESSAGE failed" $exit_cret_mdxx
	MESSAGE="$MESSAGE success"
	log "$MESSAGE"
	is_verbose && echo -e "$MESSAGE"		
	trace_leave $FUNCNAME
}

# ------------------------------------------------------------------------
function do_activate(){
	trace_enter $FUNCNAME $*
	local MESSAGE=''
	# check if the resource is already-active
	is_configured
	[ $? -eq 0 ] && {
		# check the connection status, try conneting peer if it is StandAlone.
		L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
		[ "$L_CSTATE" == "StandAlone" ] && $CMD_DRBDADM connect $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
		L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
		[[ "$L_CSTATE" == "PausedSyncS"  || "$L_CSTATE" == "PausedSyncT" ]] && {
			OPT_SYNC_ARG='RESUME'
			do_sync
			[ $? -ne 0 ]  && {
				abort "Resource activated, but failed to start the synchronization process" $exit_actv_sync
			} 
		}	
		MESSAGE="Resource is already active"
		#MESSAGE="DRBD Resource [$DRBD_RESOURCE] is already active"
		log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
		trace_leave $FUNCNAME
		return $exit_sucs
	}
	
	# launch drbdadm to activate $DRBD_RESOURCE
	$CMD_DRBDADM up $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && {
		abort "Activating Resource... failed" $exit_actv_upxx
	}
	
	# check the connection status, try conneting peer if it is StandAlone.
	L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
	[ "$L_CSTATE" == "StandAlone" ] && $CMD_DRBDADM connect $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
	L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
	[[ "$L_CSTATE" == "PausedSyncS" || "$L_CSTATE" == "PausedSyncT" ]] && {
		OPT_SYNC_ARG='RESUME'
		do_sync
		[ $? -ne 0 ]  && {
			abort "Resource activated, but failed to start the synchronization process" $exit_actv_sync
		}
	}	
	MESSAGE="Activating Resource... success"
	log "$MESSAGE"
	is_verbose && echo -e "$MESSAGE"
	trace_leave $FUNCNAME
}

# ------------------------------------------------------------------------
function do_deactivate(){
	trace_enter $FUNCNAME $*
	local MESSAGE=''
	local rCode
	# check if the resource is already de-activated
	is_configured
	[ $? -ne 0 ] && {
		MESSAGE="Resource is already disabled/de-activated"
		log "$MESSAGE"
		echo -e "$MESSAGE"
		trace_leave $FUNCNAME
		return $exit_sucs
	}
	
	is_primary
	rCode=$?
	[ $rCode -eq $TRUE ] && {
		is_mounted && {
			[ $OPT_FORCE -eq $FALSE ] && abort "Resource is mounted, use the --force switch to force disable" $exit_dact_forc
			do_unmount
		}
		# demote the DRBD_RESOURCE first
		$CMD_DRBDADM secondary $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
		if [ $? -ne 0 ]; then
			abort "Unable to disable/demote Resource " $exit_dact_scon
		fi
	}
	
	# launch drbdadm to de-activate $DRBD_RESOURCE
	$CMD_DRBDADM down $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] &&  {
		abort "Deactivating Resource... failed" $exit_dact_down
	}
	MESSAGE="Deactivating Resource... success"
	log "$MESSAGE"
	is_verbose && echo -e "$MESSAGE"
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_assemble() {
	trace_enter $FUNCNAME $*
	local MESSAGE=''
					
	is_configured 
	if [ $? -ne 0 ]; then
		abort "Resource is not configured" $exit_asmb_eror
	fi
	
	# Check if local drbd is primary and dstate is already uptodate
	is_primary && is_uptodate && {
		MESSAGE="Resource is already assembled"
		log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
		trace_leave $FUNCNAME
		return $exit_sucs
	}
	
	# Check if the peer drbd is already primary
	is_peer_primary && abort "Peer node is already primary" $exit_asmb_eror
	
	# ask drbd to take the primary-role
	OPT_ROLE_ARG='PRIMARY'
	do_role
	if ! is_primary || ! is_uptodate ; then
		# final try before bailout
		is_mounted && do_unmount
		
		# deactivate drbd resouce now.
		do_deactivate
		
		# activate drbd resouce now.
		do_activate	
		
		# ask drbd to take the primary-role
		OPT_ROLE_ARG='PRIMARY'
		do_role		
	fi
	if ! is_primary && ! is_uptodate ; then
		# bail-out
		abort "Performing Resource assembly... failed" $exit_asmb_eror
	fi
	                  
	MESSAGE="Performing Resource assembly... success"
	log "$MESSAGE"
	is_verbose && echo -e "$MESSAGE"
	
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_format(){
	trace_enter $FUNCNAME $*
	local MESSAGE=''
	! is_configured && abort "Resource is not configured" $exit_frmt_conf
	
	# FIXME: Assuming that Maiden-Installation happens on SC-2-1 first
	# 	   	 and SC-2-2 later. so force SC-2-1 to take the primary role.
	OPT_ROLE_ARG='SECONDARY'
	[[ $NODE_ID -eq $NODE_ONE || $OPT_CREATE -eq $TRUE ]] && {
		# clear the bitmap as necessary and do not worry abt the return code.
		$CMD_DRBDADM new-current-uuid --clear-bitmap $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
		MESSAGE="Clearing new-current-uuid bitmap..success"
		log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
		
		# mark the drbd to primary if it is only the resource configured yet.
		# Also, mark the OPT_FORCE indicator to true for the force primary role setup.
		OPT_FORCE=$TRUE
		OPT_ROLE_ARG='PRIMARY'
	}
	# set the drbd role 
	do_role
	
	is_primary
	[ $? -eq $FALSE ] && abort "Resource is not active, formatting not allowed" $exit_frmt_prim
	
	if ! is_mounted; then
		MESSAGE='Formatting in progress...'
		log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
		local OPT='-q -F'
		is_verbose && OPT=''
		$CMD_MKFS_EXT3 $OPT $DRBD_DEVICE &> /dev/null
		[ $? -ne $TRUE ] && abort 'Formatting failed' $exit_frmt_fail
		MESSAGE='Formatting done'
		is_verbose && log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
	else
        abort "Resource is already mounted, formatting not allowed." $exit_frmt_mntx
	fi
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
# This function mounts the DRBD_DEVICE if not already mounted
function do_mount(){
	trace_enter $FUNCNAME
	local MESSAGE=''

	if ! is_mounted; then
		$CMD_MOUNT -o "$FSTAB_OPTIONS" -t "$FILE_SYS" "$DRBD_DEVICE" "$MOUNT_POINT" >$OUT_TMP 2>$ERR_TMP
		[ $? -ne $TRUE ] && abort 'Mount Operation... failed' $exit_mntx_fail
		MESSAGE="Mount Operation... successful"
		log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
	else
		MESSAGE="Resource is already mounted"
		log "$MESSAGE"
		is_verbose && echo -e "$MESSAGE"
	fi

	# following condition is applicable only in case of double node
	# restore and the first board is replaced.
	if [ -f /cluster/home/board_type ]; then
		board_type=$( cat /cluster/home/board_type)
		[ $board_type == 'new' ] && {
			do_folder
                       
                       
		}	
	fi

	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
# This function unmounts the DRBD_DEVICE if not already un-mounted.

function do_unmount(){
        trace_enter $FUNCNAME
        local COM_MOUNT='/data/opt/ap/nbi_fuse'
        if is_mounted; then
		log "Executing Umount Operation on data mount point.."
                ## This is temporary fix now            
                $CMD_UMOUNT "$COM_MOUNT" >$OUT_TMP 2>$ERR_TMP
                [  $? -ne 0 ] && fusermount -u "$COM_MOUNT" >$OUT_TMP 2>$ERR_TMP
                ## temporary fix ends now
                $CMD_UMOUNT "$MOUNT_POINT" >$OUT_TMP 2>$ERR_TMP
                if [ $? -ne 0 ]; then
                        busyfs_data
                        local PIDS="$(get_pids)"
                        log "here a list of pids:commands having open handles on the drbd1 device:"
                        while read P; do
                                log "$P"
                        done < <(echo "$PIDS")
                        abort "Unmount operation... failed" $exit_umnt_bsyf
                fi
                is_verbose && echo "Unmount operation... successful"
        else
                is_verbose && echo "Resource already unmounted"
        fi
        trace_leave $FUNCNAME
        return $exit_sucs
}

# ------------------------------------------------------------------------
# This function, lists the active users of the mount $MOUNT_POINT of
# DRBD_DEVICE
function get_pids(){	
	local PIDS=''
	PIDS=$($CMD_FUSER -m $MOUNT_POINT $DRBD_DEVICE 2>$ERR_TMP)	
	if [ -n "$PIDS" ]; then
		PIDS="$(echo $PIDS | $CMD_TR '[:space:]' '\n' | $CMD_AWK ' !x[$0]++')"
		for P in $PIDS; do			
			echo -e "$P:\"$($CMD_PS -p $P -o cmd h)\""
		done
	fi
}

# ------------------------------------------------------------------------
function do_disable(){
	trace_enter $FUNCNAME $*
	local MESSAGE=''
	local rCode
	
	# check if the resource is already disabled
	! is_configured && abort "Resource is not configured" $exit_disb_conf
	
	is_primary
	rCode=$?
	[ $rCode -eq $TRUE ] && {
		is_mounted && {
			[ $OPT_FORCE -eq $FALSE ] && abort "$DRBD_DEVICE is mounted, use the --force switch to force disable" $exit_disb_forc
			do_unmount
		}
		# demote the DRBD_RESOURCE now
		$CMD_DRBDADM secondary $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP
		if [ $? -ne 0 ]; then
			abort "Unable to disable DRBD Resource [$DRBD_RESOURCE] " $exit_disb_scon
		fi
	}
	
	MESSAGE="Disabling DRBD Resource [$DRBD_RESOURCE]... success"	
	log "$MESSAGE"
	echo -e "$MESSAGE"
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_add(){
	trace_enter $FUNCNAME $*
	local MESSAGE='Add operation on peer disk'
	local rCode
	
	# general validations
	! is_configured && {
		 abort "Resource is not configured" $exit_addx_conf
	}

	! is_primary && {
		 abort "Resource is not active, operation not allowed" $exit_addx_prim	
	}

	# addition operation is performed always on the peer node, adding local disk
	# will be supported based on the need.
	! is_peerexist && abort "Peer node is not responding, add operation can not be performed" $exit_addx_peer
	# peer node is up
	local RHOST=$(</etc/cluster/nodes/peer/hostname)
	[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
	
	# check if the peer disk is available and healthy
        local L_DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE local)
        local P_DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE peer)	
	[[ "$L_DSTATE" == 'UpToDate' && "$P_DSTATE" == 'UpToDate' ]] && {
		MESSAGE='Add operation on peer disk... failed'
		abort "$MESSAGE" $exit_addx_addx
	}
	
	# check if the local disk is healthy and sync is in progress and peer is not healthy.
	[[ "$L_DSTATE" == 'UpToDate' && "$P_DSTATE" != 'UpToDate' ]] && {
		# check cstate of drbd
		local CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
		[[ "$CSTATE" == 'SyncSource' || "$CSTATE" == 'PausedSyncS'&& $OPT_FORCE -eq $FALSE ]] && {
			MESSAGE='Resource synchronization is already in progress'
			abort "$MESSAGE" $exit_addx_sync
		}	
	}
			
    	local OPTS='--add-peer --force'
	is_verbose && OPTS="${OPTS} --verbose"
	$CMD_SSH $RHOST $CMD_DRBDMGR $OPTS >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && abort "$MESSAGE... failed" $exit_addx_addx

	local L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
	[[ "$L_CSTATE" != 'Connected' || "$L_CSTATE" != 'WFConnection' ]] &&
	$( $CMD_DRBDADM connect $DRBD_RESOURCE 2>$ERR_TMP)

	log "$MESSAGE... success"
	is_verbose && console_print "$MESSAGE... success"
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function __signal_agent__(){
	trace_enter $FUNCNAME $*
	local AGENTD='/opt/ap/apos/bin/apos_ha_rdeagentd'
	#kill -l
	#...
	#29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
	#35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
	#39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
	#...
	# if there is a change in intepretation of signal numbers, following
	# code should be updated with the right numbers
	local EVENT_REBUILD=35 #SIGRTMIN+1  
	local MESSAGE='Signaling(EVENT_REBUILD) to HAAGENT'
	$( $CMD_KILLALL -$EVENT_REBUILD -q -e $AGENTD &>/dev/null)
	if [ $? -ne 0 ]; then
		log "$MESSAGE... failed"
	else 
		log "$MESSAGE... success"
	fi
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_add_peer(){
	trace_enter $FUNCNAME $*
	# signal agent to stop monitor for a while
	__signal_agent__

	is_configured && do_deactivate

	# partition if required
	do_part
    
	# lvm setup if required	
	do_lvm
    
	# signal agent to resume monitor
	__signal_agent__
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_help(){
	trace_enter $FUNCNAME $*
	is_rootuser && usage_ruser
	! is_rootuser && usage_ouser
	trace_leave $FUNCNAME
}
#-------------------------------------------------------------------------
function faulty_disk() {
	local DISK=''
	[ $NODE_ID -eq 1 ] && DISK="Disk on AP node B NOT OK"
	[ $NODE_ID -eq 2 ] && DISK="Disk on AP node A NOT OK"
	echo $DISK
	return $TRUE
}

#-------------------------------------------------------------------------
function do_smrtctl(){
	trace_enter $FUNCNAME $*
	local DISK_STATUS=$TRUE
	local MESSAGE=''

	[ ! -f $CMD_SMARTCTL ] && abort "smartctl command not found" $exit_smrt_eror 
	if is_peerexist; then
		# peer node is up
		local RHOST=$(</etc/cluster/nodes/peer/hostname)
		[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
		# fetch the peer disks
		peer_disk_finder
		for DISK in $PEER_DATA_DISKS; do
			$CMD_SSH $RHOST $CMD_SMARTCTL --all $DISK 2>>$ERR_TMP | grep -i 'overall-health' | grep -q 'PASSED'
			[ $? -ne 0 ] && { 
				DISK_STATUS=$FALSE
				break
			}
		done

		if [ $DISK_STATUS -eq $TRUE ];then
			MESSAGE="Disks are OK"
		else	
			MESSAGE="$(faulty_disk)"
		fi
	fi

	console_print "$MESSAGE"
	trace_leave $FUNCNAME
}

#-----------------------------------------------------------------------------
# This function is to check a linux ext2/ext3/etx4 file system
# The exit code returned by e2fsck is the sum of the following conditions:
# rCode=0  --> No errors
# rCode=1  --> File system errors corrected
# rCode=2  --> File system errors corrected, system should be booted
# rCode=4  --> File system errors left uncorrected
# rCode=8  --> Operational error
# Return: the exit status is OK in case if rCode=0,1,2,4 and NOT OK otherwise.

function do_fsck(){
        trace_enter $FUNCNAME
        ! is_primary && abort "DRBD Resource [$DRBD_RESOURCE] is not active, file system check  not allowed" $exit_fsck_eror
        echo
        echo -n  "File system check..."
        local launchcommand
        local corrupt_file
        local fs_count_cluster=0
        local fs_count_data=0
        local fs_count_rcluster=0
        local fs_dmesg_cluster=0
        local fs_dmesg_data=0
        local fs_dmesg_rdata=0
        local fs_dmesg_rcluster=0
            for path in data cluster
            do
              corrupt_file=""
              launchcommand="ls -lR /$path 2> /dev/null | grep \"\?\" | awk '{print \$NF}' |tr '\n' ',' | sed 's/.$//'"
              corrupt_file=$(eval $launchcommand)
              if [ "$corrupt_file" != "" ]; then
        #        echo -e "\nDisk Corruption detected, partition $path. Contact next level of support"
                [ "$path" == "cluster" ] && fs_count_cluster=1
                [ "$path" == "data" ] && fs_count_data=1
              fi
              if [ "$path" == "cluster" ]; then  # check health of remote node
                  # Launch command on remote node
                  if is_peerexist; then
                        # peer node is up
                        local RHOST=$(</etc/cluster/nodes/peer/hostname)
                    corrupt_file=$($CMD_SSH $RHOST $launchcommand 2>/dev/null)
                  fi
                  if [ "$corrupt_file" != "" ]; then
                    fs_count_rcluster=1
                  fi
                fi
            done
        HW_TYPE=$(GetHwType)
        local fs_dmesg=$( echo $(dmesg -T | grep -i "EXT4-fs error" | awk '{print substr($0,index($0,"device")+7,4)}'))
        if [[ $HW_TYPE == 'VM' || $HW_TYPE =~ 'GEP5' || $HW_TYPE =~ 'GEP7' ]];then
                [ "$fs_dmesg" == "dm-0" ] && fs_dmesg_data=1
        fi
        if [[ $HW_TYPE == 'VM' || $HW_TYPE =~ 'GEP5' || $HW_TYPE =~ 'GEP7' ]];then
                [ "$fs_dmesg" == "dm-1" ] && fs_dmesg_cluster=1
        fi

        if [[ $HW_TYPE == 'GEP1' || $HW_TYPE == 'GEP2' ]] ;then
                [ "$fs_dmesg" == "dm-0" ] && fs_dmesg_cluster=1
        fi
        if [[ $HW_TYPE == 'GEP1' || $HW_TYPE == 'GEP2' ]] ;then
                [ "$fs_dmesg" =~ "md0" ] && fs_dmesg_data=1
        fi

        local fs_rdmesg=$( echo $($CMD_SSH $RHOST dmesg -T | grep -i "EXT4-fs error" | awk '{print substr($0,index($0,"device")+7,4)}'))
        if [[ $HW_TYPE == 'VM' || $HW_TYPE =~ 'GEP5' || $HW_TYPE =~ 'GEP7' ]];then
                [ "$fs_rdmesg" == "dm-0" ] && fs_dmesg_rdata=1
        fi
        if [[ $HW_TYPE == 'VM' || $HW_TYPE =~ 'GEP5' || $HW_TYPE =~ 'GEP7' ]];then
                [ "$fs_rdmesg" == "dm-1" ] && fs_dmesg_rcluster=1
        fi

        if [[ $HW_TYPE == 'GEP1' || $HW_TYPE == 'GEP2' ]] ;then
                [ "$fs_rdmesg" == "dm-0" ] && fs_dmesg_rcluster=1
        fi
        if [[ $HW_TYPE == 'GEP1' || $HW_TYPE == 'GEP2' ]] ;then
                [ "$fs_rdmesg" =~ "md0" ] && fs_dmesg_data=1
        fi
        [[ $fs_count_cluster == 1 || $fs_dmesg_cluster == 1 ]] && echo -e "\nDisk Corruption detected, partition cluster. Contact next level of support"
        [[ $fs_count_rcluster == 1 || $fs_dmesg_rcluster == 1 ]] && echo -e "\nDisk Corruption detected on peer($RHOST), partition Cluster. Contact next level of support"
        [[ $fs_count_data == 1 || $fs_dmesg_data == 1 || $fs_dmesg_rdata == 1 ]] && echo -e "\nDisk Corruption detected, partition Data. Contact next level of support"
        [[ $fs_count_cluster == 0 && $fs_count_data == 0 && $fs_dmesg_cluster == 0 && $fs_count_rcluster == 0 && $fs_dmesg_rcluster && $fs_dmesg_data == 0 && $fs_dmesg_rdata == 0 ]] && echo -e "\nNo disk corruption detected."

        echo
        trace_leave $FUNCNAME
}

# ------------------------------------------------------------------------
function do_recover(){
	trace_enter $FUNCNAME $*
	local rCode
	local MESSAGE=''
	local RHOST=$(</etc/cluster/nodes/peer/hostname)
	[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
	
	! is_configured && abort "Resource is not configured." $exit_rcvy_conf
	
        local L_DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE local)
        local P_DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE peer)

	[[ "$L_DSTATE" == 'UpToDate' && "$P_DSTATE" == 'UpToDate' ]] && {
		MESSAGE='Data disks are found healthy, recovery operation is not allowed'
		log "$MESSAGE"
		is_verbose && console_print "$MESSAGE"
		trace_leave $FUNCNAME
		return $exit_sucs
	}

	# recovery shall be always on peer disk and of-course, the current node role
	# shall be primary and disk state shall be UpToDate to perform the recovery
	# on the other node.
	! is_primary && abort "Resource is not active, recovery not allowed" $exit_rcvy_prim
	[ "$L_DSTATE" != 'UpToDate' ] && abort "No healthy data disk is found to perform the recovery" $exit_rcvy_disk
	
	# de-activate/disable the peer drbd role
	$CMD_SSH $RHOST $CMD_DRBDMGR --deactivate --force >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && {
		MESSAGE="Disabling Resource on peer node failed"
		log "$MESSAGE"
		is_verbose && console_print "$MESSAGE"
		trace_leave $FUNCNAME
		abort "Disabling Resource on peer node failed" $exit_rcvy_disb
	}
	
	# activate the drbd resouce on peer node now.
	$CMD_SSH $RHOST $CMD_DRBDMGR --activate --force >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && abort "Reactivating Resource on peer node failed" $exit_rcvr_actv
	
	# check if the sync of the other node is started.
	local L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP | $CMD_AWK -F '/' '{print $1}')
	[[ "$L_CSTATE" == 'SyncSource' || "$L_CSTATE" == 'SyncTarget' ]] && MESSAGE="Recovery success."
	[[ "$L_CSTATE" == 'PausedSyncS' || "$L_CSTATE" == 'PausedSyncT' ]] && {
		OPT_SYNC_ARG='RESUME'
		do_sync	
	}
	
	# perform in-validate to force start the sync from the primary node.
        local P_DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE peer)
	[[ "$L_CSTATE" == 'Connected' && "$P_DSTATE" != 'UpToDate' ]] && {		
		$( $CMD_DRBDADM invalidate $DRBD_RESOURCE >$OUT_TMP 2>$ERR_TMP)
		rCode=$?
		[ $rCode -ne 0 ] && abort "Attempt to initiate the synchronization process failed" $exit_rcvr_invd		
	}
	MESSAGE="Recovery operation... success"
	log "$MESSAGE"
	is_verbose && console_print "$MESSAGE"
	trace_leave $FUNCNAME	
	return $exit_sucs
}

# ------------------------------------------------------------------------
# This function is supported, if there is an option to remove diskA/diskB.
# As of now, it is not needed and should be muted.
function do_remove_local() {
	trace_enter $FUNCNAME
	# check the drbd role and if it is primary, remove operation
	# is not allowed on active drbd.
	is_primary 
	[ $? -eq $TRUE ] && {
		MESSAGE='Resource is already active, remove operation not allowed'
		log "$MESSAGE"
		abort "$MESSAGE" $exit_rlcl_actv
	}
	
	local L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
	if [[ "$L_CSTATE" == 'SyncSource' || "$L_CSTATE" == 'SyncTarget' && $OPT_FORCE -eq $FALSE ]]; then
		abort "Remove operation failed [Synchronization is in progress], use force(-f) option to force remove" $exit_rlcl_cste
	fi
	
	# pause the sync-process before we disconnect.
	[[ "$L_CSTATE" == 'SyncSource' || "$L_CSTATE" == 'SyncTarget' ]] && do_sync 'PAUSE'
	
	# deactivate drbd configuration
	do_deactivate	
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_remove_peer(){
	trace_enter $FUNCNAME
	is_peerexist
    [ $? -ne 0 ] && {
		MESSAGE='Remove operation failed [Peer node does not exist].'
		log "$MESSAGE"
		trace_leave $FUNCNAME
		abort "$MESSAGE" $exit_rper_nexs
    }
	is_peer_primary && abort "Peer node is already primary." $exit_asmb_eror
    local L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
	[[ "$L_CSTATE" == 'SyncSource' || "$L_CSTATE" == 'SyncTarget' ]] && {
		[ $OPT_FORCE -eq $FALSE ] &&
		abort "Remove operation failed [Synchronization is in progress], use force(-f) option to force remove" $exit_rper_sync
	}
	# pause the sync-process before we disconnect.
	[[ "$L_CSTATE" == 'SyncSource' || "$L_CSTATE" == 'SyncTarget' ]] && do_sync 'PAUSE'
	
	# do we need to disconnect the cluster nodes first, before deactivating the drbd resource??.
	# if we do, we might need to connect it manually for every operation. proceeding without
	# disconnecting for now.
	
	# launch raidmgr command, to remove $DRBD_RESOURCE configuration.
	local RHOST=$(</etc/cluster/nodes/peer/hostname)
	[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
	
	local OPTS='--deactivate'
	is_verbose && OPTS="${OPTS} --verbose"
	[ $OPT_FORCE -eq $TRUE ] && OPTS="${OPTS} --force"
	$CMD_SSH $RHOST $CMD_DRBDMGR $OPTS 
	[ $? -ne 0 ] && abort "Remove operation failed" $exit_rper_rmve
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_remove(){
	trace_enter $FUNCNAME
	local rCode=''
	local MESSAGE=''
	
	! is_configured && abort "Resource is not configured." $exit_rmve_conf
	do_remove_peer
	
	MESSAGE='Remove operation... success'
	log "$MESSAGE"
	is_verbose && console_print "$MESSAGE"
	trace_leave $FUNCNAME
	return $exit_sucs 
}

# ------------------------------------------------------------------------
function do_status(){
	trace_enter $FUNCNAME $*
	local DRBD_ROLE_HEALTHY=$FALSE
	local DRBD_CSTATE_HEALTHY=$FALSE
	local DRBD_DSTATE_HEALTHY=$FALSE
	local DRBD_DSTATE_FAULTY=$FALSE
	local LOCAL_DRBD_ROLE=''
	local PEER_DRBD_ROLE=''
	local LOCAL_DRBD_DISK=''
	local PEER_DRBD_DISK=''
	local DRBD_CSTATE=''
	local FDISK=''
	local PEER_DISK=''
	local DRBD_STATUS='UP'
	local MESSAGE="Faulty Disk"
	local REBUILD=''
	
	# this funtion print-out the console when in verbose
	_printout_(){
		echo -e "										"
		echo -e "DRBD Resource ($DRBD_RESOURCE) Status:	"
		echo -e "======================================	"
		echo -e "Local Role: $LOCAL_DRBD_ROLE			"
		echo -e "Peer  Role: $PEER_DRBD_ROLE			"
		echo -e "======================================	"
		echo -e "Local Disk: $LOCAL_DRBD_DISK			"
		echo -e "Peer  Disk: $PEER_DRBD_DISK			"
		echo -e "======================================	"
		echo -e "Connection: $DRBD_CSTATE				"
		echo -e "======================================	"
	}
	
	is_configured
	rCode=$?
	[ $rCode -eq $FALSE ] && {
		is_verbose && _printout_
		DRBD_STATUS='DOWN'
		is_verbose && abort "DRBD Status: $DRBD_STATUS" $exit_stat_conf
		! is_verbose && abort "$DRBD_STATUS" $exit_stat_conf
	}
	{ # fetching role
                LOCAL_DRBD_ROLE=$($CMD_DRBD_STATUS role $DRBD_RESOURCE local)
                PEER_DRBD_ROLE=$($CMD_DRBD_STATUS role $DRBD_RESOURCE peer)
                if [[ "$LOCAL_DRBD_ROLE" =~ "ERROR" ]]; then
                  LOCAL_DRBD_ROLE=""
                fi
                if [[ "$PEER_DRBD_ROLE" =~ "ERROR" ]]; then
                  PEER_DRBD_ROLE=""
                fi
		# if local node drbd role is not primary, we can conclude DRBD is DOWN
		[ "$LOCAL_DRBD_ROLE" != 'Primary' ] && {
			# DRBD role is not primary on the local node
			DRBD_STATUS='DOWN'	
		}
	}
	{ # fetching cstate
		DRBD_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
                DRBD_REPSTATE=$($CMD_DRBD_STATUS repstate $DRBD_RESOURCE)
                if [ "$DRBD_REPSTATE" == "" ];then
                        DRBD_REPSTATE=$DRBD_CSTATE
                fi
                local HEALTHY_REPSTATE="StandAlone WFConnection Connected StartingSyncS StartingSyncT \
								WFBitMapS WFBitMapT WFSyncUUID SyncSource SyncTarget PausedSyncS \
								PausedSyncT VerifyS VerifyT Connecting"
		for REPSTATE in $HEALTHY_REPSTATE
		do
			if [ "$REPSTATE" == "$DRBD_REPSTATE" ] ; then
				if [[ "$REPSTATE" == 'SyncSource' || "$REPSTATE" == 'SyncTarget' ]]; then
					# this means that synchronization is in progress. 
					# calculate the synchronization percentage.
					REBUILD=$($CMD_DRBDADM status $DRBD_RESOURCE 2>/dev/null | $CMD_GREP -w "SyncSource" | $CMD_AWK -F "done:" '{print $2}')
					[ "$DRBD_STATUS" != 'DOWN' ] && {
						DRBD_STATUS='DEGRADED'
						MESSAGE="(rebuild: ${REBUILD})"
					}	
				fi
				DRBD_CSTATE_HEALTHY=$TRUE
				break
			fi	
		done
		[ $DRBD_CSTATE_HEALTHY -eq $FALSE ] && DRBD_STATUS='DOWN'				
	}	
	{ # fetching dstate
        local HEALTHY_DSTATE="Attaching Consistent UpToDate"
        local FAULTY_DSTATE="Diskless Failed Negotiating DUnknown Outdated Inconsistent"
        LOCAL_DRBD_DISK=$( $CMD_DRBD_STATUS dstate $DRBD_RESOURCE local)
        PEER_DRBD_DISK=$( $CMD_DRBD_STATUS dstate $DRBD_RESOURCE peer)
		
		if [ $NODE_ID -eq $NODE_ONE ]; then
            PEER_DISK='Disk on AP node B'
            LOCAL_DISK='Disk on AP node A'
        else
            PEER_DISK='Disk on AP node A'
            LOCAL_DISK='Disk on AP node B'
		fi

        for DSTATE in $HEALTHY_DSTATE
        do
			if [ "$DSTATE" == "$LOCAL_DRBD_DISK" ]; then
				DRBD_DSTATE_HEALTHY=$TRUE
                break
            fi
        done

        for DSTATE in $FAULTY_DSTATE
        do
			if [ "$DSTATE" == "$LOCAL_DRBD_DISK" ]; then
				DRBD_DSTATE_FAULTY=$TRUE
                FDISK=$LOCAL_DISK
                break
            elif [ "$DSTATE" ==  "$PEER_DRBD_DISK" ]; then
				DRBD_DSTATE_FAULTY=$TRUE
                FDISK=$PEER_DISK
                break
            fi
        done

        [ $DRBD_DSTATE_FAULTY -eq $TRUE ] && {
			[ "$DRBD_STATUS" != 'DOWN' ] && DRBD_STATUS='DEGRADED'
        }
        [ $DRBD_DSTATE_HEALTHY -eq $FALSE ] && {
  			[ $DRBD_DSTATE_FAULTY -eq $FALSE ] && DRBD_STATUS='DOWN'
        }
    }
	is_verbose && _printout_
	[ $DRBD_STATUS == 'DOWN' ] && {
		is_verbose && abort "DRBD Status: $DRBD_STATUS" $exit_stat_drbd
		! is_verbose && abort "$DRBD_STATUS" $exit_stat_drbd
	}	
	[ $DRBD_STATUS == 'DEGRADED' ] && {
		is_verbose && {
			[ -z "$REBUILD" ] && abort "DRBD Status: $DRBD_STATUS\n$MESSAGE: $FDISK" $exit_stat_drbd	
			[ ! -z "$REBUILD" ] && abort "DRBD Status: $DRBD_STATUS $MESSAGE" $exit_stat_drbd
		}
		! is_verbose && {
			[ -z "$REBUILD" ] && abort "$DRBD_STATUS\n$MESSAGE: $FDISK" $exit_stat_drbd	
			[ ! -z "$REBUILD" ] && abort "$DRBD_STATUS $MESSAGE" $exit_stat_drbd
		}
	}	
	[ $DRBD_STATUS == 'UP' ] && {
		is_verbose && console_print "DRBD Status: $DRBD_STATUS"
		! is_verbose && console_print "$DRBD_STATUS"	
	}
	
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_sync(){
	trace_enter $FUNCNAME $*
	local rCode
	
	! is_configured && abort "Resource is not configured." $exit_sync_conf
	[ "$OPT_SYNC_ARG" == 'RESUME' ] && {
		# check if the sync is in already sync-state
		local L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
		local FLAG=$FALSE
		local ALLOWED="PausedSyncS PausedSyncT SyncSource SyncTarget"
		for CSTATE in $ALLOWED; do
			[ "$CSTATE" == "$L_CSTATE" ] && FLAG=$TRUE
		done
		[ $FLAG -eq $FALSE ] && abort "Resource synchronization process is completed" $exit_sync_resm
		[[ "$L_CSTATE" == 'SyncSource' || "$L_CSTATE" == 'SyncTarget' ]] && abort "Resource synchronization is already in progress" $exit_sync_csrs
		[ "$L_CSTATE" == 'PausedSyncT' ] && {
			local RHOST=$(</etc/cluster/nodes/peer/hostname)
			[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
			local OPTS="-S resume"
			[ $OPT_FORCE -eq $TRUE ] && OPTS="${OPTS} -f"
			is_verbose && OPTS="${OPTS} -v"
			$CMD_SSH $RHOST $CMD_DRBDMGR $OPTS >$OUT_TMP 2>$ERR_TMP
			[ $? -ne 0 ] && abort "Starting the synchronization process... failed" $exit_sync_resm
			console_print "Synchronization process on Resource started"
			trace_leave $FUNCNAME
			return $exit_sucs
		}
		
		# initiate resume-sync
		$CMD_DRBDADM resume-sync $DRBD_RESOURCE  >$OUT_TMP 2>$ERR_TMP
		rCode=$?
		[ $rCode -ne 0 ] && abort "Starting the synchronization process... failed" $exit_sync_resm
		console_print "Synchronization process on Resource started"
	}
	
	[ "$OPT_SYNC_ARG" == 'PAUSE' ] && {
		# check if the sync is in already paused-state
		L_CSTATE=$( $CMD_DRBD_STATUS cstate $DRBD_RESOURCE 2>$ERR_TMP)
		local FLAG=$FALSE
		local ALLOWED="PausedSyncS PausedSyncT SyncSource SyncTarget"
		for CSTATE in $ALLOWED; do
			[ "$CSTATE" == "$L_CSTATE" ] && FLAG=$TRUE
		done
		[ $FLAG -eq $FALSE ] && abort "Resource synchronization process is not active" $exit_sync_resm
		[[ "$L_CSTATE" == 'PausedSyncS' || "$L_CSTATE" == 'PausedSyncT' ]] && abort "Resource synchronization is already paused" $exit_sync_cspa
		[ "$L_CSTATE" == 'SyncTarget' ] && {
			local RHOST=$(</etc/cluster/nodes/peer/hostname)
			[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
			local OPTS="-S pause"
			[ $OPT_FORCE -eq $TRUE ] && OPTS="${OPTS} -f"
			is_verbose && OPTS="${OPTS} -v"
			$CMD_SSH $RHOST $CMD_DRBDMGR $OPTS >$OUT_TMP 2>$ERR_TMP
			[ $? -ne 0 ] && abort "Stopping the synchronization process on Resource... failed" $exit_sync_resm
			console_print "Stopping the synchronization process on Resource... success"
			trace_leave $FUNCNAME
			return $exit_sucs
		}
	
		# initiate pause-sync
		$CMD_DRBDADM pause-sync $DRBD_RESOURCE  >$OUT_TMP 2>$ERR_TMP
		rCode=$?
		[ $rCode -ne 0 ] && abort "Stopping the synchronization process on Resource... failed" $exit_sync_paus
		console_print "Stopping the synchronization process on Resource... success"
	}
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_is_mounted(){	
	trace_enter $FUNCNAME $*
	local rCode
	local MESSAGE=''

	is_mounted
	rCode=$?
	if [ $rCode -ne $TRUE ]; then
		MESSAGE="$DRBD_DEVICE is not mounted"	
	else
		MESSAGE="$DRBD_DEVICE is mounted to $MOUNT_POINT"
	fi	
	log "$MESSAGE"
	! is_verbose && echo -e "$MESSAGE"	
	
	trace_leave $FUNCNAME
	return $rCode
}

# ------------------------------------------------------------------------
# This function is used to create partitions and activate drbd on both 
# local and remote nodes. If the remote node is not up, drbd is created
# only on the local node.
function do_create(){
	trace_enter $FUNCNAME
	local OPT_FORCE=$TRUE
	
	if is_primary && is_uptodate; then
		abort "Resource is active, deactivate before proceeding with the creation" $exit_crte_prim
	fi	

	# Check if the peer drbd is already primary
	is_peer_primary && abort "Peer node is already primary, Creating DRBD Resource on passive node not allowed." $exit_crte_prim

	# create the partitions and activate drbd on local node
	do_part 
	
	# create Logical volumes
	do_lvm

	# check if the remote node is up.
	is_peerexist
	[ $? -eq 0 ] && {
		# peer node is up
		local RHOST=$(</etc/cluster/nodes/peer/hostname)
		[ -z $RHOST ] && abort_v2 "RHOST received null,exiting..."
		local OPTS='--part --lvm --role secondary --force'
		is_verbose && OPTS="${OPTS} --verbose"
		$CMD_SSH $RHOST $CMD_DRBDMGR $OPTS >$OUT_TMP 2>$ERR_TMP
		[ $? -ne 0 ] && abort "Resource creation on remote node failed" $exit_crte_dmgr
	}

	# format the drbd patition now.
	do_format
	
	is_verbose && console_print "Resource creation... success"
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_role(){
	trace_enter $FUNCNAME
	local OPTS=''
	local MESSAGE=''
	local ROLE=''
		
	# check if drbd resource drbd1 is configured.
	! is_configured && abort "Resource is not configured" $exit_role_conf

	if [ "$OPT_ROLE_ARG" == 'PRIMARY' ]; then
		OPTS='primary'
		[ $OPT_FORCE -eq $TRUE ] && OPTS="${OPTS} --force"
		MESSAGE="Promotion of Resource..."
	else
		OPTS='secondary'
		MESSAGE="Demotion of Resource..."
	fi
	
	# check if the role is already primary
	is_primary && {
		if [ "$OPT_ROLE_ARG" == 'PRIMARY' ]; then
			log "Resource is already primary"
			trace_leave $FUNCNAME
			return $exit_sucs
		fi	
	}
	
	# check if the role is already secondary
	! is_primary && {
		if [ "$OPT_ROLE_ARG" == 'SECONDARY' ]; then
			log "Resource is already secondary"
			trace_leave $FUNCNAME
			return $exit_sucs
		fi	
	}
	
	# check if the local disk state is healthy 
	local DSTATE=$($CMD_DRBD_STATUS dstate $DRBD_RESOURCE local )
	[ -z "$DSTATE" ] && abort "Local disk of Resource is not found" $exit_role_dste
	
	# If the local disk state is in valid state, then we are allowed
	# to promote/demote the drbd1 role
	local HEALTHY_DSTATE="Attaching Negotiating Inconsistent Consistent UpToDate"
	local IS_HEALTHY=$FALSE
	for L_DSTATE in $HEALTHY_DSTATE
		do
			if [ "$L_DSTATE" == "$DSTATE" ]; then
				IS_HEALTHY=$TRUE
				break
			fi			
	done
	[ $IS_HEALTHY -eq $FALSE ] && abort "$MESSAGE not allowed" $exit_role_invd
	$CMD_DRBDADM $OPTS $DRBD_RESOURCE  >$OUT_TMP 2>$ERR_TMP
	[ $? -ne 0 ] && abort "$MESSAGE failed " $exit_role_role
	
	local MESSAGE="$MESSAGE success"
	log "$MESSAGE"
	is_verbose && echo -e "$MESSAGE"	
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
function do_speed(){
	trace_enter $FUNCNAME
	local MESSAGE=''
		
	! is_configured && abort "Resource is not configured" $exit_sped_conf
	! is_primary && abort "Resource is not active, operation not allowed" $exit_sped_prim
	
	[ ! -z "$OPT_SYNC_SPEED_ARG" ] && {
		MESSAGE="Setting sync rate to $OPT_SYNC_SPEED_ARG..."
		$CMD_DRBDADM peer-device-options --resync-rate=$OPT_SYNC_SPEED_ARG --c-plan-ahead=0 $DRBD_RESOURCE
		[ $? -ne 0 ] && abort "$MESSAGE failed" $exit_sped_setx
		log "$MESSAGE success"
		is_verbose && echo -e "$MESSAGE success"	
	}
	
	[ -z "$OPT_SYNC_SPEED_ARG" ] && {
		MESSAGE="Re-setting sync rate to default..."
		$CMD_DRBDADM adjust $DRBD_RESOURCE
		[ $? -ne 0 ] && abort "$MESSAGE failed" $exit_sped_rset
		log "$MESSAGE success"
		is_verbose && echo -e "$MESSAGE success"	
	}
	
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
# check_options_compatibility <option> <compatible_options> <specified_options>
function check_options_compatibility(){
    local OPTION=$1
    local COMPATIBLE=$2
    local SPECIFIED=$3
    for SPE in $SPECIFIED; do
        CHECK=$FALSE
        if [ $SPE != $OPTION ]; then
            for COMP in $COMPATIBLE; do
                if [ $COMP == $SPE ]; then
                    CHECK=$TRUE
                    break
                fi
            done
            [ $CHECK -eq $FALSE ] && {
				is_rootuser && {
					CMPTBLE_OPTS=$FALSE
					echo -e "Incorrect Usage!"
					usage_ruser
				}	
				! is_rootuser && {
					CMPTBLE_OPTS=$FALSE
					echo -e "Incorrect Usage!" 
					usage_ouser
				}	
			}
        fi
    done
    return $TRUE
}

# ------------------------------------------------------------------------
# The function retrieves the device linked to the specified directory 
# structure.
function dir_to_device(){
	[ $# -lt 1 ] && abort_v2 "${FUNCNAME}: missing parameter"	
	local DIR="$($CMD_DIRNAME $1)"	
	[ ! -d "$DIR" ] && abort_v2 "${FUNCNAME}: $DIR is not valid"
	local BASEDIR=$(echo "$DIR" | sed  's@\/sas_device\/.*$@@g')
	local DEVICE=$($CMD_FIND ${BASEDIR}/target*/*/block/sd? -maxdepth 0 -type d | awk -F'/' '{print $NF}')
	if [[ ! -z ${DEVICE} && -b "/dev/${DEVICE}" ]]; then		
		echo "/dev/${DEVICE}"
		return $TRUE
	fi
	return $FALSE
}

# ------------------------------------------------------------------------
# The function retrieves the available disks in Node
function _disk_finder_1() {
	[ $NODE_ID -eq $NODE_ONE ] && SLOT=$(get_valid_phy LEFT $HW_TYPE)
	[ $NODE_ID -eq $NODE_TWO ] && SLOT=$(get_valid_phy RIGHT $HW_TYPE)
	for DIR in $($CMD_FIND /sys/devices | grep -E '/sys/devices/.*/host.*/port-.*/end_device-.*/sas_device/end_device-.*/phy_identifier$'); do
		local PHY=$(<${DIR})
		case "$PHY" in
			$SLOT)
				PARTBLE_DISKS="$(dir_to_device ${DIR})"
			;;
	    esac
    done
    DUBLE_PART_DISK="${PARTBLE_DISKS}"
    DRBD_DATA_DISKS="${PARTBLE_DISKS}1"
    DRBD_META_DISK="${PARTBLE_DISKS}2"
    return $TRUE
}

# ------------------------------------------------------------------------
function _disk_finder_2() {
	# In GEP4/5 single disk case, sdb is partitioned to multiple 
	# partitions and sdb6 and sdb7 are agreed to allot for DRBD META
	# and DATA DISKS

	PARTBLE_DISKS=''
	DRBD_DATA_DISKS="${SYSTM_DISK}7"
	DRBD_META_DISK="${SYSTM_DISK}6"
	return $TRUE
}


# ------------------------------------------------------------------------
function _disk_finder_3() {
    # In GEP4/5 multi disk case, DATA DISKS are sdb, sdc and sdd.
    # Followng partitions will takes place in case of multi disks.
    # 1.sdb7 for DRBD DATA and sdb6 for META DATA
    # 2.sdc1 for DRBD DATA
    # 3.sdd1 for DRBD DATA
    # Now DRDB_DATA_DISKS='/dev/sdb7 /dev/sdc1 /dev/sdd1'
	local DISK=''
	_disk_finder_2
	local diskC=$( readlink -f /dev/eri_diskC)
	local diskD=$( readlink -f /dev/eri_diskD)
	PARTBLE_DISKS="$diskC $diskD"
	SNGLE_PART_DISK="${PARTBLE_DISKS}"
	for DISK in $PARTBLE_DISKS;do
		DRBD_DATA_DISKS="$DRBD_DATA_DISKS ${DISK}1"
	done
	return $TRUE
}

# ------------------------------------------------------------------------
function _disk_finder_4() {
  # In ATLAS/ECM, DATA VOLUMES are attached to VM instance.
  # Here vd[bc]1 for DATA PART and vd[bc]2 for META PART
	# To avoid more impacts on raidmgr command, here SYSTEM_DISK
	# is used as DATA_DISK(i.e SYSTM_DISK=DATA_DISK) 
  DUBLE_PART_DISK="${SYSTM_DISK}"
  DRBD_DATA_DISKS="${SYSTM_DISK}1"
  DRBD_META_DISK="${SYSTM_DISK}2"

  return $TRUE
}

# ------------------------------------------------------------------------
function _disk_finder_5() {
        # In GEP7L_1600  and GEP7_128_1600  multi disk case, DATA DISKS are sdb and sdc.
        # Followng partitions will takes place in case of multi disks.
        # 1.sdb8 for DRBD DATA and sdb7 for META DATA
        # 2.sdc1 for DRBD DATA
        # Now DRDB_DATA_DISKS='/dev/sdb8 /dev/sdc1'
	local DISK=''
	_disk_finder_2
	local diskC=$( readlink -f /dev/eri_diskC)
	PARTBLE_DISKS="$diskC"
	SNGLE_PART_DISK="${PARTBLE_DISKS}"
	for DISK in $PARTBLE_DISKS;do
		DRBD_DATA_DISKS="$DRBD_DATA_DISKS ${DISK}1"
	done
	return $TRUE
}

# ------------------------------------------------------------------------
function peer_disk_finder() {

  PEER_SYSTEM_DISK=$($CMD_SSH $RHOST readlink -f /dev/eri_disk)

  if [[ $HW_TYPE == 'GEP5' || $HW_TYPE == 'GEP5-400' || $HW_TYPE == 'GEP7L-400' ]]; then
    PEER_DATA_DISKS="${PEER_SYSTEM_DISK}7"
    PEER_META_DISK="${PEER_SYSTEM_DISK}6"     
  elif [[ $HW_TYPE == 'GEP4-1600' || $HW_TYPE == 'GEP5-1200' || $HW_TYPE == 'GEP5-64-1200' ]]; then
    PEER_META_DISK="${PEER_SYSTEM_DISK}6"  
    PEER_DATA_DISKS="${PEER_SYSTEM_DISK}7"
  PEER_DISK_C=$($CMD_SSH $RHOST readlink -f /dev/eri_diskC)
  PEER_DISK_D=$($CMD_SSH $RHOST readlink -f /dev/eri_diskD)
    PEER_DATA_DISKS="$PEER_DATA_DISKS ${PEER_DISK_C}1 ${PEER_DISK_D}1"
  elif [[ $HW_TYPE == 'VM' ]]; then
    PEER_DATA_DISKS="${PEER_SYSTEM_DISK}1"
  elif [[ $HW_TYPE == 'GEP7L-1600' || $HW_TYPE == 'GEP7-128-1600'  ]]; then
    PEER_DATA_DISKS="${PEER_SYSTEM_DISK}7"
    PEER_META_DISK="${PEER_SYSTEM_DISK}6" 
    PEER_DISK_C=$($CMD_SSH $RHOST readlink -f /dev/eri_diskC)
    PEER_DATA_DISKS="$PEER_DATA_DISKS ${PEER_DISK_C}1"
  fi
  
  [[ -z "$PEER_DATA_DISKS" ]] && abort "No Disks Found" $exit_dsfk_eror
  return $TRUE
}

# ------------------------------------------------------------------------
# This is the only function allowed to define the content of the $DRBD_DISKS and
# $DRBD_DISKS_COUNT. This function is expected to populate disk info across the
# the hardware platforms.
function disk_finder(){

  if [[ $HW_TYPE == 'GEP1' || $HW_TYPE == 'GEP2' ]] ;then
    _disk_finder_1
    META_SIZE_MB=130 # roundedOff to 128MB by parted
  elif [[ $HW_TYPE == 'GEP5' || $HW_TYPE == 'GEP5-400' || $HW_TYPE == 'GEP7L-400' ]]; then
    _disk_finder_2
    META_SIZE_MB=256
  elif [[ $HW_TYPE == 'GEP4-1600' || $HW_TYPE == 'GEP5-1200' || $HW_TYPE == 'GEP5-64-1200' ]]; then
		_disk_finder_3
		META_SIZE_MB=256
		[ -z "$PARTBLE_DISKS" ] && abort "No Disks Found" $exit_dsfk_eror
  # In ECM/ATLAS VM multi disk is not supported for now
  elif [[ $HW_TYPE == 'VM' ]]; then
    _disk_finder_4
    META_SIZE_MB=256
  elif [[ $HW_TYPE == 'GEP7L-1600' || $HW_TYPE == 'GEP7-128-1600' ]]; then
    _disk_finder_5
    META_SIZE_MB=256
    [ -z "$PARTBLE_DISKS" ] && abort "No Disks Found" $exit_dsfk_eror
  fi

  # _disk_finder_x is supposted to populate PARTBLE_DISKS and
  # DRBD_DATA_DISKS and DRBD_META_DISK, if these are empty, bail-out
  [[ -z "$DRBD_DATA_DISKS" ||  -z "$DRBD_META_DISK" ]] && abort "No Disks Found" $exit_dsfk_eror

  check_disks
  return $TRUE
}

# ------------------------------------------------------------------------
function trigger_udev() {
    $CMD_UDEVADM control --reload-rules >$OUT_TMP 2>$ERR_TMP 
    $CMD_UDEVADM trigger --subsystem-match='block' >$OUT_TMP 2>$ERR_TMP
    $CMD_UDEVADM settle >$OUT_TMP 2>$ERR_TMP  
}

# ------------------------------------------------------------------------
# The function checks for the $DRBD_DISKS to be valid block-devices.
function check_disks(){

	local DISK=''
	local PART=''
	
	for DISK in $PARTBLE_DISKS;do
        [ ! -b "$DISK" ] && trigger_udev
        [ ! -b "$DISK" ] && abort "The expected partition \"$DISK\" have not been found" $exit_cdsk_part
    done
    
    if [ $OPT_PART -eq $FALSE ]; then
        for PART in $DRBD_DATA_DISKS;do
            [ ! -b "$PART" ] && trigger_udev
            [ ! -b "$PART" ] && abort "The expected partition \"$PART\" have not been found" $exit_cdsk_part
        done
        [ ! -b "$DRBD_META_DISK" ] && abort "The expected partition \"$DRBD_META_DISK\" have not been found" $exit_cdsk_part
    fi
	return $TRUE
}

# ------------------------------------------------------------------------
# The function checks if the symlinks for the partitions are created by udev.
function check_symlinks(){
	local PART_META=$PART_META_SLINK
	[ ! -b "$PART_META" ] && abort "The expected symlinks \"$PART_META\" have not been found" $exit_slnk_part
	return $TRUE
}

# ------------------------------------------------------------------------
function do_folder(){
    trace_enter $FUNCNAME
    local MESSAGE=''

	if ! is_mounted; then
		abort "Resource is not mounted, can not create the folder structure" $exit_fold_mntx
    fi

	# create folder structure first.
    $( $CMD_CONFIGAP -d >$OUT_TMP 2>$ERR_TMP)
    [ $? -ne 0 ] && abort "Error creating folder structure." $exit_fold_cfig
    is_verbose && echo -e "Creating folder structure... success"

	if ! $CMD_MOUNT | $CMD_GREP "$DRBD_RESOURCE" | $CMD_GREP -q cpftp; then
		# create virtual directory structure.
    	$( $CMD_VDIRCONF >$OUT_TMP 2>$ERR_TMP)
    	[ $? -ne 0 ] && abort "Error creating virtual folder structure." $exit_fold_vdir
    	is_verbose && echo -e "Creating virtual folder structure... success"
	fi		

    trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
# This function invokes functions based on the options specified.
function invoker(){
	trace_enter $FUNCNAME
	[ $OPT_FORCE		-eq $TRUE ] && do_force
	[ $OPT_PART			-eq $TRUE ] && do_part
	[ $OPT_CREATE		-eq $TRUE ] && do_create
    [ $OPT_ASSEMBLE		-eq $TRUE ] && do_assemble
	[ $OPT_LVM			-eq $TRUE ] && do_lvm
	[ $OPT_FORMAT		-eq $TRUE ] && do_format
	[ $OPT_MOUNT		-eq $TRUE ] && do_mount
   	[ $OPT_UNMOUNT		-eq $TRUE ] && do_unmount
	[ $OPT_DISABLE		-eq $TRUE ] && do_disable
	[ $OPT_ADD			-eq $TRUE ] && do_add
    [ $OPT_ADD_PEER		-eq $TRUE ] && do_add_peer
	[ $OPT_HELP			-eq $TRUE ] && do_help
	[ $OPT_SMRTCTL		-eq $TRUE ] && do_smrtctl
	[ $OPT_FSCK			-eq $TRUE ] && do_fsck
	[ $OPT_IS_MOUNTED	-eq $TRUE ] && do_is_mounted
	[ $OPT_SYNC_SPEED	-eq $TRUE ] && do_speed $OPT_SYNC_SPEED_ARG
	[ $OPT_RECOVER		-eq $TRUE ] && do_recover
	[ $OPT_FOLDER		-eq $TRUE ] && do_folder
	[ $OPT_ROLE			-eq $TRUE ] && do_role
	[ $OPT_SYNC			-eq $TRUE ] && do_sync $OPT_SYNC_ARG
	[ $OPT_STATUS   	-eq $TRUE ] && do_status
	[ $OPT_ACTIVATE		-eq $TRUE ] && do_activate
	[ $OPT_DEACTIVATE	-eq $TRUE ] && do_deactivate
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
# The function will return $TRUE if $DRBD_DEVICE is found mounted. $FALSE
# otherwise.
function is_mounted(){
    local EXIT_CODE=$TRUE
    local MESSAGE=''
    if [ -z "$( $CMD_MOUNT | $CMD_GREP -E ^$DRBD_DEVICE\ on\ $MOUNT_POINT )" ]; then
        EXIT_CODE=$FALSE
    fi
    return $EXIT_CODE
}
#----------------------------------------------------------------------------------------
# The function will collect all the memory and cpu utilization during umount failure case.
#
function busyfs_data(){
local cpu_count=3

busyfs_log 'Collecting the necessary information for the process utilization'
for ((i = 1; i <= cpu_count; i++))
        do
                echo "" >> $BUSYFS_LOG
                CPU_USAGE=$(top -b -n2 -p 1 | grep -F "Cpu(s)" | tail -1 | awk -F'id,' -v prefix="$prefix" '{ split($1, vs, ","); v=vs[length(vs)]; sub("%", "", v); printf "%s%.1f%%\n", prefix, 100 - v }')
                DATE=$(date "+%Y-%m-%d %H:%M:")
                CPU_USAGE="$DATE CPU: $CPU_USAGE"
                echo "" >> $BUSYFS_LOG
                echo $CPU_USAGE >> $BUSYFS_LOG
                echo "" >> $BUSYFS_LOG
                echo "Process that hold high CPU" >> $BUSYFS_LOG
                echo "**************************" >> $BUSYFS_LOG
                ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head >> $BUSYFS_LOG
                echo "" >> $BUSYFS_LOG
                echo "Process that hold high Mem" >> $BUSYFS_LOG
                echo "**************************" >> $BUSYFS_LOG
                ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head >> $BUSYFS_LOG
                echo "" >> $BUSYFS_LOG
        done

        echo "CPU to IO utilisation in percentage (CPU.IO) for last 01 Minute : " >> $BUSYFS_LOG
        cat /proc/loadavg |awk {'print $1'} /proc/loadavg >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        echo "CPU to IO utilisation in percentage (CPU.IO) for last 05 Minute : " >> $BUSYFS_LOG
        cat /proc/loadavg |awk {'print $2'} >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        echo "CPU to IO utilisation in percentage (CPU.IO) for last 15 Minute : " >> $BUSYFS_LOG
        cat /proc/loadavg |awk {'print $3'} >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        echo "iostat with 2 sec interval for $cpu_count" >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        iostat 2 $cpu_count -h >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        echo "vmstat with 2 sec interval for $cpu_count" >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        vmstat -a 2 $cpu_count -S m >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        echo "mpstat with 2 sec interval for $cpu_count" >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        mpstat 2 $cpu_count >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG
        echo ------------------------------------------------------------------------------ >> $BUSYFS_LOG
        echo "" >> $BUSYFS_LOG

        echo "" >> $BUSYFS_LOG


}
# ------------------------------------------------------------------------
# The function will return $TRUE if $DRBD_DEVICE is found mounted. $FALSE
# otherwise.
function do_migration(){
	trace_enter $FUNCNAME
    local MESSAGE=''
		
	# Migration procedure: 
	# <empty-for-now>
	
	echo "$FUNCNAME"
	trace_leave $FUNCNAME
	return $exit_sucs
}

# ------------------------------------------------------------------------
# The function, in the case of a clean termination, will do a system 
# cleanup to remove all the unneeded files/structures.
function cleanup(){
    [ -f "$OUT_TMP" ] && $CMD_RM $OUT_TMP >/dev/null 2>&1
    [ -f "$ERR_TMP" ] && $CMD_RM $ERR_TMP >/dev/null 2>&1
}

# ------------------------------------------------------------------------
# This function, is to grant the access for the execution of the command.
function confirm(){
    local CMD=""
    local rCode
    while [ "$CMD" != "y" ] && [ "$CMD" != "n" ]; do
            echo -e "Execute raidmgr with these parameters:"
            echo -e "$SCRIPT_OPTS"
            echo -en "[y=yes, n=no]?\003:"
            read CMD
    done
    if [ "$CMD" == "y" ]; then
        rCode=0
    else
        rCode=1
    fi
    return $rCode
}
# Function definitions end here =====>>

# _____________________
#|    _ _   _  .  _    |
#|   | ) ) (_| | | )   |
#|_____________________|
# Here begins the "main" function...

# Set the interpreter to exit if a non-initialized variable is used.
set -u

# sanity check to see if things are in place
sanity_check

# parse the command-line and invoke main functionality
parse_cmdline $@

# perform necessary clean-up
cleanup

# if we are here, command executed successfully.
exit $TRUE
