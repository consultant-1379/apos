#!/bin/bash
##
# ------------------------------------------------------------------------
#     Copyright (C) 2012 Ericsson AB. All rights reserved.
# ------------------------------------------------------------------------
##
# Name:
#       netdef
#
# Description:
#       netdef command is used to define a network for VLANs or external
#       physical interface in the cluster
##
# Usage:
#       netdef -a addra -b addrb -c addrc -m subnetmask [-g gwaddr -d destaddr -s destmask] [-f] [-o] [vlanalias]
#       netdef -g gwaddr -d destaddr -s destmask [-f] [vlanalias]
##
# Output:
#       Command output is directly printed on console.
##
# Changelog:
# - Mon 07 Aug 2023 - Surya Mahit (zsurjon)
#   Fix for TR IA39761
# - Wed 29 June 2022 - Sowjanya Medak (XSOWMED)
#   Updated the script for VEN feature
# - Friday 04 Dec 2020 - Pratap ReddyUppada (xpraupp)
#   Updated function(i.e. update_imm) to support HW SWAP procedure
# - Friday 05 June 2020 - Sowjanya Medak (xsowmed)
#   Updated the script to support Ipsec configuration for IPv6 network
# - Wed 18 Mar 2020 - Sindhuja Palla(xsinpal)
#   Updated the script to support Ipv6 network definition
# - Wed 07 Mar 2018 - Dharma Theja(xdhatej)
#   TR HW32051 FIX - modified the filter in netdef -R option
# - Tue 6 Mar 2018 - Rajashekar Narla(xcsrajn)
#   Fixed a minor issue with "Reboot needed" message when dscp is configured.
# - Fri 8 Aug 2017 - Rajashekar Narla(xcsrajn)
#   TR HW19217 FIX - Fixing issue with OM vlanalias acceptance in native.
# - Wed 5 Jul 2017 - Rajashekar Narla(xcsrajn)
#   Modified netdef to handle OM network.
# - Fri May 05 2017 - Usha Manne (XUSHMAN)
#     Modified with the impacts for support of additional custom networks.
# - Wed 15 Mar 2017 - Rajashekar Narla(xcsrajn)
# New option -u is introduced to undefine network.
# - Friday 03 Feb 2017 - Pratap Reddy(xpraupp)
#   updated netdef_opt_network function to support in virtual environment.
# - Fri 11 Nov 2016 - Swapnika Baradi (XSWAPBA)
#       Fix for TR HU79440(Adding ETX character at confirmation)
# - Friday 09 Aug 2016 - Raghavendra Koduri (XKODRAG)
#   Support to add & modify DSCP value on SMX architecture
# - Tue 14 Jun 2016 - Rajashekar Narla (XCSRAJN)
#       Fixed minor issues with -r and -R options.
# - Thu 18 May 2016 - Gvl Sowjanya (XSOWGVL)
#       Static route definition for non-vlan-tagged O&M networks
#       New options -r and -R are introduced to remove the static routes
# - Wed 27 Apr 2016 - Usha Manne (XUSHMAN)
#       netdef command change in vAPG to define optional networks
# - Fri 04 Mar 2016 - Madhu Muthyala (XMADMUT)
#       TR HU55291 FIX - Fixing of updating optional network defination
# - Mon 08 Feb 2016 - Crescenzo Malvone(ecremal)
# Removed the update of vsftp conf since that's done by apos_ip-config during the cluster reload
# - Fri 11 Dec 2015 - Pratap Reddy Uppada(xpraupp)
# Added parmtool impacts(added update_pso function)
# - Fri 02 Oct 2015 - Alfonso Attanasio (ealfatt)
#       option -o change after axe16a rebase
# - Fri 19 Dec 2015 - Madhu Muthyala (XMADMUT)
#       Added netdef_opt_network function to define optinal network [ex: cdr, li... ] for virtualization POC
# - Tue 11 Aug 2015 - Roni Newatia (XRONNEW)
#       TR HT91743 FIX - Added Apache server configuration.
# - Mon 25 May 2015 - Pratap Reddy Uppada(XPRAUPP)
#   TR HT65008 FIX - Hide the -o option to user but functionality remains exists
# - Mon 18 May 2015 - Roni Newatia (XRONNEW)
#       TR HT72041 FIX - Fixed -o option
# - Mon 06 Apr 2015 - Sarita Gundeboina/Pranshu Sinha (XGUNSAR/XPRANSI)
#   Support to add & modify DSCP value on BSP architecture
# - Mon 03 Nov 2014 - Fabio Imperato (XFABIMP)
#       TR HT16881 FIX - Invoke clu_mgmt --commit to delete cluster.conf.mupdt
# - Mon 03 Nov 2014 - Fabio Imperato (XFABIMP)
#       TR HT16881 FIX - Invoke clu_mgmt --commit to delete cluster.conf.mupdt
# - Mon 23 Jun 2014 - Fabrizio Paglia (XFABPAG)
#       Added procedure to update the IPSec policies in case of IP address (re)definition
#       The procedure is skipped if ACS_ASECBIN is not installed
# - Mon 9 Jun 2014 - Fabrizio Paglia (XFABPAG)
#       New -o option introduced
#       Non-compliant gateways are removed only with -o option, otherwise an exit code is shown in case of conflicts
#       IMM state change moved before reload of cluster.conf (in this way if IMM change fails, it triggers a rollback
# - Fri 16 May 2014 - Fabrizio Paglia (XFABPAG)
#       Removed unused functions, variables and commented old code
# - Fri 9 May 2014 - Torgny Wilhelmsson (XTORWIL)
#       Cableless bonding configuration changed from 'arp' to 'arp_ip_target', to align with cluster template file
# - Tue 6 May 2014 - Torgny Wilhelmsson (XTORWIL)
#       Cableless bonding configuration changed from two ips as parameters to use GWy address
# - Fri 2 May 2014 - Torgny Wilhelmsson (XTORWIL)
#       Start preparation for Cable less configuration where
#       two ARP IP addresses are used to supervise Bonding configuration for Public network
#       netdef -a addra -b addrb -c addrc -m subnetmask [-g gwaddr -d destaddr -s destmask] [-f] [ -arp1 arpaddr -arp2 arpaddr]
#       requires new apos_common.sh and clu_bonding files
# - Thu Apr 17 2014 - Fabrizio Paglia (XFABPAG)
#       Bug fixed in netdef_add_gw (added check for VLAN network that must be already configured)
# - Fri Apr 04 2014 - Fabrizio Paglia (XFABPAG)
#       Bug fixed in netdef_vlan and netdef_add_gw
# - Thu Apr 03 2014 - Fabrizio Paglia (XFABPAG)
#       Added checks to avoid setting network and broadcast addresses as IP/MIP/Gateway
#       Re-arranged exit codes
# - Wed Apr 02 2014 - Fabrizio Paglia (XFABPAG)
#       Fixed is_IP_unique to check also against MIP addresses
# - Mon Mar 31 2014 - Fabrizio Paglia (XFABPAG)
#       Heavy rework done to:
#       - Support the redefinition of network settings when Public VLAN is defined and acts as OaM interface
#       - Support the definition of additional gateways for Public VLAN
#       - Improve robustness of argument checks and code maintainability
#       Bug fixed in update_vsftpd_nbi
# - Tue Dec 10 2013 - Roni Newatia(xronnew)
#       Rework done to include:
#               1. To calulate the network based on cluster IP(-c) and subnet mask provided by the user
#               2. To delete the previous gateway/destination for VLANs which are not in newly defined network
# - Sat Jul 28 2012 - Malangsha Shaik(xmalsha)
#       Heavy rework done to include
#               1. Improve the code quality
#               2. Add subnet change support feature
#               3. Removed own/ohter phrases
# - Thu Jun 28 2012 - Pratap Reddy (xpraupp)
#       Modified to support single gateway.
# - Thu Mar 10 2011 - Madhu Aravabhumi (XMADARA)
#       Dynamically fetching public interface by assuming public network name
#       in cluster.conf file as "public"
#      - First version.
#

#set -x

APOS_COMMON="${AP_HOME:-/opt/ap}/apos/conf/apos_common.sh"
source $APOS_COMMON

# paths and files variables
TRUE=$( true; echo $? )
FALSE=$( false; echo $? )

LOG_TAG='netdef'
LOG_DIR=/tmp
LOG_FILE=netdef.log
CLUSTER_CONF=/cluster/etc/cluster.conf
VLAN_MAPING_CONF=/cluster/etc/ap/apos/vlan_adapter_maping.conf
storage_config_path=/usr/share/pso/storage-paths/config
CONFIG_PATH=$(apos_check_and_cat $storage_config_path)
HTTP_CONFIGURATION_FILE_PATH="$CONFIG_PATH/apos/"
LISTEN_CONF_UPDATE="/opt/ap/apos/bin/apos_httpmgr_operations.sh"
HTTP_CONFIGURATION_FILE="http_config_file"
STRONGSWAN_CFGFILE="/etc/ipsec.conf"
IKE_VER_FILE="/cluster/etc/ikeversion"

# command-list
CMD_IMMLIST=/usr/bin/immlist
CMD_IMMCFG=/usr/bin/immcfg
CMD_IMMFIND=/usr/bin/immfind
CMD_GREP=/usr/bin/grep
CMD_AWK=/usr/bin/awk
CMD_CLUSTER_CONF=/opt/ap/apos/bin/clusterconf/clusterconf
CMD_CAT=/bin/cat
CMD_LOGGER=/bin/logger
CMD_RM=/bin/rm
CMD_GETOPT=/usr/bin/getopt
CMD_SED=/usr/bin/sed
CMD_HEAD=/usr/bin/head
CMD_CUT=/usr/bin/cut
CMD_SORT=/usr/bin/sort
CMD_TR=/usr/bin/tr
CMD_UNIQ=/usr/bin/uniq
CMD_WC=/usr/bin/wc
CMD_HWTYPE='/opt/ap/apos/conf/apos_hwtype.sh'
CMD_PING='/bin/ping'
CMD_SSH='/usr/bin/ssh'
CMD_CHMOD='/usr/bin/chmod'
CMD_TOUCH='/usr/bin/touch'
CMD_LDE_CONFIG=/usr/sbin/lde-config

# script-wide variables
OPT_NODEA=$FALSE
OPT_NODEA_ARG=''
OPT_NODEB=$FALSE
OPT_NODEB_ARG=''
OPT_MIP=$FALSE
OPT_MIP_ARG=''
OPT_SMASK=$FALSE
OPT_SMASK_ARG=''
OPT_GW=$FALSE
OPT_GW_ARG=''
OPT_FORCE=$FALSE
OPT_OVERWRITE=$FALSE
OPT_VLAN=$FALSE
OPT_VLAN_ARG=''
OPT_DEST=$FALSE
OPT_DEST_ARG=''
OPT_DMASK=$FALSE
OPT_DMASK_ARG=''
OPT_UNDEF=$FALSE
OPT_DSCP=$FALSE
OPT_DSCP_ARG=''
OPT_NTWRK=$FALSE
OPT_NTWRK_ARG=''
OPT_RM_STATIC_ROUTE=$FALSE
OPT_RM_ALL_STATIC_ROUTES=$FALSE
OPT_IP_VERSION=$FALSE
OPT_IP_VERSION_ARG=''
OPT_PREFIX_LENGTH=$FALSE
OPT_PREFIX_LENGTH_ARG=''
OPT_DEST_PREFIX_LENGTH=$FALSE
OPT_DEST_PREFIX_LENGTH_ARG=''
SHELF_ARCH=''
HW_TYPE=''
EXTERNAL_NICNAME=''
OPT_NET_NAME=''

CLUS_MGMT_OPTS='mgmt --cluster'
MAX_ALWD_GW=5
IPSEC_CONF_DIR="/etc/racoon"
IPSEC_SETKEY_FILE="setkey.conf"
VIRTL_ARCH=$FALSE

CableLessDefined=$FALSE
CableLess_APR_param=$FALSE

# list-of exit flags
exit_sucs=0
exit_fail=1
exit_usge=2
exit_cmnd_abrt=3
exit_immx_eror=5
exit_vlan_eror=6
exit_ntwk_limt=9
exit_ures_valu=22

#New exit codes (March 2014)
#Network definition conflict subcases
exit_not_unique_network=31
exit_not_unique_network_msg="Network definition conflict: < Network configuration is not compatible with another already defined network >"
exit_not_unique_IP=32
exit_not_unique_IP_msg="Network definition conflict: < Network IPs conflict with already defined IPs >"
exit_not_unique_gateway=33
exit_not_unique_gateway_msg="Network definition conflict: < Gateway IP conflicts with already defined IPs >"
exit_not_unique_dest_network=34
exit_not_unique_dest_network_msg="Network definition conflict: < Destination network conflicts with another already defined network >"

exit_no_public_vlan=35
exit_no_public_vlan_msg="Additional gateways are not supported when Public network is not defined on a VLAN"

#Invalid routing subcases
exit_incompatible_default_gw=30
exit_incompatible_default_gw_msg="Invalid routing: < Public network configuration is not compatible with the already defined default gateway >"
exit_own_gw_conflict=40
exit_own_gw_conflict_msg="Invalid routing: < Conflicting routes detected >"
exit_gw_conflict=36
exit_gw_conflict_msg="Invalid routing: < Gateway IP conflicts with the source network >"
exit_dest_conflict=38
exit_dest_conflict_msg="Invalid routing: < Destination network conflicts with the source network >"

exit_vlan_not_configured=39

exit_invalid_opt_net_name=41
exit_invalid_opt_net_name_msg="Invalid Network Configuration: < Network name not available in the model > "
exit_invalid_admin_state=42
exit_invalid_admin_state_msg="Invalid Network Configuration: < adminState is locked to configure network >"
exit_invalid_opt_network=43
exit_invalid_opt_network_msg="Invalid Network Configuration: < Network definition not found >"
exit_invalid_netname=44
exit_invalid_netname_msg="Invalid Network Configuration: < Network name should be given as OM to configure public network >"
exit_om_nw_cannot_be_undef=45
exit_om_nw_cannot_be_undef_msg="Invalid Network Configuration: < Public  network cannot be undefined >"
exit_format_not_supprted_msg="This command format not supported in this system configuration"
exit_format_not_supprted=46
exit_public_ipv6_nw_not_defined=47
exit_public_ipv6_nw_not_defined_msg="Invalid Network Configuration: < public_v6 network should be defined before defining custom network >"


##############################################################################################
#                                  LOGGING UTILITIES                                         #
##############################################################################################

##############################################################################################
# function INFO($msg);                                                                       #
#                                                                                            #
# Adds a timestamped entry to the log file.                                                  #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to add to the log                                                           #
##############################################################################################
function INFO() {
  echo "[$(date --utc +'%Y-%m-%d %H:%M:%S')] $@" >>$LOG_DIR/$LOG_FILE
}

##############################################################################################
# function log($msg);                                                                        #
#                                                                                            #
# Adds a notice message to the log file.                                                     #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to add to the log                                                           #
##############################################################################################
function log() {
  local PRIO='-p user.notice'
  local MESSAGE="${*:-notice}"
  ${CMD_LOGGER} $PRIO $LOG_TAG "$MESSAGE"
}

##############################################################################################
# function log_error($msg);                                                                  #
#                                                                                            #
# Adds an error message to the log file.                                                     #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to add to the log                                                           #
##############################################################################################
function log_error() {
  local PRIO='-p user.err'
  local MESSAGE="${*:-error}"
  ${CMD_LOGGER} $PRIO $LOG_TAG "$MESSAGE"
  INFO "$MESSAGE"
}

##############################################################################################
# function TRACE_ENTER($msg);                                                                #
#                                                                                            #
# Adds a message to the log file followed by "() >>"                                         #
# Note: it is useful to log the entry point of a function e.g. TRACE_ENTER $FUNCNAME         #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to print                                                                    #
##############################################################################################
function TRACE_ENTER(){
  INFO "$1() >>"
}

##############################################################################################
# function TRACE_LEAVE($msg);                                                                #
#                                                                                            #
# Adds a message to the log file followed by "() <<"                                         #
# Note: it is useful to log the end point of a function e.g. TRACE_LEAVE $FUNCNAME           #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to print                                                                    #
##############################################################################################
function TRACE_LEAVE(){
  INFO "$1() <<"
}

##############################################################################################
#                                MESSAGE AND EXIT FUNCTIONS                                  #
##############################################################################################

##############################################################################################
# function console_print($msg);                                                              #
#                                                                                            #
# Prints a message.                                                                          #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to print                                                                    #
##############################################################################################
function console_print() {
  echo -e "$1"
}

##############################################################################################
# function abort($msg);                                                                      #
#                                                                                            #
# Adds an error message to the log file and exits with                                       #
# "Error when executing (general fault)"                                                     #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to add to the log                                                           #
#                                                                                            #
# Exits:                                                                                     #
# - "Error when executing (general fault)"                                                   #
##############################################################################################
function abort() {
  console_print "Error when executing (general fault)"
  log_error "ABORTING: <"$1">"
  exit $exit_fail
}

##############################################################################################
# function console_abort($msg,$exit_code);                                                   #
#                                                                                            #
# Prints an error message and exits.                                                         #
#                                                                                            #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to print                                                                    #
# - $exit_code numeric exit code to use                                                      #
##############################################################################################
function console_abort() {
  console_print "$1"
  echo -e
  exit $2
}

##############################################################################################
# function imm_abort($msg,$exit_code);                                                   #
#                                                                                            #
# Prints an error message and exits.                                                         #
# Cancels any current operation on the cluster.conf file                                     #
#                                                                                            #
# Arguments:                                                                                 #
# - $msg message to print                                                                    #
# - $exit_code numeric exit code to use                                                      #
##############################################################################################
function imm_abort() {
  console_print "$1"
  echo -e
  ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &>/dev/null
  exit $2
}



##############################################################################################
# function usage();                                                                          #
#                                                                                            #
# Prints the command usage.                                                                  #
##############################################################################################
function usage() {
if is_vAPG ; then
  $CMD_CAT << EOF
  Usage: netdef [-v ip-proto-version] -a addra -b addrb -c addrc -m subnetmask|-p prefix-length [-g gwaddr -d destaddr -s destmask|-l dest-prefix-length [-q dscp] ] [-f] [-o] netName
         netdef -u [-v ip-proto-version] [-f] netName

EOF
elif isBSP; then
    $CMD_CAT << EOF
    Usage: netdef -a addra -b addrb -c addrc -m subnetmask [-g gwaddr -d destaddr -s destmask [-q dscp]] [-f] [-o] [vlanalias]
           netdef -g gwaddr -d destaddr -s destmask [-q dscp] [-f] [vlanalias]

EOF
elif isSMX; then
    $CMD_CAT << EOF
    Usage: netdef -a addra -b addrb -c addrc -m subnetmask [-g gwaddr -d destaddr -s destmask [-q dscp]] [-f] [-o] [vlanalias]
           netdef -g gwaddr -d destaddr -s destmask [-q dscp] [-f] [vlanalias]
            netdef -r -g gwaddr -d destaddr -s destmask [-f]
            netdef -R [-f]

EOF
   else
     $CMD_CAT << EOF
     Usage: netdef -a addra -b addrb -c addrc -m subnetmask [-g gwaddr -d destaddr -s destmask ] [-f] [-o] [vlanalias]
            netdef -g gwaddr -d destaddr -s destmask [-f] [vlanalias]
            netdef -r -g gwaddr -d destaddr -s destmask [-f]
            netdef -R [-f]

EOF
   fi
}

##############################################################################################
# function usage_error();                                                                    #
#                                                                                            #
# Prints the command usage and exits with "Incorrect usage".                                 #
##############################################################################################
function usage_error() {
  console_print "Incorrect usage"
  usage
  exit $exit_usge
}

##############################################################################################
# function ping_peer()
#
# checks if the peer node is up
##############################################################################################
function is_peer_node_up(){
  local RHOST=$(</etc/cluster/nodes/peer/hostname)

  ${CMD_PING} -c 1 -W 1 $RHOST &>/dev/null
  [ $? -eq 0 ] && return $TRUE
  return $FALSE
}

##############################################################################################
# function create_reboot_needed_file();
#
# creates /tmp/netdef_reboot_needed file to help netls list the network information
# after the reboot.
#
###############################################################################################
function create_reboot_needed_file(){
  TRACE_ENTER $FUNCNAME
  local filename='/tmp/netdef_reboot_needed'
  if [ ! -f $filename ]; then
    ${CMD_TOUCH} $filename 2>/dev/null
    ${CMD_CHMOD} 1400 $filename 2>/dev/null  # no other user should be able to remove this file
  fi

  if is_peer_node_up; then
    local RHOST=$(</etc/cluster/nodes/peer/hostname)
    if ! ${CMD_SSH} $RHOST ${CMD_TOUCH} $filename &>/dev/null; then
      log "ERR: Creating [$filename] failed on $RHOST"
    elif ! ${CMD_SSH} $RHOST ${CMD_CHMOD} 1400  $filename &>/dev/null; then
      log "ERR: Setting 1400 on [$filename] failed on $RHOST"
    fi
  fi
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_gateway();                                                                 #
#                                                                                            #
# Removes gateway rules from cluster.conf                                                    #
#                                                                                            #
# Arguments:                                                                                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_gateway(){
  TRACE_ENTER $FUNCNAME

  local CNT=0 INDEX=0 RULE_NO=0
  local STATIC_NW_NAME="$1"
  local RM_INTERFACE=${STATIC_NW_NAME}"_gw"
  [ "$STATIC_NW_NAME" == "public_v6" ] && RM_INTERFACE="default_v6"
  [ "$STATIC_NW_NAME" == "public" ] && RM_INTERFACE="default"
  if [ "$STATIC_NW_NAME" == "public" ]; then
    CNT=$( $CMD_CLUSTER_CONF route --display |$CMD_GREP $RM_INTERFACE | $CMD_GREP -v "default_v6" |$CMD_WC -l )
  else
    CNT=$( $CMD_CLUSTER_CONF route --display |$CMD_GREP $RM_INTERFACE | $CMD_WC -l )
  fi
  while [ $INDEX -lt $CNT ]
  do
    if [ "$STATIC_NW_NAME" == "public" ]; then
      RULE_NO=$( $CMD_CLUSTER_CONF route --display |$CMD_GREP $RM_INTERFACE | $CMD_GREP -v "default_v6" | $CMD_HEAD -1 | $CMD_AWK '{print $1}' )
    else
      RULE_NO=$( $CMD_CLUSTER_CONF route --display |$CMD_GREP $RM_INTERFACE | $CMD_HEAD -1 | $CMD_AWK '{print $1}' )
    fi
    $CMD_CLUSTER_CONF route --m_delete $RULE_NO &>/dev/null
    [ $? -ne $TRUE ] && console_abort "ERROR: Cluster configuration update failed" $exit_clus_fail
    ((INDEX=INDEX + 1))
  done
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_alias();                                                                   #
#                                                                                            #
# Removes alias rules from cluster.conf                                                      #
#                                                                                            #
# Arguments:                                                                                 #
# - $interface physical or VLAN interface name upon which define the network                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_alias(){
  TRACE_ENTER $FUNCNAME
  local INTERFACE="$1"
  if [ $OPT_VLAN_ARG == "OM" ] ; then
    if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
      INTERFACE=eth1:2
    else
      INTERFACE=eth1:1
    fi
  fi
  if ! [[ $OPT_IP_VERSION -eq $TRUE && $OPT_IP_VERSION_ARG -eq 6 && $OPT_VLAN_ARG != "OM" ]] ; then
    RULE_NO=$( $CMD_CLUSTER_CONF interface --display | $CMD_GREP alias | $CMD_GREP -w "$INTERFACE" | $CMD_AWK '{print $1}' )
    [ ! -z "$RULE_NO" ] && {
      $CMD_CLUSTER_CONF interface --m_delete $RULE_NO &>/dev/null
      [ $? -ne $TRUE ] && console_abort "ERROR: Cluster configuration update failed" $exit_clus_fail
    }
  fi
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_mip();                                                                     #
#                                                                                            #
# Removes mip rules from cluster.conf                                                        #
#                                                                                            #
# Arguments:                                                                                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_mip(){
  TRACE_ENTER $FUNCNAME

  local STATIC_NW_NAME="$1"
  local RM_INTERFACE=$STATIC_NW_NAME"_mip"
  if [ "$STATIC_NW_NAME" == "public_v6" ] || [ "$STATIC_NW_NAME" == "public" ]; then
    RM_INTERFACE=$STATIC_NW_NAME
  fi
  local RULE_NO=$( $CMD_CLUSTER_CONF mip --display | $CMD_GREP -w "$RM_INTERFACE" |$CMD_AWK '{print $1}' )
  [ ! -z $RULE_NO ] && {
    $CMD_CLUSTER_CONF mip --m_delete $RULE_NO &>/dev/null
    [ $? -ne $TRUE ] && console_abort "ERROR: Cluster configuration update failed" $exit_clus_fail

  }
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_ip($interface);                                                            #
#                                                                                            #
# Removes ip rules from cluster.conf                                                         #
#                                                                                            #
# Arguments:                                                                                 #
# - $interface physical or VLAN interface name upon which define the network                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_ip(){
  TRACE_ENTER $FUNCNAME

  local INTERFACE="$1"
  local NW_NAME="$2"
  local CNT=0 INDEX=0 RULE_NO=0

  CNT=$( $CMD_CLUSTER_CONF ip --display |$CMD_GREP -w "$INTERFACE" |$CMD_GREP -w "$NW_NAME" |$CMD_WC -l )

  while [ $INDEX -lt $CNT ]
  do
    RULE_NO=$( $CMD_CLUSTER_CONF ip --display |$CMD_GREP -w "$INTERFACE" |$CMD_GREP -w "$NW_NAME" |$CMD_HEAD -1 | $CMD_AWK '{print $1}')
    $CMD_CLUSTER_CONF ip --m_delete $RULE_NO &>/dev/null
    [ $? -ne $TRUE ] && console_abort "ERROR: Cluster configuration update failed" $exit_clus_fail
    ((INDEX=INDEX + 1))
  done

  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_noncompliant_iptable();                                                    #
#                                                                                            #
# Removes non compliant iptables from cluster.conf                                           #
#                                                                                            #
# Arguments:                                                                                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_noncompliant_iptable(){
  TRACE_ENTER $FUNCNAME
  local CNT=0 INDEX=1
  local IPTABLES="iptables"
  local DEST_NW=""
  local DEST_GW=""
  local RULE_NO=""
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    IPTABLES="ip6tables"
  fi
  CNT=$( $CMD_CLUSTER_CONF $IPTABLES -D| $CMD_GREP "mangle" |$CMD_WC -l )
  ((CNT=CNT + 1))
  while [ $INDEX -lt $CNT ]
  do
    DEST_NW=$( $CMD_CLUSTER_CONF $IPTABLES -D | $CMD_GREP "mangle"| $CMD_HEAD -$INDEX | tail -1 | $CMD_AWK '{print $9}' )
    DEST_GW=$( $CMD_CLUSTER_CONF network -D| $CMD_GREP -w $DEST_NW )
    if [ "$DEST_GW" == "" ] ; then
      RULE_NO=$( $CMD_CLUSTER_CONF $IPTABLES -D | $CMD_GREP "$DEST_NW" | $CMD_AWK '{print $1}' )
      $CMD_CLUSTER_CONF $IPTABLES -d $RULE_NO &>/dev/null
    fi
    ((INDEX=INDEX + 1))
  done
  [ $? -ne $TRUE ] && abort "Removal of iptable failed."
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_iptable();                                                                 #
#                                                                                            #
# Removes iptables from cluster.conf                                                         #
#                                                                                            #
# Arguments:                                                                                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_iptable(){
  TRACE_ENTER $FUNCNAME
  local CNT=0 INDEX=0 
  CNT=$( $CMD_CLUSTER_CONF network -D| $CMD_GREP "$STATIC_NW_NAME"_gw|$CMD_AWK '{print $4}' |$CMD_WC -l )
  local iptables="iptables"

  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    iptables="ip6tables"
  fi

  while [ $INDEX -lt $CNT ]
    do
      local DEST_NW=$( $CMD_CLUSTER_CONF network -D| $CMD_GREP "$STATIC_NW_NAME"_gw|$CMD_AWK '{print $4}' )
      local RULE_NO=$( $CMD_CLUSTER_CONF $iptables -D | $CMD_GREP "$DEST_NW"| $CMD_HEAD -1 | $CMD_AWK '{print $1}' )
      $CMD_CLUSTER_CONF $iptables -d $RULE_NO &>/dev/null
      ((INDEX=INDEX + 1))
    done

  [ $? -ne $TRUE ] && abort "Removal of iptable failed."
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function remove_network();                                                                 #
#                                                                                            #
# Removes defined network                                                                    #
#                                                                                            #
# Arguments:                                                                                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function remove_network(){
  TRACE_ENTER $FUNCNAME

  local STATIC_NW_NAME="$1"
  local INDEX=0 RULE_NO=0 CNT=0
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    CNT=$( $CMD_CLUSTER_CONF network --display |$CMD_GREP -E $STATIC_NW_NAME |$CMD_GREP _v6 | $CMD_WC -l )
  else
    CNT=$( $CMD_CLUSTER_CONF network --display |$CMD_GREP -E $STATIC_NW_NAME |$CMD_GREP -v _v6 | $CMD_WC -l )
  fi
  while [ $INDEX -lt $CNT ]
  do
    if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
      RULE_NO=$( $CMD_CLUSTER_CONF network  --display |$CMD_GREP -E $STATIC_NW_NAME |$CMD_GREP _v6| $CMD_HEAD -1 | $CMD_AWK '{print $1}' )
    else
      RULE_NO=$( $CMD_CLUSTER_CONF network  --display |$CMD_GREP -E $STATIC_NW_NAME |$CMD_GREP -v _v6 | $CMD_HEAD -1 | $CMD_AWK '{print $1}' )
    fi
    $CMD_CLUSTER_CONF network --m_delete $RULE_NO &>/dev/null
    [ $? -ne $TRUE ] && console_abort "ERROR: Cluster configuration update failed" $exit_clus_fail
    ((INDEX=INDEX + 1))
  done

  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
#                                    UTILITIES & CHECKS                                      #
##############################################################################################

##############################################################################################
# function in_array($needle,$haystack);                                                      #
#                                                                                            #
# Arguments:                                                                                 #
# $needle string to search for in $haystack                                                  #
# $haystack imploded array to search in (pass the array as "${haystack[@]}" )                #
#                                                                                            #
# Returns 0 if $needle is in $haystack, 1 otherwise                                          #
##############################################################################################
function in_array() {
  local needle=$1
  shift

  local hay
  for hay in "$@"; do
    [[ "$hay" == "$needle" ]] && return 0
  done
  return 1
}

##############################################################################################
# function subnet_mask_to_CIDR($subnet_mask);                                                #
#                                                                                            #
# Convert a subnet mask in CIDR notation                                                     #
# Example: 255.255.224.0 in 19                                                               #
#                                                                                            #
# Arguments:                                                                                 #
# - $subnet_mask subnet mask to convert                                                      #
#                                                                                            #
# Return value:                                                                              #
# CIDR number corresponding to $subnet_mask                                                  #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1) in case $subnet_mask is not a valid CIDR subnet mask                         #
##############################################################################################
function subnet_mask_to_CIDR() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local subnet_mask="$1"
  local error=$FALSE

  local dec
  local nbits=0
  IFS=$'.'
  for dec in $subnet_mask ; do
    case $dec in
      255)
        let nbits+=8
        ;;
      254)
        let nbits+=7
        break
        ;;
      252)
        let nbits+=6
        break
        ;;
      248)
        let nbits+=5
        break
        ;;
      240)
        let nbits+=4
        break
        ;;
      224)
        let nbits+=3
        break
        ;;
      192)
        let nbits+=2
        break
        ;;
      128)
        let nbits+=1
        break
        ;;
      0)
        ;;
      *)
        error=$TRUE
        ;;
    esac
  done
  unset IFS

  [[ $error -eq $TRUE ]] && rCode=$exit_fail
  [[ $error -eq $FALSE ]] && echo "$nbits"

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function CIDR_to_subnet_mask($cidr);                                                       #
#                                                                                            #
# Convert from CIDR notation in a subnet mask                                                #
# Example: 19 in 255.255.224.0                                                               #
#                                                                                            #
# Arguments:                                                                                 #
# - $cidr CIDR number to convert                                                             #
#                                                                                            #
# Return value:                                                                              #
# Subnet mask corresponding to $cidr                                                         #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1) in case $cidr is not a valid CIDR number                                     #
##############################################################################################
function CIDR_to_subnet_mask() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local cidr="$1"
  local error=$FALSE

  CIDR_subnet_masks=("0.0.0.0" "128.0.0.0" "192.0.0.0" "224.0.0.0" "240.0.0.0" "248.0.0.0" "252.0.0.0" "254.0.0.0" "255.0.0.0" "255.128.0.0" "255.192.0.0" "255.224.0.0" "255.240.0.0" "255.248.0.0" "255.252.0.0" "255.254.0.0" "255.255.0.0" "255.255.128.0" "255.255.192.0" "255.255.224.0" "255.255.240.0" "255.255.248.0" "255.255.252.0" "255.255.254.0" "255.255.255.0" "255.255.255.128" "255.255.255.192" "255.255.255.224" "255.255.255.240" "255.255.255.248" "255.255.255.252" "255.255.255.254" "255.255.255.255")

  if [ $cidr -ge 0 ] && [ $cidr -le 32 ] ; then
    local subnet_mask="${CIDR_subnet_masks[$cidr]}"
    echo $subnet_mask
    rCode=$exit_sucs
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function compute_network($ip_address,$subnet_mask);                                        #
#                                                                                            #
# Given an IP address and a subnet mask returns the subnet id in CIDR format                 #
# Example: given 192.168.23.45 and 255.255.255.252 returns 192.168.23.44/30                  #
#                                                                                            #
# Arguments:                                                                                 #
# - $ip_address valid IP address                                                             #
# - $subnet_mask valid CIDR subnet_mask                                                      #
#                                                                                            #
# Return value:                                                                              #
# Subnet id in CIDR format                                                                   #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1) in case $subnet_mask is not a valid CIDR subnet mask                         #
##############################################################################################
function compute_network() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local ip_address="$1"
  local subnet_mask="$2"

  local cidr_subnet_mask=$(subnet_mask_to_CIDR "$subnet_mask")
  if [ "$cidr_subnet_mask" != "" ] ; then
    local ip_address_component=(${ip_address//./ })
    local subnet_mask_component=(${subnet_mask//./ })

    local subnet_id_A=`echo $((${ip_address_component[0]} & ${subnet_mask_component[0]}))`
    local subnet_id_B=`echo $((${ip_address_component[1]} & ${subnet_mask_component[1]}))`
    local subnet_id_C=`echo $((${ip_address_component[2]} & ${subnet_mask_component[2]}))`
    local subnet_id_D=`echo $((${ip_address_component[3]} & ${subnet_mask_component[3]}))`

    echo "$subnet_id_A.$subnet_id_B.$subnet_id_C.$subnet_id_D/$cidr_subnet_mask"
    rCode=$exit_sucs
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function compute_broadcast_address($network_id);                                           #
#                                                                                            #
# Given a network id in CIDR notation (e.g 10.35.13.0/24) returns the broadcast IP address   #
# Example: given 10.35.13.0/24 returns 10.35.13.255                                          #
#                                                                                            #
# Arguments:                                                                                 #
# - $network_id valid network id in CIDR notation                                            #
#                                                                                            #
# Return value:                                                                              #
# Broadcast IP address                                                                       #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1) in case $network_id is not a valid network id                                #
##############################################################################################
function compute_broadcast_address() {
  local rCode=$exit_sucs

  local network_id="$1"

  local network_ip="$(echo "$network_id" | $CMD_AWK -F'/' '{ print $1 }')"
  local network_cidr="$(echo "$network_id" | $CMD_AWK -F'/' '{ print $2 }')"
  local network_subnet_mask="$(CIDR_to_subnet_mask $network_cidr)"

  if [ "$network_subnet_mask" != "" ] ; then
    local network_ip_components=(${network_ip//./ })
    local network_subnet_mask_components=(${network_subnet_mask//./ })

    (( a = ~${network_subnet_mask_components[0]} + 256 ))
    (( b = ~${network_subnet_mask_components[1]} + 256 ))
    (( c = ~${network_subnet_mask_components[2]} + 256 ))
    (( d = ~${network_subnet_mask_components[3]} + 256))

    local broadcast_ip_A=`echo $((${network_ip_components[0]} | $a))`
    local broadcast_ip_B=`echo $((${network_ip_components[1]} | $b))`
    local broadcast_ip_C=`echo $((${network_ip_components[2]} | $c))`
    local broadcast_ip_D=`echo $((${network_ip_components[3]} | $d))`

    echo "$broadcast_ip_A.$broadcast_ip_B.$broadcast_ip_C.$broadcast_ip_D"
    rCode=$exit_sucs
  fi

  return $rCode
}

##############################################################################################
# function dec_to_bin($dec,$pad = 8);                                                        #
#                                                                                            #
# Convert an unsigned decimal integer in the corresponding binary string                     #
#                                                                                            #
# Arguments:                                                                                 #
# - $dec unsigned decimal integer to convert                                                 #
# - $pad (optional) minimun length of the resulting binary string                            #
#                                                                                            #
# Return value:                                                                              #
# Binary string corresponding to $dec                                                        #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (0) in case $dec is not an unsigned decimal integer                              #
##############################################################################################
function dec_to_bin() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local dec="$1"
  local pad=$2

  [[ $pad =~ ^[0-9]+$ ]] || pad=8

  if [[ $dec =~ ^[0-9]+$ ]] ; then
    local bin=$(echo "obase=2;$dec" | bc)
    printf "%0*d\n" $pad $bin

    rCode=$exit_sucs
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function ip_to_bin($ip);                                                                   #
#                                                                                            #
# Convert an IP address in the corresponding binary string                                   #
#                                                                                            #
# Arguments:                                                                                 #
# - $ip IP address to convert                                                                #
#                                                                                            #
# Return value:                                                                              #
# Binary string corresponding to $ip                                                         #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (0) in case $ip is not a valid IP address                                        #
##############################################################################################
function ip_to_bin() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local ip="$1"

  local bin=""

  local ip_components=(${ip//./ })
  local ip_component
  local ip_component_bin
  for ip_component in "${ip_components[@]}" ; do
    ip_component_bin=$(dec_to_bin "$ip_component")
    if [ "$ip_component_bin" == "" ] ; then
      rCode=$exit_fail
      break;
    fi
    bin="$bin$ip_component_bin"
  done

  [[ rCode -eq $exit_sucs ]] && echo "$bin"

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_subnet_of($subnetA_id,$subnetB_id);                                            #
#                                                                                            #
# Given two subnet ids, returns TRUE if $subnetA_id is a subnet of $subnetB_id.              #
#                                                                                            #
# Arguments:                                                                                 #
# - $subnetA_id subnet id in CIDR notation                                                   #
# - $subnetB_id subnet id in CIDR notation                                                   #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0) in case $subnetA_id is a subnet of $subnetB_id                               #
# - FAILURE (0) in case $subnetA_id is not a subnet of $subnetB_id                           #
##############################################################################################
function is_subnet_of() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local subnetA_id="$1"
  local subnetB_id="$2"

  local subnetA_ip="$(echo "$subnetA_id" | $CMD_AWK -F'/' '{ print $1 }')"
  local subnetB_ip="$(echo "$subnetB_id" | $CMD_AWK -F'/' '{ print $1 }')"

  local subnetA_cidr=$(echo "$subnetA_id" | $CMD_AWK -F'/' '{ print $2 }')
  local subnetB_cidr=$(echo "$subnetB_id" | $CMD_AWK -F'/' '{ print $2 }')

  if [ $subnetA_cidr -ge $subnetB_cidr ] ; then
    local subnetA_ip_binary=$(ip_to_bin "$subnetA_ip")
    local subnetB_ip_binary=$(ip_to_bin "$subnetB_ip")

    local subnetA_ip_firstBits=${subnetA_ip_binary:0:$subnetB_cidr}
    local subnetB_ip_firstBits=${subnetB_ip_binary:0:$subnetB_cidr}

    [[ "$subnetA_ip_firstBits" == "$subnetB_ip_firstBits" ]] && rCode=$exit_sucs
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}


##############################################################################################
# function is_valid_dscp($dscp_value);                                                       #
#                                                                                            #
# Verifies if the dscp value is valid                                                        #
#                                                                                            #
# Arguments:                                                                                 #
# - $dscp_value dscp value to validate                                                       #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if $dscp_value is a valid dscp value                                         #
# - FAILURE (1) if $dscp_value is not a valid dscp value                                     #
##############################################################################################
function is_valid_dscp() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail
  local dscp_value="$1"
  local letters=$(echo $dscp_value | tr -dc "([0-9]|\.)")
  local diff=`echo $(( ${#dscp_value} - ${#letters} ))`

  if [ $diff -eq 0 ] ; then
    if [ $dscp_value -ge 0 ] && [ $dscp_value -le 63 ] ; then
      rCode=$exit_sucs
    fi
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_valid_IP($ip_address);                                                         #
#                                                                                            #
# Arguments:                                                                                 #
# - $ip_address IP address to validate                                                       #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if $ip_address is a valid IP                                                 #
# - FAILURE (1) if $ip_address is not a valid IP                                             #
##############################################################################################
function is_valid_IP() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail
  local ip_address="$1"
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    isValidIPv6 $ip_address && rCode=$exit_sucs
  else
    local letters=$(echo $ip_address | tr -dc "([0-9]|\.)")
    local diff=`echo $(( ${#ip_address} - ${#letters} ))`

    if [ $diff -eq 0 ] ; then
      local ip_address_components=(${ip_address//./ })
      if [ ${#ip_address_components[@]} -eq 4 ] ; then
        local dots=$(echo $ip_address | tr -dc "(\.)")
        if [ ${#dots} -eq 3 ] ; then
          local ok=$TRUE
          local ip_component
          for ip_component in "${ip_address_components[@]}" ; do
            if [ ${#ip_component} -le 0 ] || [ ${#ip_component} -gt 3 ] || [ $ip_component -lt 0 ] || [ $ip_component -gt 255 ]; then
              ok=$FALSE;
              break;
            fi
          done

          [[ $ok -eq $TRUE ]] && rCode=$exit_sucs
        fi
      fi
    fi
  fi
  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_unique_format();                                                               #
#                                                                                            #
# Verifies if all the parameters(-a,-b,-c,-g,-d) are in same format                          #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if all the parameters are in same format                                     #
# - FAILURE (1) if all the parameters are not in same format                                 #
##############################################################################################
function is_unique_format(){
  local ip_address="$1"
  local rCode=$FALSE
  if echo "$ip_address" | grep -E '[0-9a-f]+:+' >/dev/null; then
    rCode=$TRUE
  fi
  return $rCode
}

##############################################################################################
# function is_valid_CIDR_subnet_mask($subnet_mask);                                          #
#                                                                                            #
# Checks if $subnet_mask is one of the useable CIDR subnet masks from the following table    #
# Netmask              Netmask (binary)                 CIDR     Notes                       #
# _____________________________________________________________________________              #
# 255.255.255.255  11111111.11111111.11111111.11111111  /32  Host (single addr)              #
# 255.255.255.254  11111111.11111111.11111111.11111110  /31  Unuseable                       #
# 255.255.255.252  11111111.11111111.11111111.11111100  /30    2  useable                    #
# 255.255.255.248  11111111.11111111.11111111.11111000  /29    6  useable                    #
# 255.255.255.240  11111111.11111111.11111111.11110000  /28   14  useable                    #
# 255.255.255.224  11111111.11111111.11111111.11100000  /27   30  useable                    #
# 255.255.255.192  11111111.11111111.11111111.11000000  /26   62  useable                    #
# 255.255.255.128  11111111.11111111.11111111.10000000  /25  126  useable                    #
# 255.255.255.0    11111111.11111111.11111111.00000000  /24 "Class C" 254 useable            #
#                                                                                            #
# 255.255.254.0    11111111.11111111.11111110.00000000  /23    2  Class C's                  #
# 255.255.252.0    11111111.11111111.11111100.00000000  /22    4  Class C's                  #
# 255.255.248.0    11111111.11111111.11111000.00000000  /21    8  Class C's                  #
# 255.255.240.0    11111111.11111111.11110000.00000000  /20   16  Class C's                  #
# 255.255.224.0    11111111.11111111.11100000.00000000  /19   32  Class C's                  #
# 255.255.192.0    11111111.11111111.11000000.00000000  /18   64  Class C's                  #
# 255.255.128.0    11111111.11111111.10000000.00000000  /17  128  Class C's                  #
# 255.255.0.0      11111111.11111111.00000000.00000000  /16  "Class B"                       #
#                                                                                            #
# 255.254.0.0      11111111.11111110.00000000.00000000  /15    2  Class B's                  #
# 255.252.0.0      11111111.11111100.00000000.00000000  /14    4  Class B's                  #
# 255.248.0.0      11111111.11111000.00000000.00000000  /13    8  Class B's                  #
# 255.240.0.0      11111111.11110000.00000000.00000000  /12   16  Class B's                  #
# 255.224.0.0      11111111.11100000.00000000.00000000  /11   32  Class B's                  #
# 255.192.0.0      11111111.11000000.00000000.00000000  /10   64  Class B's                  #
# 255.128.0.0      11111111.10000000.00000000.00000000  /9   128  Class B's                  #
# 255.0.0.0        11111111.00000000.00000000.00000000  /8   "Class A"                       #
#                                                                                            #
# 254.0.0.0        11111110.00000000.00000000.00000000  /7                                   #
# 252.0.0.0        11111100.00000000.00000000.00000000  /6                                   #
# 248.0.0.0        11111000.00000000.00000000.00000000  /5                                   #
# 240.0.0.0        11110000.00000000.00000000.00000000  /4                                   #
# 224.0.0.0        11100000.00000000.00000000.00000000  /3                                   #
# 192.0.0.0        11000000.00000000.00000000.00000000  /2                                   #
# 128.0.0.0        10000000.00000000.00000000.00000000  /1                                   #
# 0.0.0.0          00000000.00000000.00000000.00000000  /0   IP space                        #
#                                                                                            #
# Arguments:                                                                                 #
# - $subnet_mask subnet mask to validate                                                     #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if $subnet_mask is a valid CIDR subnet mask                                  #
# - FAILURE (1) if $subnet_mask is not a valid CIDR subnet_mask                              #
##############################################################################################
function is_valid_CIDR_subnet_mask() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local subnet_mask="$1"

  local valid_subnet_masks=("255.255.255.255" "255.255.255.252" "255.255.255.248" "255.255.255.240" "255.255.255.224" "255.255.255.192" "255.255.255.128" "255.255.255.0" "255.255.254.0" "255.255.252.0" "255.255.248.0" "255.255.240.0" "255.255.224.0" "255.255.192.0" "255.255.128.0" "255.255.0.0" "255.254.0.0" "255.252.0.0" "255.248.0.0" "255.240.0.0" "255.224.0.0" "255.192.0.0" "255.128.0.0" "255.0.0.0" "254.0.0.0" "252.0.0.0" "248.0.0.0" "240.0.0.0" "224.0.0.0" "192.0.0.0" "128.0.0.0" "0.0.0.0")

  in_array "$subnet_mask" "${valid_subnet_masks[@]}" && rCode=$exit_sucs

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function sanity_check();                                                                   #
#                                                                                            #
# Erases the log file and checks the execute permission on APOS clusterconf tool             #
#                                                                                            #
# Execute clu_mgmt --commit in order to erase /opt/ap/apos/conf/cluster.conf.mupdt backup    #
# not handled correctly by previous operations                                               #
#                                                                                            #
# Exits:                                                                                     #
# - "Error when executing (general fault)"                                                   #
##############################################################################################
function sanity_check() {
  [ -f $LOG_DIR/$LOG_FILE    ] && ${CMD_RM} -f $LOG_DIR/$LOG_FILE
  [ ! -x ${CMD_CLUSTER_CONF} ] && abort "Execute permission error: $CMD_CLUSTER_CONF" $exit_fail
  ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --commit &>/dev/null

  ## check shelf architecture for virtualization
  SHELF_ARCH=$($CMD_IMMLIST -a apgShelfArchitecture axeFunctionsId=1 | ${CMD_AWK} -F "=" '{print $2}' 2>/dev/null)
  [ -z $SHELF_ARCH ] && abort "ERROR: Failed to get apgShelfArchitecture"

  HW_TYPE=$($CMD_HWTYPE 2>/dev/null)
  [ -z "$HW_TYPE" ] && abort "ERROR: HW_TYPE not found"

  if [[ $SHELF_ARCH -eq 3 && $HW_TYPE == 'VM' ]]; then
    VIRTL_ARCH=$TRUE;
  fi

}

##############################################################################################
# function confirm();                                                                        #
#                                                                                            #
# Asks the user for confirmation.                                                            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if user gives confirmation                                                   #
# - FAILURE (1) if user does not give confirmation                                           #
##############################################################################################
function confirm() {
  TRACE_ENTER $FUNCNAME
  local CMD=''
  local rCode
  while [ "$CMD" != "y" ] && [ "$CMD" != "n" ]; do
    echo -e "Are you sure you want to do these changes:"
    echo -en "[y=yes, n=no]?\003:"
    read CMD
  done

  if [ "$CMD" == "y" ]; then
    rCode=0
  else
    rCode=1
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

############################################################################################################################################
# function parse_args($args...);                                                                                                           #
#                                                                                                                                          #
# Parses the command line arguments and fill the global variables.                                                                         #
#                                                                                                                                          #
# Allowed formats                                                                                                                          #
# netdef -a addra -b addrb -c addrc -m subnetmask                                                                                          #
# netdef -a addra -b addrb -c addrc -m subnetmask -f                                                                                       #
# netdef -a addra -b addrb -c addrc -m subnetmask -o                                                                                       #
# netdef -a addra -b addrb -c addrc -m subnetmask -f -o                                                                                    #
# netdef -a addra -b addrb -c addrc -m subnetmask vlanalias                                                                                #
# netdef -a addra -b addrb -c addrc -m subnetmask -o vlanalias                                                                             #
# netdef -a addra -b addrb -c addrc -m subnetmask -f vlanalias                                                                             #
# netdef -a addra -b addrb -c addrc -m subnetmask -o vlanalias                                                                             #
# netdef -a addra -b addrb -c addrc -m subnetmask -f -o vlanalias                                                                          #
# netdef -a addra -b addrb -c addrc -m subnetmask -g gwaddr -d destaddr -s destmask -q dscp                                                #
#    (destaddr and destmask must be 0.0.0.0)                                                                                               #
# netdef -a addra -b addrb -c addrc -m subnetmask -g gwaddr -d destaddr -s destmask -q dscp -o                                             #
#    (destaddr and destmask must be 0.0.0.0)                                                                                               #
# netdef -a addra -b addrb -c addrc -m subnetmask -g gwaddr -d destaddr -s destmask -q dscp -f -o                                          #
#    (destaddr and destmask must be 0.0.0.0)                                                                                               #
# netdef -a addra -b addrb -c addrc -m subnetmask -g gwaddr -d destaddr -s destmask -q dscp vlanalias                                      #
#    (if vlanalias is Public then destaddr and destmask must be 0.0.0.0)                                                                   #
# netdef -a addra -b addrb -c addrc -m subnetmask -g gwaddr -d destaddr -s destmask -q dscp -o vlanalias                                   #
#    (if vlanalias is Public then destaddr and destmask must be 0.0.0.0)                                                                   #
# netdef -a addra -b addrb -c addrc -m subnetmask -g gwaddr -d destaddr -s destmask -q dscp -f -o vlanalias                                #
#    (if vlanalias is Public then destaddr and destmask must be 0.0.0.0)                                                                   #
# netdef -g gwaddr -d destaddr -s destmask -q dscp                                                                                         #
#    (valid only if Public VLAN is defined)                                                                                                #
# netdef -g gwaddr -d destaddr -s destmask -q dscp -f                                                                                      #
#    (valid only if Public VLAN is defined)                                                                                                #
# netdef -g gwaddr -d destaddr -s destmask -q dscp vlanalias                                                                               #
# netdef -g gwaddr -d destaddr -s destmask -q dscp -f vlanalias                                                                            #
# netdef -u [-f] netName                                                                                                                   #
# netdef -a addra -b addrb -c addrc -p prefix-length -v ip-proto-version netName                                                           #
# netdef -a addra -b addrb -c addrc -p prefix-length -v ip-proto-version -f netName                                                        #
# netdef -a addra -b addrb -c addrc -p prefix-length -v ip-proto-version -o netName                                                        #
# netdef -a addra -b addrb -c addrc -p prefix-length -v ip-proto-version -f -o netName                                                     #
# netdef -a addra -b addrb -c addrc -p prefix-length -g gwaddr -d destaddr -l dest-prefix-length -q dscp -v ip-proto-version netname       #
# netdef -a addra -b addrb -c addrc -p prefix-length -g gwaddr -d destaddr -l dest-prefix-length -q dscp -v ip-proto-version netname -f    #
# netdef -a addra -b addrb -c addrc -p prefix-length -g gwaddr -d destaddr -l dest-prefix-length -q dscp -v ip-proto-version netname -o    #
# netdef -a addra -b addrb -c addrc -p prefix-length -g gwaddr -d destaddr -l dest-prefix-length -q dscp -v ip-proto-version netname -f -0 #
# Arguments:                                                                                                                               #
# - $args... command line arguments                                                                                                        #
############################################################################################################################################
function parse_args() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  [ $# -lt 1 ] && usage_error

  local parameters=($@)
  local num_parameters=${#parameters[@]}
  # Retrieve VLAN alias
  #If last parameter is not an option
  if ! [[ ${parameters[$num_parameters - 1]} =~ ^-.*$ ]] ; then
  # netdef netName or netdef vlanalias shall throw usage_error
    if [ $num_parameters -eq 1 ]; then
      usage_error
    fi

    #If last but one is not an option or is -f or is -o
    if ! [[ ${parameters[$num_parameters - 2]} =~ ^-.*$ ]] || [ ${parameters[$num_parameters - 2]} == "-f" ] || [ ${parameters[$num_parameters - 2]} == "-o" ] || [ ${parameters[$num_parameters - 2]} == "-u" ]; then
      OPT_VLAN=$TRUE
      OPT_VLAN_ARG=${parameters[$num_parameters - 1]}

      parameters=(${parameters[@]:0:(($num_parameters - 1))})
    fi
  fi

  if [ $VIRTL_ARCH -eq $TRUE ] && [ $OPT_VLAN -eq $FALSE ]; then
    usage_error
  fi

  if [ $OPT_VLAN -eq $TRUE ] && [[ $OPT_VLAN_ARG =~ ^-.*$ ]] ; then
    usage_error
  fi

  if [ $OPT_VLAN -eq $TRUE ] ; then
    local vlan_name_lowercase=$(echo "$OPT_VLAN_ARG" | ${CMD_AWK} '{ print tolower($0) }')
    if [ "$vlan_name_lowercase" == "public" ] ; then
      [ $VIRTL_ARCH -eq $TRUE ] && console_abort "$exit_invalid_netname_msg" $exit_invalid_netname
      OPT_VLAN_ARG="Public"
    fi
  fi

  local OPTIONS='a: b: c: m: g: d: s: q: v: p: l: u f o r R'

  $CMD_GETOPT --quiet --quiet-output --options="$OPTIONS" -- "${parameters[@]}"
  [ $? -ne $TRUE ] && usage_error

  ARGS="${parameters[@]}"
  eval set -- $ARGS

  while [ $# -gt 0 ]; do
    case "$1" in
      '-a')
        OPT_NODEA=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_NODEA_ARG=${2:-''}
          shift
        fi
      ;;
      '-b')
        OPT_NODEB=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_NODEB_ARG=${2:-''}
          shift
        fi
      ;;
      '-c')
        OPT_MIP=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_MIP_ARG=${2:-''}
          shift
        fi
      ;;
      '-m')
        OPT_SMASK=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_SMASK_ARG=${2:-''};
          is_valid_CIDR_subnet_mask "$OPT_SMASK_ARG" || console_abort "Unreasonable value < $OPT_SMASK_ARG >" $exit_ures_valu
          shift
        fi
      ;;
      '-g')
        OPT_GW=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_GW_ARG=${2:-''};
          shift
        fi
      ;;
      '-d')
        OPT_DEST=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_DEST_ARG=${2:-''};
          shift
        fi
      ;;
      '-s')
        OPT_DMASK=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_DMASK_ARG=${2:-''};
          is_valid_CIDR_subnet_mask "$OPT_DMASK_ARG" || console_abort "Unreasonable value < $OPT_DMASK_ARG >" $exit_ures_valu
          shift
        fi
      ;;
      '-u')
        OPT_UNDEF=$TRUE
      ;;
      '-q')
        OPT_DSCP=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_DSCP_ARG=${2:-''};
          shift
        fi
      ;;
      '-v')
        OPT_IP_VERSION=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_IP_VERSION_ARG=${2:-''};
          [ $OPT_IP_VERSION_ARG -ne 6 ] && [ $OPT_IP_VERSION_ARG -ne 4 ] && console_abort "Unreasonable value < $OPT_IP_VERSION_ARG >" $exit_ures_valu
          shift
        fi
      ;;
      '-p')
        OPT_PREFIX_LENGTH=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_PREFIX_LENGTH_ARG=${2:-''};
          !(isValidPrefixLength "$OPT_PREFIX_LENGTH_ARG") && console_abort "Unreasonable value < $OPT_PREFIX_LENGTH_ARG >" $exit_ures_valu
          shift
        fi
        ;;
      '-l')
        OPT_DEST_PREFIX_LENGTH=$TRUE
        if [[ $2 =~ ^-.*$ ]]; then
          usage_error
        else
          OPT_DEST_PREFIX_LENGTH_ARG=${2:-''};
          !(isValidPrefixLength "$OPT_DEST_PREFIX_LENGTH_ARG") && console_abort "Unreasonable value < $OPT_DEST_PREFIX_LENGTH_ARG >" $exit_ures_valu
          shift
        fi
        ;;
      '-f')
        OPT_FORCE=$TRUE
      ;;
      '-o')
        OPT_OVERWRITE=$TRUE
      ;;
      '-r')
        OPT_RM_STATIC_ROUTE=$TRUE
      ;;
      '-R')
        OPT_RM_ALL_STATIC_ROUTES=$TRUE
      ;;
    esac
    shift
  done

  # Options -a, -b, -c, -m, -d, -g, -s should be in same IP format
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    for arg in $OPT_NODEA_ARG $OPT_NODEB_ARG $OPT_MIP_ARG $OPT_GW_ARG $OPT_DEST_ARG; do
     if ! is_unique_format $arg; then
      console_abort "Unreasonable value < $arg >" $exit_ures_valu
     fi
    done
  fi

  # Options -a, -b, -c and -m must be given together or omitted if $OPT_IP_VERSION_ARG is set false or is set as 4
  # Options -a, -b, -c and -p must be given together or omitted if $OPT_IP_VERSION_ARG is set true and is 6
  local sum_a_b_c_m
  local sum_a_b_c_p
  # Options -g, -d, -s must be given together or omitted if $OPT_IP_VERSION_ARG is set false or is set as 4
  # Options -g, -d, -l must be given together or omitted if $OPT_IP_VERSION_ARG is set true and is 6
  local sum_g_d_s
  local sum_g_d_l
  (( sum_a_b_c_p = $OPT_NODEA + $OPT_NODEB + $OPT_MIP + $OPT_PREFIX_LENGTH ))
  (( sum_a_b_c_m = $OPT_NODEA + $OPT_NODEB + $OPT_MIP + $OPT_SMASK ))
  (( sum_g_d_s = $OPT_GW + $OPT_DEST + $OPT_DMASK ))
  (( sum_g_d_l = $OPT_GW + $OPT_DEST + $OPT_DEST_PREFIX_LENGTH ))

  if [ $VIRTL_ARCH -eq $TRUE ] && [ $OPT_UNDEF -eq $FALSE ]; then
    if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 4 ] ; then
      [ $sum_a_b_c_p -eq 0 ] && console_abort "Unreasonable value < $OPT_IP_VERSION_ARG >" $exit_ures_valu
    fi
    if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
      [ $sum_a_b_c_m -eq 0 ] && console_abort "Unreasonable value < $OPT_IP_VERSION_ARG >" $exit_ures_valu
      [ $sum_a_b_c_p -eq 0 ] && [ $sum_g_d_s -eq 0 ] && console_abort "$exit_format_not_supprted_msg" $exit_format_not_supprted
      [ $sum_a_b_c_p -ne 0 ] && usage_error
      [ $sum_g_d_l -ne 0 ] && [ $sum_g_d_l -ne 3 ] && usage_error
    else
      [ $sum_a_b_c_m -eq 0 ] && [ $sum_g_d_l -eq 0 ] && console_abort "$exit_format_not_supprted_msg" $exit_format_not_supprted
      [ $sum_a_b_c_p -eq 0 ] && console_abort "$exit_format_not_supprted_msg" $exit_format_not_supprted
      [ $sum_a_b_c_m -ne 0 ] && [ $sum_a_b_c_m -ne 4 ] && usage_error
      [ $sum_g_d_s -ne 0 ] && [ $sum_g_d_s -ne 3 ] && usage_error
      [ $sum_a_b_c_m -ne 0 ] && usage_error
    fi
  else
    if [ $OPT_UNDEF -eq $FALSE ]; then
      [ $sum_a_b_c_p -eq 0 ] && [ $OPT_IP_VERSION -eq $FALSE ] && console_abort "$exit_format_not_supprted_msg" $exit_format_not_supprted
      [ $sum_a_b_c_m -ne 0 ] && [ $sum_a_b_c_m -ne 4 ] && usage_error
      [ $sum_g_d_s -ne 0 ] && [ $sum_g_d_s -ne 3 ] && usage_error
    fi
  fi

  if [ $OPT_NODEA -eq $TRUE ] ; then
    is_valid_IP  "$OPT_NODEA_ARG" || console_abort "Unreasonable value < $OPT_NODEA_ARG >" $exit_ures_valu
    is_valid_IP  "$OPT_NODEB_ARG" || console_abort "Unreasonable value < $OPT_NODEB_ARG >" $exit_ures_valu
    is_valid_IP  "$OPT_MIP_ARG" || console_abort "Unreasonable value < $OPT_MIP_ARG >" $exit_ures_valu
    verify_network_IPs_are_different
  fi

  if [ $OPT_GW -eq $TRUE ]; then
    is_valid_IP "$OPT_GW_ARG" || console_abort "Unreasonable value < $OPT_GW_ARG >" $exit_ures_valu
    is_valid_IP "$OPT_DEST_ARG" || console_abort "Unreasonable value < $OPT_DEST_ARG >" $exit_ures_valu
    verify_gateway_IP_is_different_from_network_IPs
  fi

  if [ $OPT_NODEA -eq $FALSE ] && [ $OPT_OVERWRITE -eq $TRUE ] ; then
    usage_error
  fi

  if [ $VIRTL_ARCH -eq $TRUE ] && [ $OPT_VLAN -eq $TRUE ]; then
    OPT_NET_NAME="$OPT_VLAN_ARG"
    if echo $OPT_NET_NAME | $CMD_GREP -iqwE "public|public_v6|ipn[a-b]|internal|data_network|default"; then
      console_abort "$exit_invalid_opt_net_name_msg < $OPT_NET_NAME >" $exit_invalid_opt_net_name
    fi
  fi

  local expected_parameters_number=0
  # Check for extra unwanted parameters
  if [ $sum_a_b_c_m -eq 0 ] ; then
    (( expected_parameters_number = $expected_parameters_number + 8 ))
  fi
  if [ $sum_a_b_c_p -eq 0 ] ; then
    (( expected_parameters_number = $expected_parameters_number + 8 ))
  fi
  if [ $sum_g_d_s -eq 0 ] ; then
    (( expected_parameters_number = $expected_parameters_number + 6 ))
  fi
  if [ $sum_g_d_l -eq 0 ] ; then
    (( expected_parameters_number = $expected_parameters_number + 6 ))
  fi
  if [ $OPT_VLAN -eq $TRUE ] ; then
    (( expected_parameters_number = $expected_parameters_number + 1 ))
  fi

  if [ $OPT_DSCP -eq $TRUE ]; then
    (( expected_parameters_number = $expected_parameters_number + 2 ))

    #checking for dscp error configurations
    ! is_dscp_supported && console_abort "Illegal option <-q> in this system configuration" $exit_fail
    [ $OPT_DEST -eq $FALSE ] && usage_error
  fi
  if  [ $VIRTL_ARCH -eq $TRUE ] && [ $OPT_IP_VERSION -eq $TRUE ] ; then
    (( expected_parameters_number = $expected_parameters_number + 2 ))
  fi

  if [ $OPT_UNDEF -eq $TRUE ]; then
    (( expected_parameters_number = $expected_parameters_number + 1 ))
  fi

  if [ $OPT_RM_STATIC_ROUTE -eq $TRUE ] && [ $OPT_RM_ALL_STATIC_ROUTES -eq $TRUE ] ; then
    usage_error
  fi

  if [ $OPT_OVERWRITE -eq $TRUE ] ; then
    (( expected_parameters_number = $expected_parameters_number + 1 ))
  fi
  if [ $OPT_RM_ALL_STATIC_ROUTES -eq $TRUE ] ; then
    (( expected_parameters_number = $expected_parameters_number + 1 ))
  elif [ $OPT_RM_STATIC_ROUTE -eq $TRUE ] ; then
    (( expected_parameters_number = $expected_parameters_number + 1 ))
  fi

  if [ $OPT_FORCE -eq $TRUE ] ; then
    (( expected_parameters_number = $expected_parameters_number + 1 ))
  fi

  if [ $expected_parameters_number -ne $num_parameters ] ; then
    usage_error
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function check_public_dest_IP();                                                           #
#                                                                                            #
# Verify that passed destination id and subnet mask for OaM network are both 0.0.0.0         #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if destination id and subnet mask are both 0.0.0.0                           #
# Exits:                                                                                     #
# - "Destination IP <$OPT_DEST_ARG> is not allowed for public network"                       #
#   if destination id is different from 0.0.0.0                                              #
# - "Destination mask IP <$OPT_DMASK_ARG> is not allowed for public network"                 #
#   if destination subnet mask is different from 0.0.0.0                                     #
##############################################################################################
function check_public_dest_IP() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  [ "$OPT_DEST_ARG" != "0.0.0.0" ] && console_abort "Destination IP <$OPT_DEST_ARG> is not allowed for public network" $exit_ures_valu
  [ "$OPT_DMASK_ARG" != "0.0.0.0" ] && console_abort "Destination mask IP <$OPT_DMASK_ARG> is not allowed for public network" $exit_ures_valu

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function verify_network_IPs_are_different();                                               #
#                                                                                            #
# Verify that passed network IPs for Node A, Node B and Cluster are all different            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if all IPs are different                                                     #
# Exits:                                                                                     #
# - Unreasonable values if duplicate IPs are passed                                          #
##############################################################################################
function verify_network_IPs_are_different() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    local OPT_NODEA_ARG=$(expand_ipv6_address $OPT_NODEA_ARG)
    local OPT_NODEB_ARG=$(expand_ipv6_address $OPT_NODEB_ARG)
    local OPT_MIP_ARG=$(expand_ipv6_address $OPT_MIP_ARG)
  fi
  [[ "$OPT_NODEA_ARG" == "$OPT_NODEB_ARG" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG >" $exit_ures_valu
  [[ "$OPT_NODEA_ARG" == "$OPT_MIP_ARG" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_MIP_ARG >" $exit_ures_valu
  [[ "$OPT_NODEB_ARG" == "$OPT_MIP_ARG" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_MIP_ARG >" $exit_ures_valu

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function verify_gateway_IP_is_different_from_network_IPs();                                #
#                                                                                            #
# Verify that passed gateway IP is different from passed network IPs                         #
# for Node A, Node B and Cluster are all different                                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if all IPs are different                                                     #
# Exits:                                                                                     #
# - Unreasonable values if duplicate IPs are passed                                          #
##############################################################################################
function verify_gateway_IP_is_different_from_network_IPs() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    local OPT_NODEA_ARG=$(expand_ipv6_address $OPT_NODEA_ARG)
    local OPT_NODEB_ARG=$(expand_ipv6_address $OPT_NODEB_ARG)
    local OPT_MIP_ARG=$(expand_ipv6_address $OPT_MIP_ARG)
    local OPT_GW_ARG=$(expand_ipv6_address $OPT_GW_ARG)
  fi
  [[ "$OPT_NODEA_ARG" == "$OPT_GW_ARG" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_GW_ARG >" $exit_ures_valu
  [[ "$OPT_NODEB_ARG" == "$OPT_GW_ARG" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_GW_ARG >" $exit_ures_valu
  [[ "$OPT_MIP_ARG" == "$OPT_GW_ARG" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_GW_ARG >" $exit_ures_valu

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

############################################################################################################
# function verify_new_nw_IPs_are_diff_from_defined_nw_IPs($old_nodeA_IP,$old_nodeB_IP,$old_cluster_IP,\    #
#                                                            $new_nodeA_IP,$new_nodeB_IP,$new_cluster_IP); #
#                                                                                                          #
# Verify that passed  network IPs are different from defined network IPs                                   #
# for Node A, Node B and Cluster are different                                                             #
#                                                                                                          #
# Returns:                                                                                                 #
# - SUCCESS (0) if IPs are different                                                                       #
# - FAILURE (1) if IPs are same                                                                            #
############################################################################################################
function verify_new_nw_IPs_are_diff_from_defined_nw_IPs() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local old_nodeA_IP="$1"
  local old_nodeB_IP="$2"
  local old_cluster_IP="$3"
  local new_nodeA_IP="$4"
  local new_nodeB_IP="$5"
  local new_cluster_IP="$6"

  [[ "$old_nodeA_IP" == "$new_nodeA_IP" ]] && [[ "$old_nodeB_IP" == "$new_nodeB_IP" ]] && [[ "$old_cluster_IP" == "$new_cluster_IP" ]] &&  rCode=exit_fail

  TRACE_LEAVE $FUNCNAME
  return $rCode
}


##############################################################################################
# function is_network_unique($subnet_id,$networks_to_ignore);                                #
#                                                                                            #
# Given a subnet id (example 192.168.23.44/30) verify that it isn't already assigned to      #
# another network (it looks at the "network" rules in cluster.conf                           #
#                                                                                            #
# Arguments:                                                                                 #
# - $subnet_id subnet id to verify                                                           #
# - $networks_to_ignore network name (or regex) to exclude from the comparison               #
# Note:                                                                                      #
#  The parameter $networks_to_ignore can be used to exclude from the comparison the network  #
#  that is currently being redefined or the destination networks of its additional routes.   #
#  If, for example the network to redefine is the "public" one, we have to ignore:           #
#  - the "public" network name                                                               #
#  - all the networks with names "public_gw1", "public_gw2" etc.                             #
#   (because not-compliant gateways will be removed - true only with -o option)              #
#  So, we have to pass this networks_to_ignore="public|public_gw([0-9])([0-9])*"             #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) in case $subnet_id is unique                                                 #
# - FAILURE (1) in case $subnet_id is not unique                                             #
##############################################################################################
function is_network_unique() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local subnet_id="$1"
  local networks_to_ignore="$2"

  local networks_to_ignore_regex="\s\s*($networks_to_ignore)\s\s*"

  local other_networks=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -Ev "$networks_to_ignore_regex" | tail -n +2 | $CMD_AWK '{ print $4 }' | $CMD_AWK -F'/' '{ print $1 }' | tr '\n' '*')

  local other_id
  IFS=$'*'
  for other_id in $other_networks ; do
    if [ "$other_id" == "$subnet_id" ] ; then
      rCode=$exit_fail
      break
    fi
  done
  unset IFS

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_IP_unique($ip_address,$networks_to_ignore);                                    #
#                                                                                            #
# Given an IP address verify that it isn't already assigned to another network or gateway    #
# (it looks at the "ip", "mip" and "route" rules in cluster.conf)                            #
#                                                                                            #
# Arguments:                                                                                 #
# - $ip_address IP address to verify                                                         #
# - $networks_to_ignore network name (or regex) to exclude from the comparison               #
# Note:                                                                                      #
#  The parameter $networks_to_ignore can be used to exclude from the comparison the network  #
#  that is currently being redefined or the destination networks of its additional routes.   #
#  If, for example the network to redefine is the "public" one, we have to ignore:           #
#  - the "public" network name                                                               #
#  - all the networks with names "public_gw1", "public_gw2" etc.                             #
#   (because not-compliant gateways will be removed- true only with -o option)               #
#  So, we have to pass this networks_to_ignore="public|public_gw([0-9])([0-9])*"             #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) in case $ip_address is unique                                                #
# - FAILURE (1) in case $ip_address is not unique                                            #
##############################################################################################
function is_IP_unique() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local ip_address="$1"
  local networks_to_ignore="$2"

  local networks_to_ignore_regex="\s\s*($networks_to_ignore)\s\s*"

  local other_IPs=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -Ev "$networks_to_ignore_regex" | tail -n +2 | $CMD_AWK '{ print $6 }' | tr '\n' '*')

  local other_IP
  IFS=$'*'
  for other_IP in $other_IPs ; do
    if [ "$other_IP" == "$ip_address" ] ; then
      rCode=$exit_fail
      break
    fi
  done
  unset IFS

  if [ $rCode -ne $exit_fail ] ; then
    local other_gateways=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -Ev "$networks_to_ignore_regex" | tail -n +2 | $CMD_AWK '{ print $6 }' | tr '\n' '*')

    local other_gateway
    IFS=$'*'
    for other_gateway in $other_gateways ; do
      if [ "$other_gateway" == "$ip_address" ] ; then
        rCode=$exit_fail
        break
      fi
    done
    unset IFS
  fi

  if [ $rCode -ne $exit_fail ] ; then
    local other_mips=$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -Ev "$networks_to_ignore_regex" | tail -n +2 | $CMD_AWK '{ print $7 }' | tr '\n' '*')

    local other_mip
    IFS=$'*'
    for other_mip in $other_mips ; do
      if [ "$other_mip" == "$ip_address" ] ; then
        rCode=$exit_fail
        break
      fi
    done
    unset IFS
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function retrieve_VLAN_tag($vlan_name);                                                    #
#                                                                                            #
# Given a VLAN logical name, retrieve the corresponding VLAN tag, if exists.                 #
#                                                                                            #
# Arguments:                                                                                 #
# - $vlan_name VLAN logical name                                                             #
#                                                                                            #
# Return value:                                                                              #
# VLAN tag corresponding to $vlan_name                                                       #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0) in case $vlan_name refers to an existing VLAN                                #
# - FAILURE (1) in case $vlan_name refers to a not-existing VLAN                             #
##############################################################################################
function retrieve_VLAN_tag() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local vlan_name="$1"

  local vlan_tag=""
  if [ -f $VLAN_MAPING_CONF ] ; then
    vlan_tag=$($CMD_CAT $VLAN_MAPING_CONF | $CMD_GREP -w "$vlan_name" | $CMD_AWK '{ print $2 }' | $CMD_AWK -F'.' '{ print $2}')

    is_vAPG && vlan_tag=$($CMD_CAT $VLAN_MAPING_CONF | $CMD_GREP -w "$vlan_name" | $CMD_AWK '{ print $3 }' | $CMD_AWK -F'.' '{ print $2}')
  fi

  if [ "$vlan_tag" != "" ] ; then
    echo "$vlan_tag"
    rCode=$exit_sucs
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function verify_gateways_compliance($source_network_name,$source_network_id);              #
#                                                                                            #
# Checks the compliance of already defined gateways with new required network configuration. #
# Check that gateway IPs are "inside" source network and that source network is not a        #
# "subnet" of destination networks                                                           #
#                                                                                            #
# Arguments:                                                                                 #
# - $source_network_name source network name as used in cluster.conf                         #
# - $source_network_id source network id as used in cluster.conf                             #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0) in case all defined gateways are compliant                                   #
# - FAILURE (1) in case some defined gateways are not compliant                              #
#                                                                                            #
# Exits:                                                                                     #
# - "Invalid routing: < Network configuration is not compatible with the already defined     #
#   gateways. Use -o to overwrite >" in case of FAILURE                                      #
##############################################################################################
function verify_gateways_compliance() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local source_network_name="$1"
  local source_network_id="$2"
  local network_names_ids=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"$source_network_name"_gw[0-9][0-9]*\s\s*" | $CMD_AWK '{ print $3"-"$4 }' | tr '\n' '*')
  local network_names_ids_array=(${network_names_ids//'*'/ })

  local network_name_id
  local network_name_id_components
  local network_name
  local network_id
  local gateway
  for network_name_id in "${network_names_ids_array[@]}" ; do
    if [ "$network_name_id" != "" ] ; then
      network_name_id_components=(${network_name_id//-/ })
      network_name="${network_name_id_components[0]}"
      network_id="${network_name_id_components[1]}"
      #Retrieve gateway IP
      gateway=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -w "$network_name" | $CMD_AWK '{ print $6 }')

      if ! is_gateway_compliant "$source_network_id" "$network_id" "$gateway" ; then
        console_abort "$exit_own_gw_conflict_msg" $exit_own_gw_conflict
      fi
    fi
  done

  rCode=$exit_sucs

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_gateway_compliant($source_network_id,$network_id,$gateway);                    #
#                                                                                            #
# Checks the compliance of the given destination address and gateway with the given source   #
# network.                                                                                   #
#                                                                                            #
# Arguments:                                                                                 #
# - $source_network_id source network id as used in cluster.conf                             #
# - $network_id destination network id as used in cluster.conf                               #
# - $gateway gateway IP                                                                      #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0) in case gateway is compliant                                                 #
# - FAILURE (1) in case gateway is not compliant                                             #
##############################################################################################
function is_gateway_compliant() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail
  local source_network_id="$1"
  local network_id="$2"
  local gateway="$3"

  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    is_gateway_compliant_v6 $source_network_id $network_id $gateway && rCode=$exit_sucs
  else
    local source_network_cidr=$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $2 }')
    local source_network_subnet_mask=$(CIDR_to_subnet_mask "$source_network_cidr")
    local subnet_network_address="$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $1 }')"
    local subnet_broadcast_address="$(compute_broadcast_address "$source_network_id")"

    #Source network is a subnet of $network_id?
    if ! is_subnet_of "$source_network_id" "$network_id" ; then
      local gateway_subnet_id=$(compute_network "$gateway" "$source_network_subnet_mask")
      #Gateway IP is "inside" source network?
      if [ "$gateway_subnet_id" == "$source_network_id" ] ; then
        #Gateway IP is equal to source network address or to source broadcast address?
        if [ "$gateway" != "$subnet_network_address" ] && [ "$gateway" != "$subnet_broadcast_address" ] ; then
          rCode=$exit_sucs
        fi
      fi
    fi

    TRACE_LEAVE $FUNCNAME

  fi
  return $rCode
}

##############################################################################################
# function isValidPrefixLength($prefix_value);                                              #
#                                                                                            #
# To verify that the prefix provided as argument to the command                              #
# (for -p & -l options) is valid one                                                         #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if valid prefix in numeric format was provided                               #
# Exits:                                                                                     #
# - Prefix provided as argument should be numeric. Other than numerics are not allowed.      #
# - Prefix provided as argument should be numeric and lesser than or equal to 128.            #
#   Greater than 128 is not allowed                                                           #
##############################################################################################
function isValidPrefixLength() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail
  local prefix_value="$1"
  local letters=$(echo $prefix_value | tr -dc "([0-9]|\.)")
  local diff=`echo $(( ${#prefix_value} - ${#letters} ))`

  if [ $diff -eq 0 ] ; then
    if [ $prefix_value -ge 0 ] && [ $prefix_value -le 128 ] ; then
      rCode=$exit_sucs
    fi
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}



##############################################################################################
# function prefix_to_hex_format_v6($cidr);                                                   #
#                                                                                            #
# Convert from CIDR notation in hexa decimal format                                          #
# Example: 64 in ffff:ffff:ffff:ffff::                                                       #
#                                                                                            #
# Arguments:                                                                                 #
# - $prefix_length prefix value to convert                                                   #
#                                                                                            #
# Return value:                                                                              #
# Subnet mask corresponding to $prefix_length                                                #
#                                                                                            #
##############################################################################################
function prefix_to_hex_format_v6() {
  TRACE_ENTER $FUNCNAME
  val=
  max_prefix_len=128
  ip6_part_len=16
  nibble_bits=4
  prefix_len=$1
  nibble_max=$(((1<<${nibble_bits}) - 1))
  l_prefix_len=$((${prefix_len} + ${nibble_max}))
  num_ip6_parts=$((${max_prefix_len} >> ${nibble_bits}))
  for ((i=0;i<${num_ip6_parts};i++)) ; do
    lval=0
    base_idx=$((${i} * ${ip6_part_len}))
    for ((j=0;j<${ip6_part_len};j++)) ; do
      idx=$((${base_idx} + ${j}))
      if [ $idx -lt $prefix_len ]; then
        lval=$((${lval} | (1 << ${j})))
      else
        lval=$((${lval} << 1))
      fi
    done
    hex_str=$(echo "obase=16; ${lval}" | bc)
    if [ $i -eq 0 ]; then
      val="$hex_str"
    else
      val="${val}:${hex_str}"
    fi
  done
  echo $val
  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function compute_network_v6($ip_address,$subnet_mask);                                     #
#                                                                                            #
# Given an IP address and a prefix length in hexadecimal format returns the network id       #
#                                                                                            #
# Arguments:                                                                                 #
# - $ip_address valid IP address                                                             #
# - $prefix_length in hexadecimal format                                                     #
#                                                                                            #
# Return value:                                                                              #
# network id                                                                                 #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function compute_network_v6() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local ip_address=$(expand_ipv6_address $1)
  local prefix_hex_format=$(expand_ipv6_address $2)

  local ip_address_component=(${ip_address//:/ })
  local prefix_hex_format_component=(${prefix_hex_format//:/ })

  local num_ip6_parts=8 #each 16 bits
  network_id=
  for ((i = 0; i < ${num_ip6_parts}; i++))
  do
    mask_val=$((0x${ip_address_component[${i}]} & 0x${prefix_hex_format_component[${i}]}))
    if [ $i -eq 0 ]; then
      network_id="$(echo "obase=16; ${mask_val}" | bc)"
    else
      network_id="${network_id}:$(echo "obase=16; ${mask_val}" | bc)"
    fi
  done
  network_id=$(get_ipv6_shortest_form $network_id)
  echo $network_id
  rCode=$exit_sucs
  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
#                                      MAIN OPERATIONS                                       #
##############################################################################################

##############################################################################################
# function invoke();                                                                         #
#                                                                                            #
# If needed, asks the user for confirmation.                                                 #
#                                                                                            #
# Then, execute one of the following actions (see function descriptions)                     #
# netdef_public                                                                              #
# netdef_vlan                                                                                #
# netdef_add_gw                                                                              #
# undefine_network                                                                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "Command aborted by user" if user does not give confirmation                             #
# - netdef_public, netdef_vlan, netdef_add_gw exit codes                                     #
##############################################################################################
function invoke() {
  TRACE_ENTER $FUNCNAME

  [ $OPT_FORCE -eq $FALSE ] &&
  if ! confirm; then
    console_abort "Command aborted by user" $exit_cmnd_abrt
  fi

  local vlan_name_lowercase=$(echo "$OPT_VLAN_ARG" | ${CMD_AWK} '{ print tolower($0) }')
  if [ "$vlan_name_lowercase" == "om" ] ; then
    OPT_DSCP=$FALSE
  elif is_dscp_supported && [[ $OPT_DSCP -ne $TRUE ]]; then
    if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
      OPT_MASK=$OPT_PREFIX_LENGTH
    fi
    if [[ $OPT_GW -eq $TRUE && $OPT_DEST -eq $TRUE && $OPT_MASK -eq $TRUE ]]; then
      OPT_DSCP=$TRUE
      OPT_DSCP_ARG=16
    fi
  fi

  if [ $OPT_UNDEF -eq $TRUE ] ; then
    local NETWORK_NAME=$OPT_VLAN_ARG
    [ -z "$NETWORK_NAME" ] && usage_error

    $( echo $NETWORK_NAME | ${CMD_GREP} -Eq "^[a-zA-Z0-9][a-zA-Z0-9_-]*$") || console_abort "Unreasonable value <$NETWORK_NAME>\n" $exit_fail
    undefine_network $NETWORK_NAME
  elif [ $OPT_RM_STATIC_ROUTE -eq $TRUE ] || [ $OPT_RM_ALL_STATIC_ROUTES -eq $TRUE ] ; then
    netdef_remove_route
  elif [ $OPT_GW -eq $TRUE ] ; then #Triplet -g -d -s has given
    #configuring DSCP value
    if is_dscp_supported && [[ $OPT_DSCP -eq $TRUE ]]; then
      netdef_mod_dscp && return $exit_sucs
    fi
    if [ $OPT_NODEA -eq $TRUE ] ; then #Quartet -a -b -c -m has given
      if [ $VIRTL_ARCH -eq $TRUE ] && [ $OPT_VLAN -eq $TRUE ] ; then
        if [ "$vlan_name_lowercase" == "om" ] ; then
          netdef_public
        else
          #Define Optional networks [ex: cdr, li..]
          netdef_opt_network
        fi
      elif [ $OPT_VLAN -ne $TRUE ] || [ "$OPT_VLAN_ARG" == "Public" ] ; then
        #Redefine OaM network and default gateway (non-compliant gateways are removed)
        netdef_public
      else
        #Redefine VLAN network and its first gateway (non-compliant gateways are removed)
        netdef_vlan
      fi
    else
      #Add additional gateway (for VLAN or Public VLAN)
      netdef_add_gw
    fi
  else #Only quartet -a -b -c -m has given
    if [ $VIRTL_ARCH -eq $TRUE ] && [ $OPT_VLAN -eq $TRUE ] ; then
      if [ "$vlan_name_lowercase" == "om" ] ; then
        netdef_public
      else
        #Define Optional networks [ex: cdr, li..]
        netdef_opt_network
      fi
    elif [ $OPT_VLAN -ne $TRUE ] || [ "$OPT_VLAN_ARG" == "Public" ] ; then
      #Redefine OaM network (non-compliant gateways are removed)
      netdef_public
    else
      #Redefine VLAN network (non-compliant gateways are removed)
      netdef_vlan
    fi
  fi

  TRACE_LEAVE $FUNCNAME
  return $exit_sucs
}

##############################################################################################
# function netdef_public();                                                                  #
#                                                                                            #
# - Redefine OaM network settings (IP A,B,Cluster and subnet mask)                           #
# - If -g is given, redefine default gateway                                                 #
# - If OaM network is defined on Public VLAN remove any non-compliant additional gateway     #
#   (true only with -o option)                                                               #
#                                                                                            #
# Checks:                                                                                    #
# - IP A,B, Cluster are valid IP addresses                                                   #
# - IP A,B, Cluster are different                                                            #
# - Subnet mask is one of the useable CIDR subnet masks from the following table             #
# Netmask              Netmask (binary)                 CIDR     Notes                       #
# _____________________________________________________________________________              #
# 255.255.255.255  11111111.11111111.11111111.11111111  /32  Host (single addr)              #
# 255.255.255.254  11111111.11111111.11111111.11111110  /31  Unuseable                       #
# 255.255.255.252  11111111.11111111.11111111.11111100  /30    2  useable                    #
# 255.255.255.248  11111111.11111111.11111111.11111000  /29    6  useable                    #
# 255.255.255.240  11111111.11111111.11111111.11110000  /28   14  useable                    #
# 255.255.255.224  11111111.11111111.11111111.11100000  /27   30  useable                    #
# 255.255.255.192  11111111.11111111.11111111.11000000  /26   62  useable                    #
# 255.255.255.128  11111111.11111111.11111111.10000000  /25  126  useable                    #
# 255.255.255.0    11111111.11111111.11111111.00000000  /24 "Class C" 254 useable            #
#                                                                                            #
# 255.255.254.0    11111111.11111111.11111110.00000000  /23    2  Class C's                  #
# 255.255.252.0    11111111.11111111.11111100.00000000  /22    4  Class C's                  #
# 255.255.248.0    11111111.11111111.11111000.00000000  /21    8  Class C's                  #
# 255.255.240.0    11111111.11111111.11110000.00000000  /20   16  Class C's                  #
# 255.255.224.0    11111111.11111111.11100000.00000000  /19   32  Class C's                  #
# 255.255.192.0    11111111.11111111.11000000.00000000  /18   64  Class C's                  #
# 255.255.128.0    11111111.11111111.10000000.00000000  /17  128  Class C's                  #
# 255.255.0.0      11111111.11111111.00000000.00000000  /16  "Class B"                       #
#                                                                                            #
# 255.254.0.0      11111111.11111110.00000000.00000000  /15    2  Class B's                  #
# 255.252.0.0      11111111.11111100.00000000.00000000  /14    4  Class B's                  #
# 255.248.0.0      11111111.11111000.00000000.00000000  /13    8  Class B's                  #
# 255.240.0.0      11111111.11110000.00000000.00000000  /12   16  Class B's                  #
# 255.224.0.0      11111111.11100000.00000000.00000000  /11   32  Class B's                  #
# 255.192.0.0      11111111.11000000.00000000.00000000  /10   64  Class B's                  #
# 255.128.0.0      11111111.10000000.00000000.00000000  /9   128  Class B's                  #
# 255.0.0.0        11111111.00000000.00000000.00000000  /8   "Class A"                       #
#                                                                                            #
# 254.0.0.0        11111110.00000000.00000000.00000000  /7                                   #
# 252.0.0.0        11111100.00000000.00000000.00000000  /6                                   #
# 248.0.0.0        11111000.00000000.00000000.00000000  /5                                   #
# 240.0.0.0        11110000.00000000.00000000.00000000  /4                                   #
# 224.0.0.0        11100000.00000000.00000000.00000000  /3                                   #
# 192.0.0.0        11000000.00000000.00000000.00000000  /2                                   #
# 128.0.0.0        10000000.00000000.00000000.00000000  /1                                   #
# 0.0.0.0          00000000.00000000.00000000.00000000  /0   IP space                        #
# - IP A,B, Cluster belongs to the same subnet                                               #
# - If -g is given:                                                                          #
#   - Gateway IP is a valid IP address                                                       #
#   - Gateway IP is different from IP A, B, Cluster                                          #
#   - Destination network id and subnet mask are both 0.0.0.0                                #
# - Default gateway belongs to the same subnet of IP A, B, Cluster                           #
#   If not:                                                                                  #
#   - if -g is given, return "Unreasonable value"                                            #
#   - otherwise, return "Defined parameters are not compatible with current default gateway" #
# - OaM subnet is different from any other defined subnet                                    #
# - IP A, B, Cluster are different from any other defined IP or gateway                      #
# - If -g is given:                                                                          #
#   - Gateway IP is different from any other defined IP or gateway                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "Unreasonable value <value>" if IPs/subnets are not valid or mismatching                 #
# - "Destination IP 0.0.0.0 is not allowed for public network"                               #
# - "Destination mask IP 0.0.0.0 is not allowed for public network"                          #
# - "Network definition conflict: <reason>" if given parameters conflicts with another       #
#   network                                                                                  #
# - "Invalid routing: < Public network configuration is not compatible with the already      #
#    defined default gateway >" if a change of IP A, B and Cluster and subnet mask           #
#    is required, but the already defined default gateway is outside of the new subnet       #
# - "Invalid routing: < Network configuration is not compatible with the already defined     #
#   gateways. Use -o to overwrite >" if -o is not given and new configuration conflicts      #
#   with previously defined gateways                                                         #
# - "Destination network limit reached" if public network is defined on a VLAN with 5        #
#   already defined additional gateways ($MAX_ALWD_GW=5 is the limit)                        #
# - "Error when executing (general fault)"                                                   #
##############################################################################################
function netdef_public() {
 TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    netdef_public_v6 && rCode=$exit_sucs
  else
    local subnet_id_A=$(compute_network "$OPT_NODEA_ARG" "$OPT_SMASK_ARG")
    local subnet_id_B=$(compute_network "$OPT_NODEB_ARG" "$OPT_SMASK_ARG")
    local subnet_id_Cluster=$(compute_network "$OPT_MIP_ARG" "$OPT_SMASK_ARG")

    [[ "$subnet_id_A" == "$subnet_id_B" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$subnet_id_A" == "$subnet_id_Cluster" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$subnet_id_B" == "$subnet_id_Cluster" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu

    local subnet_network_address="$(echo "$subnet_id_Cluster" | $CMD_AWK -F'/' '{ print $1 }')"
    local subnet_broadcast_address="$(compute_broadcast_address "$subnet_id_Cluster")"
    [[ "$OPT_NODEA_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_NODEB_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_MIP_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_NODEA_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_NODEB_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_MIP_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    if [ $OPT_GW -eq $TRUE ] ; then
      check_public_dest_IP
    fi

    local default_gateway
    [[ $OPT_GW -eq $TRUE ]] && default_gateway="$OPT_GW_ARG"
    [[ $OPT_GW -ne $TRUE ]] && default_gateway=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -w default | $CMD_AWK '{ print $6 }')
    [[ "$default_gateway" == "" ]] && console_abort "Gateway cannot be empty for public network" $exit_ures_valu

    local source_subnet_id_GW=$(compute_network "$default_gateway" "$OPT_SMASK_ARG")
    if [ "$source_subnet_id_GW" != "$subnet_id_Cluster" ] ; then
      [[ $OPT_GW -eq $TRUE ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu
      [[ $OPT_GW -ne $TRUE ]] && console_abort "$exit_incompatible_default_gw_msg" $exit_incompatible_default_gw
    fi

    if [ "$default_gateway" == "$subnet_network_address" ] || [ "$default_gateway" == "$subnet_broadcast_address" ] ; then
      [[ $OPT_GW -eq $TRUE ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu
      [[ $OPT_GW -ne $TRUE ]] && console_abort "$exit_incompatible_default_gw_msg" $exit_incompatible_default_gw
    fi

    #Check that network address is unique (in a first step skip comparison with own destination networks)
    local networks_to_ignore="public|public_gw([0-9])([0-9])*"
    is_network_unique "$subnet_network_address" "$networks_to_ignore" || console_abort "$exit_not_unique_network_msg" $exit_not_unique_network

    #Check that gateway IP is unique (skip comparison with own gateways - we must support multiple routes using same gateway)
    if [ $OPT_GW -eq $TRUE ] ; then
      is_IP_unique "$OPT_GW_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
    fi

    #Check that IP addresses are unique (compare also with own gateways)
    networks_to_ignore="public"
    is_IP_unique "$OPT_NODEA_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
    is_IP_unique "$OPT_NODEB_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
    is_IP_unique "$OPT_MIP_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP

    local network_name="public"
    local network_id="$subnet_id_Cluster"
    local physical_interface=$($CMD_GREP ^ip $CLUSTER_CONF | $CMD_GREP $network_name | $CMD_HEAD -1 | $CMD_AWK '{ print $3 }' | $CMD_AWK -F'.' '{ print $1 }')

    local vlan_name="Public"
    local vlan_tag=$(retrieve_VLAN_tag $vlan_name)

    local interface="$physical_interface"
    [[ "$vlan_tag" != "" ]] && interface="$interface.$vlan_tag"

    # TR FIX: HT65008
    #if [ $OPT_OVERWRITE -eq $FALSE ] ; then
      #We cannot overwrite non-compliant gateways
      #Repeat uniqueness check on network address, comparing also with own destination networks
      #is_network_unique "$subnet_id_Cluster" "$networks_to_ignore" || console_abort "$exit_own_gw_conflict_msg" $exit_own_gw_conflict

      #Check for not compliant gateways
      verify_gateways_compliance "$network_name" "$network_id" "$destination_id"
    #fi

    #Save currently defined IP address
    local old_nodeA_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public | $CMD_GREP -w "ip 1" | $CMD_AWK '{ print $6 }')"
    local old_nodeB_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public | $CMD_GREP -w "ip 2" | $CMD_AWK '{ print $6 }')"
    local old_cluster_IP="$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w nbi | $CMD_AWK '{ print $7 }')"

    #verify if DSCP value is correct
    dscp_value=$OPT_DSCP_ARG
      if [ "$dscp_value" != "" ]; then
        !(is_valid_dscp "$dscp_value") && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
      fi

    update_network "$network_name" "$network_id" "$interface"

    if [ $(get_oam_access_attr) -eq 1 ]; then
      update_bonding_arp $physical_interface
    fi

    local destination_id="0.0.0.0/0"
    update_gateways "$network_name" "$destination_id" $TRUE

    if [ "$dscp_value" != "" ] && [[ "$interface" == *.* ]]; then
      update_dscp_value "$destination_id" "$dscp_value"
    fi

    #Verify cluster configuration is OK after update.
    $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
    if [ $rCode -eq $exit_fail ]; then
      # Something wrong. Fallback with older cluster config
      $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management verification failed"
    fi

    update_imm

    # Verify seems to be OK. Reload the cluster now.
    $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
    if [ $rCode -eq $exit_fail ]; then
      # Something wrong in reload. Fallback on older cluster config
      $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management reload failed"
    fi

    # Things seems to be OK so-far. Commit cluster configuration now.
    $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
    if [ $rCode -eq $exit_fail ]; then
      # Commit should not fail, as it involves only removing the
      # back up file. anyway bail-out?
      abort "Cluster Management commit failed"
    fi

    # In case of vAPG, if network changes done for public network,
    # updated values are stored in PSO path. In order to align with
    # AIT-adapted MI
    if [[ $VIRTL_ARCH -eq $TRUE && $OPT_NTWRK -ne $TRUE ]] ; then
      update_pso
    fi
    log "INFO: Network definition is completed. Please reboot cluster"

    # touch reboot needed temporary file
    create_reboot_needed_file
    if [ "$(cat $IKE_VER_FILE)" == "IKEV2" ] ; then
      update_ipsec_ikev2_policies "$old_cluster_IP" "$OPT_MIP_ARG"
    else
      update_ipsec_policies "$old_nodeA_IP" "$old_nodeB_IP" "$old_cluster_IP" "$OPT_NODEA_ARG" "$OPT_NODEB_ARG" "$OPT_MIP_ARG"
    fi
    
    populate_apg_protocol_version

    # apache server configuration
    check_and_update_apache_configuration "$old_cluster_IP" "$OPT_MIP_ARG"
  fi
  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function netdef_public_v6();                                                               #
#                                                                                            #
# - Redefine OaM network settings (IP A,B,Cluster and prefix_length)                         #
# - If -g is given, redefine default gateway                                                 #
# - If OaM network is defined on Public VLAN remove any non-compliant additional gateway     #
#   (true only with -o option)                                                               #
#                                                                                            #
# Checks:                                                                                    #
# - IP A,B, Cluster are valid IP addresses                                                   #
# - IP A,B, Cluster are different                                                            #
# - valid prefix length                                                                      #
# - IP A,B, Cluster belongs to the same subnet                                               #
# - If -g is given:                                                                          #
#   - Gateway IP is a valid IP address                                                       #
#   - Gateway IP is different from IP A, B, Cluster                                          #
#   - Destination network id and subnet mask are both 0                                      #
# - Default gateway belongs to the same subnet of IP A, B, Cluster                           #
#   If not:                                                                                  #
#   - if -g is given, return "Unreasonable value"                                            #
#   - otherwise, return "Defined parameters are not compatible with current default gateway" #
# - OaM subnet is different from any other defined subnet                                    #
# - IP A, B, Cluster are different from any other defined IP or gateway                      #
# - If -g is given:                                                                          #
#   - Gateway IP is different from any other defined IP or gateway                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "Unreasonable value <value>" if IPs/subnets are not valid or mismatching                 #
# - "Destination IP 0.0.0.0 is not allowed for public network"                               #
# - "Destination mask IP 0.0.0.0 is not allowed for public network"                          #
# - "Network definition conflict: <reason>" if given parameters conflicts with another       #
#   network                                                                                  #
# - "Invalid routing: < Public network configuration is not compatible with the already      #
#    defined default gateway >" if a change of IP A, B and Cluster and subnet mask           #
#    is required, but the already defined default gateway is outside of the new subnet       #
# - "Invalid routing: < Network configuration is not compatible with the already defined     #
#   gateways. Use -o to overwrite >" if -o is not given and new configuration conflicts      #
#   with previously defined gateways                                                         #
# - "Destination network limit reached" if public network is defined on a VLAN with 5        #
#   already defined additional gateways ($MAX_ALWD_GW=5 is the limit)                        #
# - "Error when executing (general fault)"                                                   #
##############################################################################################

function netdef_public_v6() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local prefix_to_address=$(prefix_to_hex_format_v6 "$OPT_PREFIX_LENGTH_ARG")

  #subnet_id_B & subnet_id_Cluster results the same as subnet_id_A
  local network_address=$(compute_network_v6 "$OPT_NODEA_ARG" "$prefix_to_address")
  local network_addr_in_CIDR_format_v6=$network_address/$OPT_PREFIX_LENGTH_ARG

  #Checking id the Node A,B and cluster IP's are part of subnet
  if ! partof_ipv6_subnet $OPT_NODEA_ARG $network_address $OPT_PREFIX_LENGTH_ARG; then
    console_abort "Address $OPT_NODEA_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
  fi

  if ! partof_ipv6_subnet $OPT_NODEB_ARG $network_address $OPT_PREFIX_LENGTH_ARG; then
    console_abort "Address $OPT_NODEB_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
  fi

  if ! partof_ipv6_subnet $OPT_MIP_ARG $network_address $OPT_PREFIX_LENGTH_ARG; then
    console_abort "Address $OPT_MIP_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
  fi

  if [ $OPT_GW -eq $TRUE ] ; then
    #checking if gateway is part of same network as node A,B,C IP's
    if ! partof_ipv6_subnet $OPT_GW_ARG $network_address $OPT_PREFIX_LENGTH_ARG; then
      console_abort "Address $OPT_GW_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
    fi

    #For public network the destination prefix length should be 0
    [[ $OPT_DEST_PREFIX_LENGTH_ARG -ne 0 ]] && console_abort "Destination perfix value <$OPT_DEST_PREFIX_LENGTH_ARG> is not allowed for public network" $exit_ures_valu

    dest_network=$(expand_ipv6_address $OPT_DEST_ARG)

    #For public network the destination IP should be 0
    if [ "$dest_network" != "0000:0000:0000:0000:0000:0000:0000:0000" ]; then
      console_abort "Destination IP <$OPT_DEST_ARG> is not allowed for public network" $exit_ures_valu
    else
      dest_network_address="0::0/$OPT_DEST_PREFIX_LENGTH_ARG"
    fi
  fi

  local default_gateway_v6
  [[ $OPT_GW -eq $TRUE ]] && default_gateway_v6="$OPT_GW_ARG"
  [[ $OPT_GW -ne $TRUE ]] && default_gateway_v6=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -w default_v6 | $CMD_AWK '{ print $6 }')
  [[ "$default_gateway_v6" == "" ]] && console_abort "Gateway cannot be empty for public network" $exit_ures_valu
  local source_subnet_id_GW=$(compute_network_v6 "$default_gateway_v6" "$prefix_to_address")
  if [ "$source_subnet_id_GW" != "$network_address" ] ; then
    [[ $OPT_GW -eq $TRUE ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_GW_ARG >" $exit_ures_valu
    [[ $OPT_GW -ne $TRUE ]] && console_abort "$exit_incompatible_default_gw_msg" $exit_incompatible_default_gw
  fi

  #Check that network address is unique (in a first step skip comparison with own destination networks)
  local networks_to_ignore="public_v6"
  is_network_unique "$network_address" "$networks_to_ignore" || console_abort "$exit_not_unique_network_msg" $exit_not_unique_network

  #Check that gateway IP is unique (skip comparison with own gateways - we must support multiple routes using same gateway)
  if [ $OPT_GW -eq $TRUE ] ; then
    is_IP_unique "$OPT_GW_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
  fi

  #Check that IP addresses are unique
  networks_to_ignore="public_v6"
  is_IP_unique "$OPT_NODEA_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
  is_IP_unique "$OPT_NODEB_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
  is_IP_unique "$OPT_MIP_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP

  local network_name="public"
  local physical_interface=$($CMD_GREP ^ip $CLUSTER_CONF | $CMD_GREP -w "$network_name" | $CMD_HEAD -1 | $CMD_AWK '{ print $3 }' | $CMD_AWK -F'.' '{ print $1 }')

  verify_gateways_compliance "$network_name" "$network_address" "$dest_network_address"

  #Save currently defined IP address
  local old_nodeA_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public_v6 | $CMD_GREP -w "ip 1" | $CMD_AWK '{ print $6 }')"
  local old_nodeB_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public_v6 | $CMD_GREP -w "ip 2" | $CMD_AWK '{ print $6 }')"
  local old_cluster_IP="$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w nbi_v6 | $CMD_AWK '{ print $7 }')"


  #verify if DSCP value is correct
  dscp_value=$OPT_DSCP_ARG
  if [ "$dscp_value" != "" ]; then
    !(is_valid_dscp "$dscp_value") && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
  fi

  update_network "$network_name" "$network_addr_in_CIDR_format_v6" "$physical_interface"

  local destination_id_ipv6="0::0/0"
  update_gateways "$network_name" "$destination_id_ipv6" $TRUE
  if [ "$dscp_value" != "" ] && [[ "$interface" == *.* ]]; then
    update_dscp_value "$destination_id_ipv6" "$dscp_value"
  fi

  #Verify cluster configuration is OK after update.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong. Fallback with older cluster config
    $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management verification failed"
  fi

  # Verify seems to be OK. Reload the cluster now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong in reload. Fallback on older cluster config
    $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management reload failed"
  fi

  # Things seems to be OK so-far. Commit cluster configuration now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Commit should not fail, as it involves only removing the
    # back up file. anyway bail-out?
    abort "Cluster Management commit failed"
  fi

  # In case of vAPG, if network changes done for public network,
  # updated values are stored in PSO path. In order to align with
  # AIT-adapted MI
  if [[ $VIRTL_ARCH -eq $TRUE && $OPT_NTWRK -ne $TRUE ]] ; then
    update_pso
  fi
  log "INFO: Network definition is completed. Please reboot cluster"

  # touch reboot needed temporary file
  create_reboot_needed_file

  update_imm

  populate_apg_protocol_version

  if [ "$(cat $IKE_VER_FILE)" == "IKEV2" ] ; then
    update_ipsec_ikev2_policies "$old_cluster_IP" "$OPT_MIP_ARG"
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

function update_pso() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    update_pso_v6
  else
    if [ $OPT_UNDEF -eq $TRUE ] ; then
      for arg in node1_public_network_ipv4_ip_address node2_public_network_ipv4_ip_address cluster_public_network_ipv4_ip_address default_network_ipv4_gateway_ip_address; do
        IpAddress="apos/$arg"
        cat /dev/null > $CONFIG_PATH/$IpAddress
        [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
      done
    else
      # Here CONFIG_PATH is "/storage/system/config"
      # Update nodeA IP address
      if [ -n "$OPT_NODEA_ARG" ]; then
        nodeAIpAddress="apos/node1_public_network_ipv4_ip_address"
        echo "$OPT_NODEA_ARG" > $CONFIG_PATH/$nodeAIpAddress
        [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
      fi

      # Update nodeB IP address
      if [ -n "$OPT_NODEB_ARG" ]; then
        nodeBIpAddress="apos/node2_public_network_ipv4_ip_address"
        echo "$OPT_NODEB_ARG" > $CONFIG_PATH/$nodeBIpAddress
        [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
      fi

      # Update cluster IP address
      if [ -n "$OPT_MIP_ARG" ]; then
        clusterIpAddress="apos/cluster_public_network_ipv4_ip_address"
        echo "$OPT_MIP_ARG" > $CONFIG_PATH/$clusterIpAddress
        [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
      fi


      # Update gateway IP address
      if [ $OPT_GW -eq $TRUE ]; then
        if [ -n "$OPT_MIP_ARG" ]; then
          gatewayIpAddress="apos/default_network_ipv4_gateway_ip_address"
          echo "$OPT_GW_ARG" > $CONFIG_PATH/$gatewayIpAddress
          [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
        fi
      fi
    fi
  fi
  TRACE_LEAVE $FUNCNAME
  return $exit_sucs
}
function update_pso_v6() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  if [ $OPT_UNDEF -eq $TRUE ] ; then
    for arg in node1_public_network_ipv6_ip_address node2_public_network_ipv6_ip_address cluster_public_network_ipv6_ip_address default_network_ipv6_gateway_ip_address; do
      IpAddress="apos/$arg"
      cat /dev/null > $CONFIG_PATH/$IpAddress
      [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
    done
  else
    # Here CONFIG_PATH is "/storage/system/config"
    # Update nodeA IP address
    if [ -n "$OPT_NODEA_ARG" ]; then
      nodeAIpAddress="apos/node1_public_network_ipv6_ip_address"
      echo "$OPT_NODEA_ARG" > $CONFIG_PATH/$nodeAIpAddress
      [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
    fi

    # Update nodeB IP address
    if [ -n "$OPT_NODEB_ARG" ]; then
      nodeBIpAddress="apos/node2_public_network_ipv6_ip_address"
      echo "$OPT_NODEB_ARG" > $CONFIG_PATH/$nodeBIpAddress
      [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
    fi

    # Update cluster IP address
    if [ -n "$OPT_MIP_ARG" ]; then
      clusterIpAddress="apos/cluster_public_network_ipv6_ip_address"
      echo "$OPT_MIP_ARG" > $CONFIG_PATH/$clusterIpAddress
      [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
    fi

    # Update gateway IP address
    if [ $OPT_GW -eq $TRUE ]; then
      if [ -n "$OPT_MIP_ARG" ]; then
        gatewayIpAddress="apos/default_network_ipv6_gateway_ip_address"
        echo "$OPT_GW_ARG" > $CONFIG_PATH/$gatewayIpAddress
        [ $? -ne 0 ] && abort "Error when executing (general fault)" $exit_fail
      fi
    fi
  fi
  TRACE_LEAVE $FUNCNAME
  return $exit_sucs
}

function check_and_update_apache_configuration(){
  TRACE_ENTER $FUNCNAME

  if [ -f "$HTTP_CONFIGURATION_FILE_PATH$HTTP_CONFIGURATION_FILE" ] ;then
    [ ! -x "$LISTEN_CONF_UPDATE" ] && abort "Invalid file permission"
    $LISTEN_CONF_UPDATE "$1" "$2" "$HTTP_CONFIGURATION_FILE_PATH"
  else
    log "INFO: APACHE is not configured on the node"
  fi

  TRACE_LEAVE $FUNCNAME
  return $exit_sucs
}
##############################################################################################
# function netdef_vlan();                                                                    #
#                                                                                            #
# - Redefine network settings (IP A,B,Cluster and subnet mask) for VLAN with alias           #
#   $OPT_VLAN_ARG                                                                            #
# - If -g is given, add the gateway/route                                                    #
# - Remove any other non-compliant gateway                                                   #
#                                                                                            #
# Checks:                                                                                    #
# - VLAN with alias $OPT_VLAN_ARG exists                                                     #
# - IP A,B, Cluster are valid IP addresses                                                   #
# - IP A,B, Cluster are different                                                            #
# - Subnet mask is one of the useable CIDR subnet masks from the following table             #
# Netmask              Netmask (binary)                 CIDR     Notes                       #
# _____________________________________________________________________________              #
# 255.255.255.255  11111111.11111111.11111111.11111111  /32  Host (single addr)              #
# 255.255.255.254  11111111.11111111.11111111.11111110  /31  Unuseable                       #
# 255.255.255.252  11111111.11111111.11111111.11111100  /30    2  useable                    #
# 255.255.255.248  11111111.11111111.11111111.11111000  /29    6  useable                    #
# 255.255.255.240  11111111.11111111.11111111.11110000  /28   14  useable                    #
# 255.255.255.224  11111111.11111111.11111111.11100000  /27   30  useable                    #
# 255.255.255.192  11111111.11111111.11111111.11000000  /26   62  useable                    #
# 255.255.255.128  11111111.11111111.11111111.10000000  /25  126  useable                    #
# 255.255.255.0    11111111.11111111.11111111.00000000  /24 "Class C" 254 useable            #
#                                                                                            #
# 255.255.254.0    11111111.11111111.11111110.00000000  /23    2  Class C's                  #
# 255.255.252.0    11111111.11111111.11111100.00000000  /22    4  Class C's                  #
# 255.255.248.0    11111111.11111111.11111000.00000000  /21    8  Class C's                  #
# 255.255.240.0    11111111.11111111.11110000.00000000  /20   16  Class C's                  #
# 255.255.224.0    11111111.11111111.11100000.00000000  /19   32  Class C's                  #
# 255.255.192.0    11111111.11111111.11000000.00000000  /18   64  Class C's                  #
# 255.255.128.0    11111111.11111111.10000000.00000000  /17  128  Class C's                  #
# 255.255.0.0      11111111.11111111.00000000.00000000  /16  "Class B"                       #
#                                                                                            #
# 255.254.0.0      11111111.11111110.00000000.00000000  /15    2  Class B's                  #
# 255.252.0.0      11111111.11111100.00000000.00000000  /14    4  Class B's                  #
# 255.248.0.0      11111111.11111000.00000000.00000000  /13    8  Class B's                  #
# 255.240.0.0      11111111.11110000.00000000.00000000  /12   16  Class B's                  #
# 255.224.0.0      11111111.11100000.00000000.00000000  /11   32  Class B's                  #
# 255.192.0.0      11111111.11000000.00000000.00000000  /10   64  Class B's                  #
# 255.128.0.0      11111111.10000000.00000000.00000000  /9   128  Class B's                  #
# 255.0.0.0        11111111.00000000.00000000.00000000  /8   "Class A"                       #
#                                                                                            #
# 254.0.0.0        11111110.00000000.00000000.00000000  /7                                   #
# 252.0.0.0        11111100.00000000.00000000.00000000  /6                                   #
# 248.0.0.0        11111000.00000000.00000000.00000000  /5                                   #
# 240.0.0.0        11110000.00000000.00000000.00000000  /4                                   #
# 224.0.0.0        11100000.00000000.00000000.00000000  /3                                   #
# 192.0.0.0        11000000.00000000.00000000.00000000  /2                                   #
# 128.0.0.0        10000000.00000000.00000000.00000000  /1                                   #
# 0.0.0.0          00000000.00000000.00000000.00000000  /0   IP space                        #
# - IP A,B, Cluster belongs to the same subnet                                               #
# - If -g is given:                                                                          #
#   - Gateway IP is a valid IP address                                                       #
#   - Gateway IP is different from IP A, B, Cluster                                          #
#   - Gateway belongs to the same subnet of IP A, B, Cluster                                 #
#   - Destination network is a valid IP address                                              #
#   - Destination subnet mask is one of the useable CIDR subnet masks                        #
#   - Source network isn't a subnet of destination network                                   #
# - VLAN subnet is different from any other defined subnet                                   #
# - IP A, B, Cluster are different from any other defined IP or gateway                      #
# - If -g is given:                                                                          #
#   - Destination subnet is different from any other defined subnet                          #
#   - Gateway IP is different from any other defined IP or gateway                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "VLAN <vlan_name> not found" if VLAN with alias $OPT_VLAN_ARG does not exists            #
# - "Unreasonable value <value>" if IPs/subnets are not valid or mismatching                 #
# - "Network definition conflict: <reason>" if given parameters conflicts with another       #
#   network                                                                                  #
# - "Invalid routing: < Network configuration is not compatible with the already defined     #
#   gateways. Use -o to overwrite >" if -o is not given and new configuration conflicts      #
#   with previously defined gateways                                                         #
# - "Destination network limit reached" if VLAN have 5 already defined additional gateways   #
#   ($MAX_ALWD_GW=5 is the limit)                                                            #
# - "Error when executing (general fault)"                                                   #
##############################################################################################
function netdef_vlan() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
 if [ $OPT_DEST -eq $FALSE ] && [ $OPT_DSCP -eq $TRUE ];     then
    abort "DSCP value is not allowed without destination"
  fi
  local vlan_name="$OPT_VLAN_ARG"
  local vlan_tag=$(retrieve_VLAN_tag $vlan_name)
  [[ "$vlan_tag" == "" ]] && console_abort "VLAN <$vlan_name> not found" $exit_vlan_eror
  local network_name="public_vlan$vlan_tag"

  local subnet_id_A=$(compute_network "$OPT_NODEA_ARG" "$OPT_SMASK_ARG")
  local subnet_id_B=$(compute_network "$OPT_NODEB_ARG" "$OPT_SMASK_ARG")
  local subnet_id_Cluster=$(compute_network "$OPT_MIP_ARG" "$OPT_SMASK_ARG")

  [[ "$subnet_id_A" == "$subnet_id_B" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$subnet_id_A" == "$subnet_id_Cluster" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$subnet_id_B" == "$subnet_id_Cluster" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu

  local subnet_network_address="$(echo "$subnet_id_Cluster" | $CMD_AWK -F'/' '{ print $1 }')"
  local subnet_broadcast_address="$(compute_broadcast_address "$subnet_id_Cluster")"
  [[ "$OPT_NODEA_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$OPT_NODEB_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$OPT_MIP_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$OPT_NODEA_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$OPT_NODEB_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  [[ "$OPT_MIP_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
  local destination_network_id=""
  if [ $OPT_GW -eq $TRUE ] ; then
    local source_subnet_id_GW=$(compute_network "$OPT_GW_ARG" "$OPT_SMASK_ARG")
    [[ "$source_subnet_id_GW" != "$subnet_id_Cluster" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu

    [[ "$OPT_GW_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu
    [[ "$OPT_GW_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu

    [[ "$OPT_DEST_ARG" == "0.0.0.0" ]] && console_abort "Unreasonable value < $OPT_DEST_ARG >" $exit_ures_valu
    destination_network_id=$(compute_network "$OPT_DEST_ARG" "$OPT_DMASK_ARG")
    is_subnet_of "$subnet_id_Cluster" "$destination_network_id" && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_DEST_ARG, $OPT_DMASK_ARG >" $exit_ures_valu
  fi

  #Check that network address is unique (in a first step skip comparison with own destination networks)
  local networks_to_ignore=$network_name"|"$network_name"_gw([0-9])([0-9])*"
  is_network_unique "$subnet_network_address" "$networks_to_ignore" || console_abort "$exit_not_unique_network_msg" $exit_not_unique_network
  local destination_network=$(echo "$destination_network_id" | $CMD_AWK -F'/' '{ print $1 }')

  if [ $OPT_GW -eq $TRUE ] ; then
    #Check that destination network address is unique (in a first step skip comparison with own destination networks)
    is_network_unique "$destination_network" "$networks_to_ignore" || console_abort "$exit_not_unique_dest_network_msg" $exit_not_unique_dest_network
    #Check that gateway IP is unique (skip comparison with own gateways - we must support multiple routes using same gateway)
    is_IP_unique "$OPT_GW_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
  fi

  #Check that IP addresses are unique (compare also with own gateways)
  networks_to_ignore="$network_name"
  is_IP_unique "$OPT_NODEA_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
  is_IP_unique "$OPT_NODEB_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
  is_IP_unique "$OPT_MIP_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP

  local network_id="$subnet_id_Cluster"
  local physical_interface=$($CMD_GREP ^ip $CLUSTER_CONF | $CMD_GREP -w public | $CMD_HEAD -1 | $CMD_AWK '{ print $3 }' | $CMD_AWK -F'.' '{ print $1 }')
  local interface="$physical_interface.$vlan_tag"

   # HT65008 FIX
  if [ $OPT_GW -eq $TRUE ] ; then
    #Repeat uniqueness check on destination network address, comparing also with own destination networks
    is_network_unique "$destination_network" "$networks_to_ignore" || OPT_OVERWRITE=$TRUE
  fi

  #Check for not compliant gateways
  verify_gateways_compliance "$network_name" "$network_id" "$destination_network_id"

  #Save currently defined IP address
  local old_nodeA_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "public_vlan$vlan_tag" | $CMD_GREP -w "ip 1" | $CMD_AWK '{ print $6 }')"
  local old_nodeB_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "public_vlan$vlan_tag" | $CMD_GREP -w "ip 2" | $CMD_AWK '{ print $6 }')"
  local old_cluster_IP="$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w "public_vlan${vlan_tag}_mip" | $CMD_AWK '{ print $7 }')"

  #verify dscp value
  dscp_value=$OPT_DSCP_ARG
  if [ "$dscp_value" != "" ]; then
    !(is_valid_dscp "$dscp_value") && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
  fi

  update_network "$network_name" "$network_id" "$interface"
  update_gateways "$network_name" "$destination_network_id" $FALSE

  if [ "$dscp_value" != "" ] && [ "$destination_network_id" != "" ]; then
    update_dscp_value "$destination_network_id" "$dscp_value"
  fi

  #Verify cluster configuration is OK after update.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong. Fallback with older cluster config
    $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management verification failed"
  fi

  # Verify seems to be OK. Reload the cluster now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong in reload. Fallback on older cluster config
    $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management reload failed"
  fi

  # Things seems to be OK so-far. Commit cluster configuration now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Commit should not fail, as it involves only removing the
    # back up file. anyway bail-out?
    abort "Cluster Management commit failed"
  fi

  log "INFO: Network definition is completed. Please reboot cluster"

  # touch reboot needed temporary file
  create_reboot_needed_file

  if [ "$(cat $IKE_VER_FILE)" == "IKEV2" ] ; then
    update_ipsec_ikev2_policies "$old_cluster_IP" "$OPT_MIP_ARG"
  else
    update_ipsec_policies "$old_nodeA_IP" "$old_nodeB_IP" "$old_cluster_IP" "$OPT_NODEA_ARG" "$OPT_NODEB_ARG" "$OPT_MIP_ARG"
  fi

  # apache server configuration
  check_and_update_apache_configuration "$old_cluster_IP" "$OPT_MIP_ARG"

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function netdef_add_gw();                                                                  #
#                                                                                            #
# - Add a gateway/route for VLAN with alias $OPT_VLAN_ARG or                                 #
#   for Public network (if defined on a VLAN)                                                #
#                                                                                            #
# Checks:                                                                                    #
# - If -v is given                                                                           #
#   - VLAN with alias $OPT_VLAN_ARG exists                                                   #
# - If -v is not given                                                                       #
#   - public network is defined on VLAN                                                      #
# - Gateway IP is a valid IP address                                                         #
# - Destination network is a valid IP address                                                #
# - Destination subnet mask is one of the useable CIDR subnet masks                          #
# - Gateway IP is different from IP A, B, Cluster                                            #
# - Gateway belongs to the same subnet of IP A, B, Cluster                                   #
# - Source network isn't a subnet of destination network                                     #
# - Destination subnet is different from any other defined subnet                            #
# - Gateway IP is different from any other defined IP or gateway                             #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "VLAN <vlan_name> not found" if VLAN with alias $OPT_VLAN_ARG does not exists            #
# - "Additional gateways are not supported when Public network is not defined on a VLAN"     #
#   if -v is not given and Public network is not defined on a VLAN                           #
# - "Unreasonable value <value>" if IPs/subnets are not valid or mismatching                 #
# - "Invalid routing: < reason >" if given route parameters conflict with the source network #
#   for the specified reason                                                                 #
# - "Destination network limit reached" if VLAN have 5 already defined additional gateways   #
#   ($MAX_ALWD_GW=5 is the limit)                                                            #
# - "Error when executing (general fault)"                                                   #
##############################################################################################
function netdef_add_gw() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  local vlan_name="Public"
  if [ $OPT_VLAN -eq $TRUE ] ; then
    vlan_name="$OPT_VLAN_ARG"
  fi

  local vlan_tag=$(retrieve_VLAN_tag $vlan_name)
  if [ "$vlan_tag" == "" ] ; then
    [[ "$vlan_name" != "Public" ]] && console_abort "VLAN <$vlan_name> not found" $exit_vlan_eror
  fi

  [[ "$OPT_DEST_ARG" == "0.0.0.0" ]] && console_abort "Unreasonable value < $OPT_DEST_ARG >" $exit_ures_valu

  local source_network_name
  [[ "$vlan_name" == "Public" ]] && source_network_name="public"
  [[ "$vlan_name" != "Public" ]] && source_network_name="public_vlan$vlan_tag"

  #Retrieve Node A, Node B, Cluster IP addresses
  local nodeA_IP=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "$source_network_name" | $CMD_GREP '^\s\s*[0-9][0-9]*\s\s*ip 1\s\s*' | $CMD_AWK '{ print $6 }')
  [[ "$nodeA_IP" == "" ]] && console_abort "Network for VLAN $vlan_name not defined" $exit_vlan_not_configured
  local nodeB_IP=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "$source_network_name" | $CMD_GREP '^\s\s*[0-9][0-9]*\s\s*ip 1\s\s*' | $CMD_AWK '{ print $6 }')
  local mip_IP=$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w "$source_network_name" | $CMD_AWK '{ print $7 }')

  [[ "$nodeA_IP" == "$OPT_GW_ARG" ]] && console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
  [[ "$nodeB_IP" == "$OPT_GW_ARG" ]] && console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
  [[ "$mip_IP" == "$OPT_GW_ARG" ]] && console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway

  #Retrieve source network id and source network subnet mask
  local source_network_id=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w "$source_network_name" | $CMD_AWK '{ print $4 }')
  local source_network_cidr=$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $2 }')
  source_network_subnet_mask=$(CIDR_to_subnet_mask "$source_network_cidr")

  local subnet_network_address="$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $1 }')"
  local subnet_broadcast_address="$(compute_broadcast_address "$source_network_id")"

  [[ "$OPT_GW_ARG" == "$subnet_network_address" ]] && console_abort "$exit_gw_conflict_msg" $exit_gw_conflict
  [[ "$OPT_GW_ARG" == "$subnet_broadcast_address" ]] && console_abort "$exit_gw_conflict_msg" $exit_gw_conflict

  local source_subnet_id_GW=$(compute_network "$OPT_GW_ARG" "$source_network_subnet_mask")
  [[ "$source_subnet_id_GW" != "$source_network_id" ]] && console_abort "$exit_gw_conflict_msg" $exit_gw_conflict

  local destination_network_id=$(compute_network "$OPT_DEST_ARG" "$OPT_DMASK_ARG")
  is_subnet_of "$source_network_id" "$destination_network_id" && console_abort "$exit_dest_conflict_msg" $exit_dest_conflict

  local networks_to_ignore=default"|"$source_network_name"|"$source_network_name"_gw([0-9])([0-9])*"
  #Check that gateway IP is unique (skip comparison with own gateways - we must support multiple routes using same gateway)
  is_IP_unique "$OPT_GW_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway

  #Check on destination network address, comparing also with own destination networks
  networks_to_ignore="$source_network_name"
  local destination_network=$(echo "$destination_network_id" | $CMD_AWK -F'/' '{ print $1 }')
  is_network_unique "$destination_network" "$networks_to_ignore" || console_abort "$exit_not_unique_dest_network_msg" $exit_not_unique_dest_network

  update_gateways "$source_network_name" "$destination_network_id" $FALSE

  dscp_value=$OPT_DSCP_ARG
  if [ "$dscp_value" != "" ] && [ $destination_network_id != "" ]; then
    !(is_valid_dscp "$dscp_value") && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
    update_dscp_value "$destination_network_id" "$dscp_value"
  fi


  #Verify cluster configuration is OK after update.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong. Fallback with older cluster config
    $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management verification failed"
  fi

  # Verify seems to be OK. Reload the cluster now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong in reload. Fallback on older cluster config
    $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management reload failed"
  fi

  # Things seems to be OK so-far. Commit cluster configuration now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Commit should not fail, as it involves only removing the
    # back up file. anyway bail-out?
    abort "Cluster Management commit failed"
  fi

  log "INFO: Network definition is completed. Please reboot cluster"

  # touch reboot needed temporary file
  create_reboot_needed_file

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_network_locked($network_name);                                                 #
#  Fetch the network for network from AxeTransportMtransportM model                          #
#  Arguments:                                                                                #
# - $network_name value to validate                                                          #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0) if $network_name is locked                                                   #
# - FAILURE (1) if $network_name is not locked                                               #
##############################################################################################
function is_network_locked(){
  local NETWORK_NAME="$1"
  local ADMIN_STATE=$TRUE

  for dn in $( kill_after_try 3 3 4 immfind -c AxeTransportMExternalNetwork)
  do
    local NAME=$( kill_after_try 3 3 4 immlist -a name $dn 2>/dev/null | awk -F'=' '{print $2}')
    if [ "$NETWORK_NAME" == "$NAME" ]; then
      ADMIN_STATE=$( kill_after_try 3 3 4 immlist -a adminState $dn 2>/dev/null | awk -F'=' '{print $2}')
      break;
    fi
  done

  return $ADMIN_STATE
}

##############################################################################################
# function netdef_opt_network();                                                             #
#                                                                                            #
# - Define/Redefine Optional network settings (IP A,B,Cluster subnet mask and gateway)       #
#                                                                                            #
# Checks:                                                                                    #
# - IP A,B, Cluster are valid IP addresses                                                   #
# - IP A,B, Cluster are different                                                            #
# - Subnet mask is one of the useable CIDR subnet masks from the following table             #
# Netmask              Netmask (binary)                 CIDR     Notes                       #
# _____________________________________________________________________________              #
# 255.255.255.255  11111111.11111111.11111111.11111111  /32  Host (single addr)              #
# 255.255.255.254  11111111.11111111.11111111.11111110  /31  Unuseable                       #
# 255.255.255.252  11111111.11111111.11111111.11111100  /30    2  useable                    #
# 255.255.255.248  11111111.11111111.11111111.11111000  /29    6  useable                    #
# 255.255.255.240  11111111.11111111.11111111.11110000  /28   14  useable                    #
# 255.255.255.224  11111111.11111111.11111111.11100000  /27   30  useable                    #
# 255.255.255.192  11111111.11111111.11111111.11000000  /26   62  useable                    #
# 255.255.255.128  11111111.11111111.11111111.10000000  /25  126  useable                    #
# 255.255.255.0    11111111.11111111.11111111.00000000  /24 "Class C" 254 useable            #
#                                                                                            #
# 255.255.254.0    11111111.11111111.11111110.00000000  /23    2  Class C's                  #
# 255.255.252.0    11111111.11111111.11111100.00000000  /22    4  Class C's                  #
# 255.255.248.0    11111111.11111111.11111000.00000000  /21    8  Class C's                  #
# 255.255.240.0    11111111.11111111.11110000.00000000  /20   16  Class C's                  #
# 255.255.224.0    11111111.11111111.11100000.00000000  /19   32  Class C's                  #
# 255.255.192.0    11111111.11111111.11000000.00000000  /18   64  Class C's                  #
# 255.255.128.0    11111111.11111111.10000000.00000000  /17  128  Class C's                  #
# 255.255.0.0      11111111.11111111.00000000.00000000  /16  "Class B"                       #
#                                                                                            #
# 255.254.0.0      11111111.11111110.00000000.00000000  /15    2  Class B's                  #
# 255.252.0.0      11111111.11111100.00000000.00000000  /14    4  Class B's                  #
# 255.248.0.0      11111111.11111000.00000000.00000000  /13    8  Class B's                  #
# 255.240.0.0      11111111.11110000.00000000.00000000  /12   16  Class B's                  #
# 255.224.0.0      11111111.11100000.00000000.00000000  /11   32  Class B's                  #
# 255.192.0.0      11111111.11000000.00000000.00000000  /10   64  Class B's                  #
# 255.128.0.0      11111111.10000000.00000000.00000000  /9   128  Class B's                  #
# 255.0.0.0        11111111.00000000.00000000.00000000  /8   "Class A"                       #
#                                                                                            #
# 254.0.0.0        11111110.00000000.00000000.00000000  /7                                   #
# 252.0.0.0        11111100.00000000.00000000.00000000  /6                                   #
# 248.0.0.0        11111000.00000000.00000000.00000000  /5                                   #
# 240.0.0.0        11110000.00000000.00000000.00000000  /4                                   #
# 224.0.0.0        11100000.00000000.00000000.00000000  /3                                   #
# 192.0.0.0        11000000.00000000.00000000.00000000  /2                                   #
# 128.0.0.0        10000000.00000000.00000000.00000000  /1                                   #
# 0.0.0.0          00000000.00000000.00000000.00000000  /0   IP space                        #
# - IP A,B, Cluster belongs to the same subnet                                               #
# - If -g is given:                                                                          #
#   - Gateway IP is a valid IP address                                                       #
#   - Gateway IP is different from IP A, B, Cluster                                          #
# - Default gateway belongs to the same subnet of IP A, B, Cluster                           #
#   If not:                                                                                  #
#   - if -g is given, return "Unreasonable value"                                            #
#   - otherwise, return "Defined parameters are not compatible with current default gateway" #
# - Optional networks subnet is different from any other defined subnet                      #
# - IP A, B, Cluster are different from any other defined IP or gateway                      #
# - If -g is given:                                                                          #
#   - Gateway IP is different from any other defined IP or gateway                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "Unreasonable value <value>" if IPs/subnets are not valid or mismatching                 #
# - "Network definition conflict: <reason>" if given parameters conflicts with another       #
#   network                                                                                  #
# - "Invalid routing: < optional network configuration is not compatible with the already    #
#    defined default gateway >" if a change of IP A, B and Cluster and subnet mask           #
#    is required, but the already defined default gateway is outside of the new subnet       #
# - "Invalid routing: < Network configuration is not compatible with the already defined     #
# - "Ethernet Interface not available for optional network<network name>" if ethernet        #
#    interface not available                                                                 #
##############################################################################################

function netdef_opt_network() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    netdef_opt_network_v6 && rCode=$exit_sucs
  else
    # check if the optional network is unlocked before proceeding
    local NETWORK_NAME_FROM_MODEL="$OPT_NET_NAME"
    is_valid_networkname $NETWORK_NAME_FROM_MODEL || console_abort "$exit_invalid_opt_net_name_msg" $exit_invalid_opt_net_name
    is_network_locked $NETWORK_NAME_FROM_MODEL && console_abort "$exit_invalid_admin_state_msg" $exit_invalid_admin_state

    if [ $OPT_DEST -eq $FALSE ] && [ $OPT_DSCP -eq $TRUE ]; then
      abort "DSCP value is not allowed without destination"
    fi

    local subnet_id_A=$(compute_network "$OPT_NODEA_ARG" "$OPT_SMASK_ARG")
    local subnet_id_B=$(compute_network "$OPT_NODEB_ARG" "$OPT_SMASK_ARG")
    local subnet_id_Cluster=$(compute_network "$OPT_MIP_ARG" "$OPT_SMASK_ARG")

    [[ "$subnet_id_A" == "$subnet_id_B" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$subnet_id_A" == "$subnet_id_Cluster" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$subnet_id_B" == "$subnet_id_Cluster" ]] || console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_NODEB_ARG, $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu

    local subnet_network_address="$(echo "$subnet_id_Cluster" | $CMD_AWK -F'/' '{ print $1 }')"
    local subnet_broadcast_address="$(compute_broadcast_address "$subnet_id_Cluster")"
    [[ "$OPT_NODEA_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_NODEB_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_MIP_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu

    [[ "$OPT_NODEA_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_NODEA_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_NODEB_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_NODEB_ARG, $OPT_SMASK_ARG >" $exit_ures_valu
    [[ "$OPT_MIP_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG >" $exit_ures_valu

    local destination_network_id=""
    if [ $OPT_GW -eq $TRUE ]; then
      local source_subnet_id_GW=$(compute_network "$OPT_GW_ARG" "$OPT_SMASK_ARG")
      [[ "$source_subnet_id_GW" != "$subnet_id_Cluster" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu

      [[ "$OPT_GW_ARG" == "$subnet_network_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu
      [[ "$OPT_GW_ARG" == "$subnet_broadcast_address" ]] && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_GW_ARG >" $exit_ures_valu

      [[ "$OPT_DEST_ARG" == "0.0.0.0" ]] && console_abort "Unreasonable value < $OPT_DEST_ARG >" $exit_ures_valu
      destination_network_id=$(compute_network "$OPT_DEST_ARG" "$OPT_DMASK_ARG")
      is_subnet_of "$subnet_id_Cluster" "$destination_network_id" && console_abort "Unreasonable value < $OPT_MIP_ARG, $OPT_SMASK_ARG, $OPT_DEST_ARG, $OPT_DMASK_ARG >" $exit_ures_valu
    fi

    local network_id="$subnet_id_Cluster"
    local external_interface=$( get_external_interface $NETWORK_NAME_FROM_MODEL)
    local interface=$( get_netw_interface $external_interface)
    [ -z "$interface" ] && abort "Network interface found NULL"

    # assign static name for network interface
    local network_name="$(get_static_net_name $interface)"
    [ -z "$network_name" ] && abort "Static network name found NULL"

    # Check that network address is unique (in a first step skip comparison with own destination networks)
    local networks_to_ignore="$network_name|"$network_name"_gw([0-9])([0-9])*"
    is_network_unique "$subnet_network_address" "$networks_to_ignore" || console_abort "$exit_not_unique_network_msg" $exit_not_unique_network
 
    local destination_network=$(echo "$destination_network_id" | $CMD_AWK -F'/' '{ print $1 }')

    if [ $OPT_GW -eq $TRUE ] ; then
    # Check that destination network address is unique (in a first step skip comparison with own destination networks)
    is_network_unique "$destination_network" "$networks_to_ignore" || console_abort "$exit_not_unique_dest_network_msg" $exit_not_unique_dest_network

      # Check that gateway IP is unique (skip comparison with own gateways - we must support multiple routes using same gateway)
      is_IP_unique "$OPT_GW_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
    fi

    # Check that IP addresses are unique (compare also with own gateways)
    networks_to_ignore="$network_name"
    is_IP_unique "$OPT_NODEA_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
    is_IP_unique "$OPT_NODEB_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
    is_IP_unique "$OPT_MIP_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP


    if [ $OPT_GW -eq $TRUE ] ; then
      # Repeat uniqueness check on destination network address, comparing also with own destination networks
      is_network_unique "$destination_network" "$networks_to_ignore" || OPT_OVERWRITE=$TRUE
    fi

    # Save currently defined IP address
    local old_nodeA_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public | $CMD_GREP -w "ip 1" | $CMD_AWK '{ print $6 }')"
    local old_nodeB_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public | $CMD_GREP -w "ip 2" | $CMD_AWK '{ print $6 }')"
    local old_cluster_IP="$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w nbi | $CMD_AWK '{ print $7 }')"
    verify_new_nw_IPs_are_diff_from_defined_nw_IPs "$old_nodeA_IP" "$old_nodeB_IP" "$old_cluster_IP" "$OPT_NODEA_ARG" "$OPT_NODEB_ARG" "$OPT_MIP_ARG"

    if [ $? -ne $exit_sucs ]; then
      # Check for not compliant gateways
      verify_gateways_compliance "$network_name" "$network_id" "$destination_id"
    fi

    update_network "$network_name" "$network_id" "$interface"
    update_gateways "$network_name" "$destination_network_id" $FALSE

    if [ $OPT_DSCP -eq $TRUE ] ; then
    # if DSCP value is passed it is needed to check if it is in range or not
    dscp_value=$OPT_DSCP_ARG
    ! is_valid_dscp "$dscp_value" && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
      if [[ "$dscp_value" != "" && "$destination_network_id" != "" ]]; then
      update_dscp_value "$destination_network_id" "$dscp_value"
      fi
    fi

    # Verify cluster configuration is OK after update.
    $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
    if [ $rCode -eq $exit_fail ]; then
      # Something wrong. Fallback with older cluster config
      ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &> /dev/null && abort "Cluster management verification failed"
    fi

    # Verify seems to be OK. Reload the cluster now.
    $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
    if [ $rCode -eq $exit_fail ]; then
      # Something wrong in reload. Fallback on older cluster config
      ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &> /dev/null && abort "Cluster management reload failed"
    fi

    # Things seems to be OK so-far. Commit cluster configuration now.
    $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
    if [ $rCode -eq $exit_fail ]; then
      # Commit should not fail, as it involves only removing the
      # back up file. anyway bail-out?
      abort "Cluster Management commit failed"
    fi
    log "INFO: populating the apg protocol version"
    populate_apg_protocol_version

    log "INFO: Network definition is completed. Please reboot cluster"

    # touch reboot needed temporary file
    create_reboot_needed_file
  fi
  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function netdef_opt_network_v6();                                                          #
#                                                                                            #
# - Define/Redefine Optional network settings (IP A,B,Cluster subnet mask and gateway)       #
#                                                                                            #
# Checks:                                                                                    #
# - IP A,B, Cluster are valid IP addresses                                                   #
# - IP A,B, Cluster are different                                                            #
# - Valid prefix_length                                                                      #
# - IP A,B, Cluster belongs to the same subnet                                               #
# - If -g is given:                                                                          #
#   - Gateway IP is a valid IP address                                                       #
#   - Gateway IP is different from IP A, B, Cluster                                          #
# - Default gateway belongs to the same subnet of IP A, B, Cluster                           #
#   If not:                                                                                  #
#   - if -g is given, return "Unreasonable value"                                            #
#   - otherwise, return "Defined parameters are not compatible with current default gateway" #
# - Optional networks subnet is different from any other defined subnet                      #
# - IP A, B, Cluster are different from any other defined IP or gateway                      #
# - If -g is given:                                                                          #
#   - Gateway IP is different from any other defined IP or gateway                           #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
#                                                                                            #
# Exits:                                                                                     #
# - "Unreasonable value <value>" if IPs/subnets are not valid or mismatching                 #
# - "Network definition conflict: <reason>" if given parameters conflicts with another       #
#   network                                                                                  #
# - "Invalid routing: < optional network configuration is not compatible with the already    #
#    defined default gateway >" if a change of IP A, B and Cluster and subnet mask           #
#    is required, but the already defined default gateway is outside of the new subnet       #
# - "Invalid routing: < Network configuration is not compatible with the already defined     #
# - "Ethernet Interface not available for optional network<network name>" if ethernet        #
#    interface not available                                                                 #
##############################################################################################
function netdef_opt_network_v6() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  # check if the optional network is unlocked before proceeding
  local NETWORK_NAME_FROM_MODEL="$OPT_NET_NAME"
  is_valid_networkname $NETWORK_NAME_FROM_MODEL || console_abort "$exit_invalid_opt_net_name_msg" $exit_invalid_opt_net_name
  is_network_locked $NETWORK_NAME_FROM_MODEL && console_abort "$exit_invalid_admin_state_msg" $exit_invalid_admin_state

  if [ $OPT_DEST -eq $FALSE ] && [ $OPT_DSCP -eq $TRUE ]; then
    abort "DSCP value is not allowed without destination"
  fi

  local prefix_hex_format=$(prefix_to_hex_format_v6 $OPT_PREFIX_LENGTH_ARG)

  local network_id=$(compute_network_v6 "$OPT_MIP_ARG" "$prefix_hex_format")

  if ! partof_ipv6_subnet $OPT_NODEA_ARG $network_id $OPT_PREFIX_LENGTH_ARG; then
    console_abort "Address $OPT_NODEA_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
  fi

  if ! partof_ipv6_subnet $OPT_NODEB_ARG $network_id $OPT_PREFIX_LENGTH_ARG; then
    console_abort "Address $OPT_NODEB_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
  fi

  if ! partof_ipv6_subnet $OPT_MIP_ARG $network_id $OPT_PREFIX_LENGTH_ARG; then
    console_abort "Address $OPT_MIP_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
  fi

  local network_id_Cluster=$network_id/$OPT_PREFIX_LENGTH_ARG
  local external_interface=$( get_external_interface $NETWORK_NAME_FROM_MODEL)
  local interface=$( get_netw_interface $external_interface)
  [ -z "$interface" ] && abort "Network interface found NULL"

  # assign static name for network interface
  local network_name="$(get_static_net_name $interface)"
  [ -z "$network_name" ] && abort "Static network name found NULL"

  # Check that network address is unique (in a first step skip comparison with own destination networks)
  local networks_to_ignore=""$network_name"_v6|"$network_name"_v6_gw([0-9])([0-9])*"
  is_network_unique "$network_id" "$networks_to_ignore" || console_abort "$exit_not_unique_network_msg" $exit_not_unique_network

  local destination_network_id=""
  if [ $OPT_GW -eq $TRUE ]; then
    if ! partof_ipv6_subnet $OPT_GW_ARG $network_id $OPT_PREFIX_LENGTH_ARG; then
      console_abort "Address $OPT_GW_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
    fi

    [[ "$OPT_DEST_ARG" == "0::0" ]] && console_abort "Unreasonable value < $OPT_DEST_ARG >" $exit_ures_valu

    if partof_ipv6_subnet $OPT_DEST_ARG $network_id $OPT_DEST_PREFIX_LENGTH_ARG; then
      console_abort "Address $OPT_DEST_ARG not supported with prefix length $OPT_PREFIX_LENGTH_ARG" $exit_ures_valu
    fi

    local dest_address_hex_format=$(prefix_to_hex_format_v6 $OPT_DEST_PREFIX_LENGTH_ARG)
    destination_network_id=$(compute_network_v6 "$OPT_DEST_ARG" "$dest_address_hex_format")/$OPT_DEST_PREFIX_LENGTH_ARG
    local destination_network=$(echo "$destination_network_id" | $CMD_AWK -F'/' '{ print $1 }')

    # Check that destination network address is unique (in a first step skip comparison with own destination networks)
    is_network_unique "$destination_network" "$networks_to_ignore" || console_abort "$exit_not_unique_dest_network_msg" $exit_not_unique_dest_network

    # Check that gateway IP is unique (skip comparison with own gateways - we must support multiple routes using same gateway)
    is_IP_unique "$OPT_GW_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_gateway_msg" $exit_not_unique_gateway
    networks_to_ignore="$network_name"_v6
    is_network_unique "$destination_network" "$networks_to_ignore" || OPT_OVERWRITE=$TRUE
  fi

  # Check that IP addresses are unique (compare also with own gateways)
  networks_to_ignore="$network_name"_v6
  is_IP_unique "$OPT_NODEA_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
  is_IP_unique "$OPT_NODEB_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP
  is_IP_unique "$OPT_MIP_ARG" "$networks_to_ignore" || console_abort "$exit_not_unique_IP_msg" $exit_not_unique_IP

  # Save currently defined IP address
  local old_nodeA_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public | $CMD_GREP -w "ip 1" | $CMD_AWK '{ print $6 }')"
  local old_nodeB_IP="$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w public | $CMD_GREP -w "ip 2" | $CMD_AWK '{ print $6 }')"
  local old_cluster_IP="$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w nbi | $CMD_AWK '{ print $7 }')"
  verify_new_nw_IPs_are_diff_from_defined_nw_IPs "$old_nodeA_IP" "$old_nodeB_IP" "$old_cluster_IP" "$OPT_NODEA_ARG" "$OPT_NODEB_ARG" "$OPT_MIP_ARG"

  if [ $? -ne $exit_sucs ]; then
    # Check for not compliant gateways
    verify_gateways_compliance "$network_name" "$network_id_Cluster" "$destination_network_id"
  fi

  update_network "$network_name" "$network_id_Cluster" "$interface"
  update_gateways "$network_name" "$destination_network_id" $FALSE

  if [ $OPT_DSCP -eq $TRUE ] ; then
    # if DSCP value is passed it is needed to check if it is in range or not
    dscp_value=$OPT_DSCP_ARG
    ! is_valid_dscp "$dscp_value" && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
    if [[ "$dscp_value" != "" && "$destination_network_id" != "" ]]; then
      update_dscp_value "$destination_network_id" "$dscp_value"
    fi
  fi

  # Verify cluster configuration is OK after update.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong. Fallback with older cluster config
    ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &> /dev/null && abort "Cluster management verification failed"
  fi

  # Verify seems to be OK. Reload the cluster now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong in reload. Fallback on older cluster config
    ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &> /dev/null && abort "Cluster management reload failed"
  fi

  # Things seems to be OK so-far. Commit cluster configuration now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Commit should not fail, as it involves only removing the
    # back up file. anyway bail-out?
    abort "Cluster Management commit failed"
  fi
  log "INFO: populating the apg protocol version"
  populate_apg_protocol_version

  log "INFO: Network definition is completed. Please reboot cluster"

  # touch reboot needed temporary file
  create_reboot_needed_file

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function undefine_network(network_name);                                                   #
#                                                                                            #
# Undefine the network                                                                       #
#                                                                                            #
#  Arguments:                                                                                #
# - $network_name value to undefine                                                          #
#                                                                                            #
# If needed, asks the user for confirmation.                                                 #
#                                                                                            #
# Then, executes the following actions (see function descriptions)                           #
# remove_gateway                                                                             #
# remove_mip                                                                                 #
# remove_alias                                                                               #
# remove_ip                                                                                  #
# remove_iptable                                                                             #
# remove_network                                                                             #
#                                                                                            #
# Exits:                                                                                     #
# - "Command aborted by user" if user does not give confirmation                             #
# - remove_gateway, remove_mip, remove_alias, remove_ip, remove_iptable                      #
# - remove_network exit codes                                                                #
##############################################################################################
function undefine_network(){
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  local NETWORK_NAME="$1"
  local om_network='OM'
  if [ $NETWORK_NAME == "OM" ] ; then
    # check if public and public_v6 networks are defined
    local public_network_count=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "public" | wc -l )
    [[ "$public_network_count" != 2 ]] && console_abort "$exit_om_nw_cannot_be_undef_msg" $exit_om_nw_cannot_be_undef
  fi

  is_valid_networkname $NETWORK_NAME || console_abort "$exit_invalid_opt_net_name_msg" $exit_invalid_opt_net_name

  local EXTERNAL_INTERFACE=$(get_external_interface $NETWORK_NAME)

  local INTERFACE=$(get_netw_interface $EXTERNAL_INTERFACE)
  [ -z "$INTERFACE" ] && abort "Network interface found NULL"

  # assign static name for network interface
  local STATIC_NW_NAME="$( get_static_net_name $INTERFACE)"
  [ -z "$STATIC_NW_NAME" ] && abort "Static network name found NULL"
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
     STATIC_NW_NAME=${STATIC_NW_NAME}_v6
  fi

  is_network_defined $STATIC_NW_NAME || console_abort "$exit_invalid_opt_network_msg" $exit_invalid_opt_network

  # Modifying cluster.conf for local node
  #Removing gateway rules from the cluster.conf
  remove_gateway $STATIC_NW_NAME

  #Removing mip rule from the cluster.conf
  remove_mip $STATIC_NW_NAME

  #Removing alias rule from the cluster.conf
  remove_alias $INTERFACE

  #Removing ip rule from the cluster.conf
  remove_ip $INTERFACE $STATIC_NW_NAME

  #Removing iptables from the cluster.conf
  is_dscp_supported && remove_iptable

  #Removing  network defined
  [ $NETWORK_NAME == "OM" ] && remove_network default
  remove_network $STATIC_NW_NAME

  # verify cluster configuration is OK after update.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong. fallback with older cluster config
    ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &>/dev/null
    abort "Cluster management verification failed."
  fi

  # verify seems to be OK. reload the cluster now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # Something wrong in reload. fallback on older cluster config
    ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &>/dev/null
    abort "Cluster management reload failed."
  fi

  # things seems to be OK so-far. commit cluster configration now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
  if [ $rCode -eq $exit_fail ]; then
    # commit should not fail, as it involves only removing the
    # back up file. anyway bail-out?
    ${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort &>/dev/null
    abort "Cluster Management commit failed"
  fi

  echo -e "INFO: Successfully Removed Network: $NETWORK_NAME \n"

  # touch reboot needed temporary file
  create_reboot_needed_file

  if [ $NETWORK_NAME == "OM" ] ; then
    update_imm
    update_pso
  fi
  populate_apg_protocol_version

  TRACE_LEAVE $FUNCNAME
}

################################################################################################
#                                                                                              #
# function populate_apg_protocol_version()                                                     #
#        This function updates file apg_protocol_version_type in apos PSO path during migration#
#        apg_protocol_version_type with  4   : In case of only IPv4                            #
#        apg_protocol_version_type with  6   : In case of only Ipv6 deployment                 #
#        apg_protocol_version_type with  4,6 : In case of dual stack deployment                #
#                                                                                              #
################################################################################################
function populate_apg_protocol_version() {

  local StackType=''
  local IPv4Stack=$FALSE
  local IPv6Stack=$FALSE
  local DualStack=$FALSE
  local PSO_PATH=$( apos_check_and_cat $STORAGE_CONFIG_PATH)
  local APOS_PSO="$PSO_PATH/apos"

  local IPv4CustCount=$FALSE
  local IPv6CustCount=$FALSE
  local IPV6CUST=$FALSE
  local IPV4CUST=$FALSE

  # check for IPv4 and IPv6 cust networks
  local v4custcount=$($CMD_LDE_CONFIG mip show |$CMD_GREP -i "_mip" |$CMD_GREP -v "v6" |wc -l)
  local v6custcount=$($CMD_LDE_CONFIG mip show |$CMD_GREP -i "v6_mip" |wc -l)
  [ $v4custcount -ne 0 ] && IPV4CUST=$TRUE
  [ $v6custcount -ne 0 ] && IPV6CUST=$TRUE

  # check for IPv4 stack
  [[ ! -z $(grep '[^[:space:]]' "$APOS_PSO/node1_public_network_ipv4_ip_address")    && \
     ! -z $(grep '[^[:space:]]' "$APOS_PSO/node2_public_network_ipv4_ip_address")    && \
     ! -z $(grep '[^[:space:]]' "$APOS_PSO/cluster_public_network_ipv4_ip_address")    && \
     ! -z $(grep '[^[:space:]]' "$APOS_PSO/default_network_ipv4_gateway_ip_address")  ]] && IPv4Stack=$TRUE

  # check for IPv6 stack
  [[ ! -z $(grep '[^[:space:]]' "$APOS_PSO/node1_public_network_ipv6_ip_address")    && \
     ! -z $(grep '[^[:space:]]' "$APOS_PSO/node2_public_network_ipv6_ip_address")    && \
     ! -z $(grep '[^[:space:]]' "$APOS_PSO/cluster_public_network_ipv6_ip_address")    && \
     ! -z $(grep '[^[:space:]]' "$APOS_PSO/default_network_ipv6_gateway_ip_address")  ]] && IPv6Stack=$TRUE

  # check for Dual stack
  if is_vAPG ; then
    [[ $IPv4Stack -eq $TRUE && $IPv6Stack -eq $TRUE ]] && DualStack=$TRUE
    [[ $IPv4Stack -eq $TRUE && $IPV6CUST -eq $TRUE ]] && DualStack=$TRUE
    [[ $IPv6Stack -eq $TRUE && $IPV4CUST -eq $TRUE ]] && DualStack=$TRUE
    echo vapg populate IPV4CUST=$IPV4CUST IPV6CUST=$IPV6CUST DualStack=$DualStack
  else
    echo not vapg populate
    [[ $IPv4Stack -eq $TRUE && $IPv6Stack -eq $TRUE ]] && DualStack=$TRUE
  fi

  [ $IPv4Stack -eq $TRUE ] && StackType='4'
  [ $IPv6Stack -eq $TRUE ] && StackType='6'
  [ $DualStack -eq $TRUE ] && StackType='4,6'

  if [ -n "$StackType" ]; then
    echo "$StackType" > $APOS_PSO/apg_protocol_version_type || \
    apos_abort 'Failure while populating stackType'
  fi
}


##############################################################################################
# function get_static_net_name($interface);                                                  #
#                                                                                            #
# Arguments:                                                                                 #
# - $interface                                                                               #
#                                                                                            #
# Return value:                                                                              #
# 'cust1' if interface is eth7                                                               #
# 'cust2' if interface is eth8                                                               #
#                                                                                            #
##############################################################################################

function get_static_net_name() {
  local static_net_name=''
  case "$1" in
    eth1)
      static_net_name='public'
      ;;
    eth7)
      static_net_name='cust1'
      ;;
    eth8)
      static_net_name='cust2'
      ;;
    eth9)
      static_net_name='cust3'
      ;;
    eth10)
      static_net_name='cust4'
      ;;
  esac
  echo "$static_net_name"

}

##############################################################################################
# function get_netw_interface($interface_dn);                                                #
#                                                                                            #
# Fetch the macaddress of the network from the imm object.                                   #
# Find out which is the nic and where such MAC is in use.                                    #
# Arguments:                                                                                 #
# - $interface_dn DN Name of the network                                                     #
#                                                                                            #
# Return value:                                                                              #
# $interface                                                                                 #
#                                                                                            #
##############################################################################################
function get_netw_interface() {
  local interface=''
  local interface_dn=$1
  local mac=$( kill_after_try 3 3 4 immlist -a mac $interface_dn 2>/dev/null | awk -F'=' '{print $2}')
  if [ -n "$mac" ]; then
    interface=$( mac2nic "$mac")
    if [ $? -ne $TRUE ]; then
      interface=''
    fi
  fi
  echo "$interface"
}

##############################################################################################
# function is_valid_networkname($network_name);                                              #
# Verify if provided network name is is valid network name                                   #
#                                                                                            #
# Arguments:                                                                                 #
# - $network_name network name to validate                                                   #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)if network name is valid                                                      #
# - FAILURE (1)if network name is invalid                                                    #
##############################################################################################
function is_valid_networkname() {
  local network_name=$1

  local external_interface=$( get_external_interface $network_name)
  if [[ $( echo $external_interface | grep -Eq ".*hostId=AP1.*"; echo $?) -eq 0 ]]; then
    return $TRUE
  fi

  return $FALSE
}

##############################################################################################
# function get_external_interface($network_name);                                            #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)if network is already defined
# - FAILURE (1)if network defintion not found
##############################################################################################
function is_network_defined() {
  local network_name="$1"

  if [[ $( $CMD_CLUSTER_CONF network -D | $CMD_GREP -qw "$network_name" 2>/dev/null; echo $?) -eq 0 ]]; then
    return $TRUE
  fi

  return $FALSE
}

##############################################################################################
# function get_external_interface($network_name);                                                  #
#                                                                                            #
# Arguments:                                                                                 #
# - $network_name network name to obtain the external interface                              #
#                                                                                            #
# Return value:                                                                              #
# DN Name of the network                                                                     #
#                                                                                            #
##############################################################################################

function get_external_interface(){
  local network_name=$1

  local hostId='AP1A'
  local nodeId=$( get_node_id)
  [ "$nodeId" -eq 2 ] && hostId='AP1B'

  for dn in $( kill_after_try 3 3 4 immfind -c AxeTransportMExternalNetwork)
  do
    local name=$( kill_after_try 3 3 4 immlist -a name $dn 2>/dev/null | awk -F'=' '{print $2}')
    if [ "$network_name" == "$name" ]; then
      interfaces=$( kill_after_try 3 3 4 immlist -a attachedInterfaces $dn 2>/dev/null)
      if [ "$hostId" == 'AP1A' ]; then
        interface_dn=$( echo $interfaces | awk -F':' '{print $1}' | awk  -F 'attachedInterfaces=' '{print $2}')
      else
        interface_dn=$( echo $interfaces | awk -F':' '{print $2}')
      fi
    fi
  done

  echo $interface_dn
}




##############################################################################################
# function update_network($network_name,$network_id,$interface);                             #
#                                                                                            #
# Update cluster.conf this way:                                                              #
# - Add or modify the rules                                                                  #
#    network $network_name $network_id                                                       #
#    interface control $interface:1 alias                                                    #
#    ip 1 $interface $network_name $OPT_NODEA_ARG                                            #
#    ip 2 $interface $network_name $OPT_NODEB_ARG                                            #
# - If $network_name is "public" add or modify the rule...                                   #
#    mip control nbi $interface:1 $network_name $OPT_MIP_ARG                                 #
# - ... otherwise add or modify the rule                                                     #
#    mip control $network_name_mip $interface:1 $network_name $OPT_MIP_ARG                   #
#                                                                                            #
# Arguments:                                                                                 #
# - $network_name network name to report in cluster.conf                                     #
# - $network_id network id to report in cluster.conf (e.g. 10.35.13.0/24)                    #
# - $interface physical or VLAN interface name upon which define the network                 #
#                                                                                            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
##############################################################################################
function update_network() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local network_name="$1"
  local network_id="$2"
  local interface="$3"

  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    network_name=$1_v6
  fi

  local network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w "$network_name" | $CMD_AWK '{ print $1 }')
  if [ "$network_rule_no" != "" ] ; then
    $CMD_CLUSTER_CONF network --m_modify $network_rule_no:network $network_name $network_id &> /dev/null
  else
    $CMD_CLUSTER_CONF network --m_add $network_name $network_id &> /dev/null
  fi

  if ! [[ $OPT_IP_VERSION -eq $TRUE && $OPT_IP_VERSION_ARG -eq 6 ]] ; then
    local alias_rule_no=$($CMD_CLUSTER_CONF interface -D | $CMD_GREP -w "$interface:1" | $CMD_AWK '{ print $1 }')
    if [ "$alias_rule_no" == "" ] ; then
      $CMD_CLUSTER_CONF interface --m_add control $interface:1 alias &> /dev/null
    fi
  else
    #Adding interface alias for IPv6
    if [ "$network_name" == "public_v6" ]; then
      local alias_rule_no=$($CMD_CLUSTER_CONF interface -D | $CMD_GREP -w "$interface:2" | $CMD_AWK '{ print $1 }')
        if [ "$alias_rule_no" == "" ] ; then
          $CMD_CLUSTER_CONF interface --m_add control $interface:2 alias &> /dev/null
        fi
    fi
  fi

  local mip_name
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    [[ "$network_name" == "public_v6" ]] && mip_name="nbi_v6"
    [[ "$network_name" != "public_v6" ]] && mip_name=$network_name"_mip"
  else
    [[ "$network_name" == "public" ]] && mip_name="nbi"
    [[ "$network_name" != "public" ]] && mip_name=$network_name"_mip"
  fi
  local mip_rule_no=$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w "$mip_name" | $CMD_AWK '{ print $1 }')
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ] ; then
    if [ "$mip_rule_no" != "" ] ; then
      if [ "$network_name" != "public_v6" ]; then
        $CMD_CLUSTER_CONF mip --m_modify $mip_rule_no:mip control $mip_name $interface $network_name $OPT_MIP_ARG &> /dev/null
      else
        $CMD_CLUSTER_CONF mip --m_modify $mip_rule_no:mip control $mip_name $interface:2 $network_name $OPT_MIP_ARG &> /dev/null
      fi
    else
      if [ "$network_name" != "public_v6" ]; then
        $CMD_CLUSTER_CONF mip --m_add control $mip_name $interface $network_name $OPT_MIP_ARG &> /dev/null
      else
        $CMD_CLUSTER_CONF mip --m_add control $mip_name $interface:2 $network_name $OPT_MIP_ARG &> /dev/null
      fi
    fi
  else
    if [ "$mip_rule_no" != "" ] ; then
      $CMD_CLUSTER_CONF mip --m_modify $mip_rule_no:mip control $mip_name $interface:1 $network_name $OPT_MIP_ARG &> /dev/null
    else
      $CMD_CLUSTER_CONF mip --m_add control $mip_name $interface:1 $network_name $OPT_MIP_ARG &> /dev/null
    fi
  fi
  local ipA_rule_no=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "$network_name" | $CMD_GREP -w "ip 1" | $CMD_AWK '{ print $1 }')
  if [ "$ipA_rule_no" != "" ] ; then
    $CMD_CLUSTER_CONF ip --m_modify $ipA_rule_no:ip 1 $interface $network_name $OPT_NODEA_ARG &> /dev/null
  else
    $CMD_CLUSTER_CONF ip --m_add 1 $interface $network_name $OPT_NODEA_ARG &> /dev/null
  fi

  local ipB_rule_no=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "$network_name" | $CMD_GREP -w "ip 2" | $CMD_AWK '{ print $1 }')
  if [ "$ipB_rule_no" != "" ] ; then
    $CMD_CLUSTER_CONF ip --m_modify $ipB_rule_no:ip 2 $interface $network_name $OPT_NODEB_ARG &> /dev/null
  else
    $CMD_CLUSTER_CONF ip --m_add 2 $interface $network_name $OPT_NODEB_ARG &> /dev/null
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}


##############################################################################################
# function update_bonding_arp($bond_interface);                                              #
#                                                                                            #
# Update cluster.conf this way:                                                              #
# - Add or modify the rules                                                                  #
#    bonding control $bond_interface arp $OPT_ARP1_ARG $OPT_ARP2_ARG                         #
#                                                                                            #
# Arguments:                                                                                 #
# - $bond_interface                                                                          #
#                                                                                            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
##############################################################################################
function update_bonding_arp() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local bond_name="$1"

  local bonding_rule_no=$($CMD_CLUSTER_CONF bonding -D | $CMD_GREP -w "arp_ip_target" | $CMD_GREP -w "$bond_name" | $CMD_AWK '{ print $1 }')
  if [ "$bonding_rule_no" != "" ] ; then
    $CMD_CLUSTER_CONF bonding --m_modify $bonding_rule_no:bonding control $bond_name arp_ip_target $OPT_GW_ARG &> /dev/null
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function update_gateways($source_network_name,$destination_id,$is_default);                #
#                                                                                            #
# Remove any gateway/route not compliant with network definition of $source_network_name     #
# Remove both network and route rules in cluster.conf                                        #
# Gateways/routes are not compliant when:                                                    #
#  - gateway IP is equal to $OPT_GW_ARG (in this case the gateway will be later redefined)   #
#  - gateway IP is "outside" of the source network                                           #
#  - source network is "a subnet" of the destination network                                 #
#                                                                                            #
# Re-number all the gateways/routes cluster.conf rules starting from                         #
# $source_network_name_gw1.                                                                  #
#                                                                                            #
# If -g is given:                                                                            #
#  - if $is_default is TRUE add or modify the cluster.conf rule                              #
#    route control default gateway $OPT_GW_ARG                                               #
#  - if $is_default is NOT TRUE                                                              #
#    Checks if the $MAX_ALWD_GW limit is reached and add the cluster.conf rules              #
#    network $source_network_name_gw<n> $destination_id                                      #
#    route control $source_network_name_gw<n> gateway $OPT_GW_ARG                            #
#                                                                                            #
# Arguments:                                                                                 #
# - $source network_name source network name to report in cluster.conf                       #
# - $destination_id destination network id to report in cluster.conf (e.g. 10.35.13.0/24)    #
# - $is_default boolean (if TRUE it is required to redefine the default gateway)             #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (0)                                                                              #
# Exits:                                                                                     #
# - "Destination network limit reached"                                                      #
#   if the $MAX_ALWD_GW limit is reached                                                     #
##############################################################################################
function update_gateways() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local source_network_name="$1"
  local destination_id="$2"
  local is_default=$3
  local routes_count=0

  #Retrieve source network id and source network subnet mask
  local source_network_id
  local source_network_subnet_mask
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    local prefix_hex=$(prefix_to_hex_format_v6 $OPT_PREFIX_LENGTH_ARG)
    source_network_id=$(compute_network_v6 "$OPT_MIP_ARG" "$prefix_hex")/$OPT_PREFIX_LENGTH_ARG
    source_network_name=$1_v6
  else
    if [ $OPT_MIP -eq $TRUE ] ; then
      source_network_id=$(compute_network "$OPT_MIP_ARG" "$OPT_SMASK_ARG")
    else
      source_network_id=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w "$source_network_name" | $CMD_AWK '{ print $4 }')
    fi
  fi

  local network_names_ids=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"$source_network_name"_gw[0-9][0-9]*\s\s*" | $CMD_AWK '{ print $3"-"$4 }' | tr '\n' '*')
  local network_names_ids_array=(${network_names_ids//'*'/ })

  #Build an array of compliant gateways/routes
  local routes=()

  local network_name_id
  local network_name_id_components
  local network_name
  local network_id
  local gateway
  for network_name_id in "${network_names_ids_array[@]}" ; do
    if [ "$network_name_id" != "" ] ; then
      network_name_id_components=(${network_name_id//-/ })
      network_name="${network_name_id_components[0]}"
      network_id="${network_name_id_components[1]}"
      #Retrieve gateway IP
      gateway=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -w "$network_name" | $CMD_AWK '{ print $6 }')

      #Gateway is compliant with new configuration?
      if is_gateway_compliant "$source_network_id" "$network_id" "$gateway" ; then
        routes[$routes_count]="$network_id-$gateway"
        (( routes_count = $routes_count + 1 ))
      fi
    fi
  done

  #Remove all gateways/routes and then re-add only compliant ones
  local network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"$source_network_name"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
  while [ "$network_rule_no" != "" ] ; do
    $CMD_CLUSTER_CONF network --m_delete $network_rule_no &> /dev/null
    network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"$source_network_name"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
  done
  local route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"$source_network_name"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
  while [ "$route_rule_no" != "" ] ; do
    $CMD_CLUSTER_CONF route --m_delete $route_rule_no &> /dev/null
    route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"$source_network_name"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
  done

  local route
  local route_components
  local i=1
  for route in "${routes[@]}" ; do
    route_components=(${route//-/ })
    network_id="${route_components[0]}"
    gateway="${route_components[1]}"

    network_name=$source_network_name"_gw$i"

    $CMD_CLUSTER_CONF network --m_add $network_name $network_id &> /dev/null
    $CMD_CLUSTER_CONF route --m_add control $network_name gateway $gateway &> /dev/null
    (( i = $i + 1 ))
  done

  #Remove all gateways/routes and then re-add only compliant ones
  local network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"$source_network_name"_gw*\s\s*" | tail -1 | $CMD_AWK '{ print $1 }')
  while [ "$network_rule_no" != "" ] ; do
    $CMD_CLUSTER_CONF network --m_delete $network_rule_no &> /dev/null
    network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"$source_network_name"_gw*\s\s*" | tail -1 | $CMD_AWK '{ print $1 }')
  done
  local route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"$source_network_name"_gw*\s\s*" | tail -1 | $CMD_AWK '{ print $1 }')
  while [ "$route_rule_no" != "" ] ; do
    $CMD_CLUSTER_CONF route --m_delete $route_rule_no &> /dev/null
    route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"$source_network_name"_gw*\s\s*" | tail -1 | $CMD_AWK '{ print $1 }')
  done

  local route
  local route_components
  local i=1
  for route in "${routes[@]}" ; do
    route_components=(${route//-/ })
    network_id="${route_components[0]}"
    gateway="${route_components[1]}"

    network_name=$source_network_name"_gw$i"

    $CMD_CLUSTER_CONF network --m_add $network_name $network_id &> /dev/null
    $CMD_CLUSTER_CONF route --m_add control $network_name gateway $gateway &> /dev/null
    (( i = $i + 1 ))
  done

  #Adding default gateway role for IPV6
  if [ $OPT_GW -eq $TRUE ] && [ $is_default -eq $TRUE ] && [ "$source_network_name" == "public_v6" ]; then
    local default_network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w default_v6 | $CMD_AWK '{ print $1 }')
    if [ "$default_network_rule_no" == "" ] ; then
      $CMD_CLUSTER_CONF network --m_add default_v6 $destination_id  &> /dev/null
    fi
  fi

   #Adding default gateway role for IPV4
  if [ $OPT_GW -eq $TRUE ] && [ $is_default -eq $TRUE ] && [ "$source_network_name" == "public" ]; then
    local default_network_rule_no_ipv4=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w default | $CMD_AWK '{ print $1 }')
    if [ "$default_network_rule_no_ipv4" == "" ] ; then
      $CMD_CLUSTER_CONF network --m_add default $destination_id  &> /dev/null
    fi
  fi

  #If -g is given, add/update the new gateway
  if [ $OPT_GW -eq $TRUE ] ; then
    if [ $is_default -eq $TRUE ] ; then
      if [ "$source_network_name" == "public_v6" ]; then
        #Add/modify the default gateway for IPv6
        local default_route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -w default_v6 | $CMD_AWK '{ print $1 }')
        if [ "$default_route_rule_no" != "" ] ; then
          $CMD_CLUSTER_CONF route --m_modify $default_route_rule_no:route control default_v6 gateway $OPT_GW_ARG &> /dev/null
        else
          $CMD_CLUSTER_CONF route --m_add control default_v6 gateway $OPT_GW_ARG &> /dev/null
        fi
      else
        local default_route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP -w default | $CMD_AWK '{ print $1 }')
        if [ "$default_route_rule_no" != "" ] ; then
          $CMD_CLUSTER_CONF route --m_modify $default_route_rule_no:route control default gateway $OPT_GW_ARG &> /dev/null
        else
          $CMD_CLUSTER_CONF route --m_add control default gateway $OPT_GW_ARG &> /dev/null
        fi
      fi
    elif [[ $OPT_OVERWRITE -eq $TRUE && $($CMD_CLUSTER_CONF network -D | $CMD_GREP  $destination_id |$CMD_AWK '{print $1}') != "" ]]; then
     # fetch the exiting rule no
      local route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "$network_name" | tail -n -1 | $CMD_AWK '{ print $1 }')
      if [ "$route_rule_no" != "" ] ; then
        $CMD_CLUSTER_CONF route --m_modify $route_rule_no:route control $network_name gateway $OPT_GW_ARG &> /dev/null
      fi
    else
      [[ $routes_count -eq $MAX_ALWD_GW ]] && console_abort "Destination network limit reached" $exit_ntwk_limt
      (( i = $routes_count + 1 ))
      network_name=$source_network_name"_gw$i"
      $CMD_CLUSTER_CONF network --m_add $network_name $destination_id &> /dev/null
      $CMD_CLUSTER_CONF route --m_add control $network_name gateway $OPT_GW_ARG &> /dev/null
    fi
  fi
  
  #Removing the iptables for the non compliant Gateways
  remove_noncompliant_iptable
  
  rCode=$exit_sucs

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function is_gateway_compliant_v6($source_network_id,$network_id,$gateway);                 #
#                                                                                            #
# Checks the compliance of the given destination address and gateway with the given source   #
# network with IPv6                                                                          #
#                                                                                            #
# Arguments:                                                                                 #
# - $source_network_id source network id as used in cluster.conf                             #
# - $network_id destination network id as used in cluster.conf                               #
# - $gateway gateway IP                                                                      #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0) in case gateway is compliant                                                 #
# - FAILURE (1) in case gateway is not compliant                                             #
##############################################################################################

function is_gateway_compliant_v6() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local source_network_id="$1"
  local network_id="$2"
  local gateway="$3"

  local source_network_address="$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $1 }')"
  local destination_network_address="$(echo "$network_id" | $CMD_AWK -F'/' '{ print $1 }')"
  local source_prefix_length=$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $2 }')
  local source_network_hex_format=$(prefix_to_hex_format_v6 $source_prefix_length)

  #Source network is a subnet of $network_id?
  if ! partof_ipv6_subnet $source_network_address $destination_network_address $OPT_PREFIX_LENGTH_ARG; then
    local gateway_network_id=$(compute_network_v6 "$gateway" "$source_network_hex_format")/$source_prefix_length
    #Gateway IP is "inside" source network?
    if [ "$gateway_network_id" == "$source_network_id" ] ; then
      rCode=$exit_sucs
    fi
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function update_imm();                                                                     #
#                                                                                            #
# Update APG IP addresses (and default gateway) in corresponding attributes of IMM object    #
# northBoundId=1,networkConfigurationId=1                                                    #
#                                                                                            #
# Exits:                                                                                     #
# - "Error when executing (general fault)"                                                   #
#                                                                                            #
# Return codes:                                                                              #
# - SUCCESS (0)                                                                              #
# - FAILURE (0)                                                                              #
##############################################################################################
function update_imm(){
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  log "Updating IMM..."
  local DN=$(${CMD_IMMFIND} | ${CMD_GREP} -i northBound | ${CMD_GREP} -i network 2> /dev/null)
  [ -z "$DN" ] && imm_abort "Error when executing (general fault)" $exit_immx_eror

  # During HW SWAP, when node is in locked state, update of network attributes are failing
  # for 'northbound' DN as LMNorthBound implementer not running. As per JIRA suggestion,
  # applied '-u/--unsafe' option to allow attributes update during locked state without a failure  
  # This change is applied on native (not only HWSWAP) during node-lock and unlock states as well.
  if ! is_vAPG; then
    [ -n "$DN" ] && DN="$DN -u"
  fi 

  local prefix=$($CMD_CLUSTER_CONF network -D | ${CMD_GREP} -w public_v6 | ${CMD_AWK} '{print $4}' | cut -d '/' -f 2)
  local smask=$($CMD_CLUSTER_CONF network -D | ${CMD_GREP} -w public | ${CMD_AWK} '{print $4}' | cut -d '/' -f 2)
  if [ -n "$smask" ]; then
    local cidr_smask=$(CIDR_to_subnet_mask $smask)
  fi
  if [[ -n "$prefix" && -n "$smask" ]]; then
    $(kill_after_try 3 3 4 ${CMD_IMMCFG} -a netmask=$cidr_smask,$prefix $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  else
    $(${CMD_IMMCFG} -a netmask=$cidr_smask$prefix $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  fi

  local nodeaip4=$($CMD_CLUSTER_CONF ip -D | ${CMD_GREP} -w public | ${CMD_AWK} '{print $6}' | head -1 )
  local nodeaip6=$($CMD_CLUSTER_CONF ip -D |  ${CMD_GREP} -w public_v6 | ${CMD_AWK} '{print $6}' | head -1 )
  if [[ -n "$nodeaip4" && -n "$nodeaip6" ]]; then
    $(${CMD_IMMCFG} -a nodeAIpAddress=$nodeaip4,$nodeaip6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  else
    $(${CMD_IMMCFG} -a nodeAIpAddress=$nodeaip4$nodeaip6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  fi

  local nodebip4=$($CMD_CLUSTER_CONF ip -D | ${CMD_GREP} -w public | ${CMD_AWK} '{print $6}' | tail -1 )
  local nodebip6=$($CMD_CLUSTER_CONF ip -D | ${CMD_GREP} -w public_v6 | ${CMD_AWK} '{print $6}' | tail -1 )
  if [[ -n "$nodebip4" && -n "$nodebip6" ]]; then
    $(${CMD_IMMCFG} -a nodeBIpAddress=$nodebip4,$nodebip6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  else
    $(${CMD_IMMCFG} -a nodeBIpAddress=$nodebip4$nodebip6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  fi

  local cluip4=$($CMD_CLUSTER_CONF mip -D | ${CMD_GREP} -w nbi | ${CMD_AWK} '{print $7}')
  local cluip6=$($CMD_CLUSTER_CONF mip -D | ${CMD_GREP} -w nbi_v6 | ${CMD_AWK} '{print $7}')
  if [[ -n "$cluip4" &&  -n "$cluip6" ]]; then
    $(${CMD_IMMCFG} -a clusterIpAddress=$cluip4,$cluip6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  else
    $(${CMD_IMMCFG} -a clusterIpAddress=$cluip4$cluip6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
  fi

   local gw4=$($CMD_CLUSTER_CONF route -D | ${CMD_GREP} -w default | ${CMD_AWK} '{print $6}')
   local gw6=$($CMD_CLUSTER_CONF route -D | ${CMD_GREP} -w default_v6 | ${CMD_AWK} '{print $6}')
   if [[ -n "$gw4" && -n "$gw6" ]]; then
    $(${CMD_IMMCFG} -a gatewayIpAddress=$gw4,$gw6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
   else
    $(${CMD_IMMCFG} -a gatewayIpAddress=$gw4$gw6 $DN &> /dev/null)
    [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
   fi

  return $exit_sucs
}

############################################################################################################################
# function update_ipsec_policies($old_nodeA_IP,$old_nodeB_IP,$old_cluster_IP,$new_nodeA_IP,$new_nodeB_IP,$new_cluster_IP); #
#                                                                                                                          #
# Update the IPSec configuration files, overwriting old IP addresses with the new ones.                                    #
# If the IPSec features provided by ACS_ASECBIN are not installed, this function does nothing.                             #
# The check is done on the existence of ipsecls script                                                                     #
#                                                                                                                          #
# Arguments:                                                                                                               #
# - $old_nodeA_IP old APG Node A IP address                                                                                #
# - $old_nodeB_IP old APG Node B IP address                                                                                #
# - $old_cluster_IP old APG Cluster IP address                                                                             #
# - $new_nodeA_IP new APG Node A IP address                                                                                #
# - $new_nodeB_IP new APG Node B IP address                                                                                #
# - $new_cluster_IP new APG Cluster IP address                                                                             #
#                                                                                                                          #
# Exits:                                                                                                                   #
# - "Error when executing (general fault)"                                                                                 #
#                                                                                                                          #
# Return codes:                                                                                                            #
# - SUCCESS (0)                                                                                                            #
# - FAILURE (0)                                                                                                            #
############################################################################################################################
function update_ipsec_policies() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail
  
  if which ipsecls &> /dev/null ; then
    local old_nodeA_IP="$1"
    local old_nodeB_IP="$2"
    local old_cluster_IP="$3"
    local new_nodeA_IP="$4"
    local new_nodeB_IP="$5"
    local new_cluster_IP="$6"
  
    if [ "$old_nodeA_IP" != "" ] && [ "$old_nodeB_IP" != "" ] && [ "$old_cluster_IP" != "" ] && [ "$new_nodeA_IP" != "" ] && [ "$new_nodeB_IP" != "" ] && [ "$new_cluster_IP" != "" ] ; then
      [[ -e $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE ]] || console_abort "Error when executing (general fault)" $exit_fail
  
      pushd $IPSEC_CONF_DIR &> /dev/null
      local remote_configuration_files=($(ls *.racoon.conf 2> /dev/null))
      popd $IPSEC_CONF_DIR &> /dev/null
  
      local remote_configuration_file
      for remote_configuration_file in "${remote_configuration_files[@]}" ; do
        sed -i "s/sainfo address $old_cluster_IP\/32/sainfo address $new_cluster_IP\/32/" $IPSEC_CONF_DIR"/"$remote_configuration_file &> /dev/null
        sed -i "s/sainfo address $old_nodeA_IP\/32/sainfo address $new_nodeA_IP\/32/" $IPSEC_CONF_DIR"/"$remote_configuration_file &> /dev/null
        sed -i "s/sainfo address $old_nodeB_IP\/32/sainfo address $new_nodeB_IP\/32/" $IPSEC_CONF_DIR"/"$remote_configuration_file &> /dev/null
      done
  
      sed -i "s/ ${old_cluster_IP}\[any\]/ ${new_cluster_IP}\[any\]/" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE &> /dev/null
      sed -i "s/ ${old_nodeA_IP}\[any\]/ ${new_nodeA_IP}\[any\]/" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE &> /dev/null
      sed -i "s/ ${old_nodeB_IP}\[any\]/ ${new_nodeB_IP}\[any\]/" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE &> /dev/null
      sed -i "s/\/${old_cluster_IP}-/\/${new_cluster_IP}-/" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE
      sed -i "s/-${old_cluster_IP}\//-${new_cluster_IP}\//" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE
      sed -i "s/\/${old_nodeA_IP}-/\/${new_nodeA_IP}-/" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE
      sed -i "s/-${old_nodeA_IP}\//-${new_nodeA_IP}\//" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE
      sed -i "s/\/${old_nodeB_IP}-/\/${new_nodeB_IP}-/" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE
      sed -i "s/-${old_nodeB_IP}\//-${new_nodeB_IP}\//" $IPSEC_CONF_DIR"/"$IPSEC_SETKEY_FILE
  
      rCode=$exit_sucs
    fi
  fi
  
  TRACE_LEAVE $FUNCNAME
  return $rCode
}
############################################################################################################################
# function update_ipsec_ikev2_policies($old_cluster_IP,$new_cluster_IP);                                                   #
#                                                                                                                          #
# Update the ikev2 IPSec configuration files, overwriting old IP addresses with the new ones.                              #
# If the IPSec features provided by ACS_ASECBIN are not installed, this function does nothing.                             #
# The check is done on the existence of ipsecls script                                                                     #
#                                                                                                                          #
# Arguments:                                                                                                               #
# - $old_cluster_IP old APG Cluster IP address                                                                             #
# - $new_cluster_IP new APG Cluster IP address                                                                             #
#                                                                                                                          #
# Exits:                                                                                                                   #
# - "Error when executing (general fault)"                                                                                 #
#                                                                                                                          #
# Return codes:                                                                                                            #
# - SUCCESS (0)                                                                                                            #
# - FAILURE (0)                                                                                                            #
############################################################################################################################

update_ipsec_ikev2_policies() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_fail

  local connNameList=""
  local attrData=""
  local ipAddress=""
  local connName=""
  local old_cluster_IP="$1"
  local new_cluster_IP="$2"

  if [[ -n "$old_cluster_IP" && -n "$new_cluster_IP" ]] ; then
    connNameList=$($CMD_GREP -i "^conn" $STRONGSWAN_CFGFILE)

    if [[ -n "$connNameList" ]]
    then
      while IFS= read -r name
      do
        connName=$(cut -d' ' -f2 <<< $name)
        attrData=$(kill_after_try 3 3 4 ${CMD_IMMLIST} -a ipsecParam ipsecConnectionId=$connName,acsSecurityMId=1 2> /dev/null)
	[ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror

	if [[ -z "$attrData" ]] ; then
	  console_abort "Error when executing (general fault)" $exit_fail 
	fi

        ipAddress=$(cut -d'=' -f2 <<< $attrData)

        if [ "$ipAddress" == $old_cluster_IP ] ; then
          $(kill_after_try 3 3 4 ${CMD_IMMCFG} -a ipsecParam=$new_cluster_IP ipsecConnectionId=$connName,acsSecurityMId=1 &> /dev/null)
	  [ $? -ne 0 ] && imm_abort "Error when executing (general fault)" $exit_immx_eror
        fi
      done <<< "$connNameList"
    else
      log "INFO: NO IPSEC IKEV2 policies defined"
    fi
    rCode=$exit_sucs
  fi

  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function update_dscp_value($destination_address $dscp_value);                              #
#                                                                                            #
# Update cluster.conf this way:                                                              #
# - Add or modify the rules                                                                  #
#    iptables all -t mangle -A OUTPUT -s $OPT_DEST_NET -j DSCP --set-dscp $OPT_DSCP          #
#                                                                                            #
# Arguments:                                                                                 #
# - $destination_address $dscp_value                                                         #
#                                                                                            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
##############################################################################################
function update_dscp_value() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  local destination_address=$1
  local dscp_value=$2
  local iptables="iptables"

  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    iptables="ip6tables"
  fi

  local record=$($CMD_CLUSTER_CONF $iptables -D | $CMD_GREP -w $destination_address | $CMD_AWK '{print $1}')
  local old_dscp_value=$($CMD_CLUSTER_CONF $iptables -D | $CMD_GREP -w $destination_address | $CMD_AWK '{print $13}')

  if [ "$record" == "" ] ; then
    $CMD_CLUSTER_CONF $iptables --m_add all -t mangle -A OUTPUT -d $destination_address -j DSCP --set-dscp $dscp_value &> /dev/null
  else
    [[ "$old_dscp_value" == $dscp_value ]] && return $exit_fail
    $CMD_CLUSTER_CONF $iptables -m $record:$iptables all -t mangle -A OUTPUT -d $destination_address -j DSCP --set-dscp $dscp_value &> /dev/null
  fi
  TRACE_LEAVE $FUNCNAME
  return $rCode
}

##############################################################################################
# function netdef_mod_dscp();                                                                #
#                                                                                            #
# modifies the dscp value when all the other parameters(-a,-b,-c,-m,-g,-s,-d) are same       #
#                                                                                            #
# Checks:                                                                                    #
#     check if vlan exists in cluster conf                                                   #
#     check if given IP's and subnet are valid                                               #
#     validate destination network from given inputs                                         #
#     validating source IP's                                                                 #
#     validate Gateway                                                                       #
#     validate DSCP and update                                                               #
#                                                                                            #
#                                                                                            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function netdef_mod_dscp() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  if [ $OPT_IP_VERSION -eq $TRUE ] && [ $OPT_IP_VERSION_ARG -eq 6 ]; then
    netdef_mod_dscp_v6 && return $TRUE
  else
    local vlan_name="Public"
    if [ $OPT_VLAN -eq $TRUE ] ; then
      vlan_name="$OPT_VLAN_ARG"
    fi

    # check if given vlan exists in cluser conf
    if ! is_vAPG; then
      local vlan_tag=$(retrieve_VLAN_tag $vlan_name)
      if [ "$vlan_tag" == "" ] ; then
        [[ "$vlan_name" != "Public" ]] && console_abort "VLAN <$vlan_name> not found" $exit_vlan_eror
        [[ "$vlan_name" == "Public" ]] && return $FALSE
      fi
    fi

    # check if given IP's and subnet are valid
    local tmpstr="_";

    #calculating destination network from given inputs
    destination_oldnetwork_id=$(compute_network "$OPT_DEST_ARG" "$OPT_DMASK_ARG")
    local source_network_name
    local destination_network_name_default=""
    local destination_network_name
    if [ "$vlan_name" == "Public" ]; then
      source_network_name="public"
      destination_network_name_default="default"
    fi

    if is_vAPG; then
      source_network_name='cust'
      destination_network_name="$source_network_name.*[1-2]_"
    else
      [[ "$vlan_name" != "Public" ]] && source_network_name="public_vlan$vlan_tag"
      destination_network_name="$source_network_name$tmpstr"
    fi

    #validating destination network
    local destination_network=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "$destination_network_name" | $CMD_AWK '{ print $4 }' | $CMD_GREP $destination_oldnetwork_id )

    if [[ "$destination_network_name_default" != "" ]] ; then
      local destination_network_default=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "$destination_network_name_default"  | $CMD_AWK '{ print $4 }' | $CMD_GREP $destination_oldnetwork_id )
    fi

    [[ "$destination_network" == "" ]] && [[ "$destination_network_default" == "" ]] && return $FALSE

    #Retrieve Node A, Node B, Cluster IP addresses  to compare with the given input values.
    local source_list=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "$source_network_name")
    [[ "$source_list" == "" ]] && return $FALSE

    local nodeA_IP=$(echo "$source_list" | $CMD_GREP '^\s\s*[0-9][0-9]*\s\s*ip 1\s\s*' | $CMD_AWK '{ print $6 }')
    local nodeB_IP=$(echo "$source_list"   | $CMD_GREP '^\s\s*[0-9][0-9]*\s\s*ip 2\s\s*' | $CMD_AWK '{ print $6 }')
    local mip_IP=$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -w "$source_network_name" | $CMD_AWK '{ print $7 }')

    #validating source IP's
    if  [ $OPT_NODEA -eq $TRUE ] ; then
      [[ "$nodeA_IP" != "$OPT_NODEA_ARG" ]] && return $FALSE
      [[ "$nodeB_IP" != "$OPT_NODEB_ARG" ]] && return $FALSE
      [[ "$mip_IP"   != "$OPT_MIP_ARG" ]]  &&  return $FALSE

      local source_network=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w "$source_network_name" )
      [[ "$source_network" = "" ]] && return $FALSE

      #validating source subnetmask
      local source_network_id=$(echo "$source_network" | $CMD_AWK '{ print $4 }')
      local source_network_cidr=$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $2 }')
      source_network_subnet_mask=$(CIDR_to_subnet_mask "$source_network_cidr")
      [ "$source_network_subnet_mask" != "$OPT_SMASK_ARG" ] && return $FALSE
    fi

    #validating gateway
    local gateway_id=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "$destination_network_name" | $CMD_AWK '{ print $6 }' | $CMD_GREP -w "$OPT_GW_ARG")
    if [[ "$destination_network_name_default" != "" ]] ; then
          local gateway_id_default=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "$destination_network_name_default" | $CMD_AWK '{ print $6 }' | $CMD_GREP -w "$OPT_GW_ARG")
    fi
    [[ "$gateway_id" == "" ]] && [[ "$gateway_id_default" == "" ]] && return $FALSE

    if [ $OPT_DSCP -eq $TRUE ] ; then
      #if DSCp value is passed it is needed to check if it is in range or not
      dscp_value=$OPT_DSCP_ARG
      !(is_valid_dscp "$dscp_value") && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
      update_dscp_value "$destination_oldnetwork_id" "$dscp_value"

      #Verify cluster configuration is OK after update.
      $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail
      if [ $rCode -eq $exit_fail ]; then
        # Something wrong. Fallback with older cluster config
        $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management verification failed"
      fi

      # Verify seems to be OK. Reload the cluster now.
      $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail
      if [ $rCode -eq $exit_fail ]; then
        # Something wrong in reload. Fallback on older cluster config
        $(${CMD_CLUSTER_CONF} $CLUS_MGMT_OPTS --abort) && abort "Cluster management reload failed"
      fi

      #Things seems to be OK so-far. Commit cluster configuration now.
      $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
      if [ $rCode -eq $exit_fail ]; then
        # Commit should not fail, as it involves only removing the
        # back up file. anyway bail-out?
        abort "Cluster Management commit failed"
      fi

      log "INFO: Network definition is completed. Please reboot cluster"

      # touch reboot needed temporary file
      create_reboot_needed_file
    else
      return $FALSE
    fi
  return $TRUE
  fi
  return $FALSE
  TRACE_LEAVE $FUNCNAME
}

##############################################################################################
# function netdef_mod_dscp_v6();                                                             #
#                                                                                            #
# modifies the dscp value when all the other parameters(-a,-b,-c,-p,-g,-s,-l) are same       #
#                                                                                            #
# Checks:                                                                                    #
#     check if vlan exists in cluster conf                                                   #
#     check if given IP's and subnet are valid                                               #
#     validate destination network from given inputs                                         #
#     validating source IP's                                                                 #
#     validate Gateway                                                                       #
#     validate DSCP and update                                                               #
#                                                                                            #
#                                                                                            #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function netdef_mod_dscp_v6() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs

  local vlan_name="Public_v6"
  if [ $OPT_VLAN -eq $TRUE ] ; then
    vlan_name="$OPT_VLAN_ARG"_v6
  fi

  local dest_prefix_hex_format=$(prefix_to_hex_format_v6 $OPT_DEST_PREFIX_LENGTH_ARG)
  local tmpstr="_";

  #calculating destination network from given inputs
  destination_oldnetwork_id=$(compute_network_v6 "$OPT_DEST_ARG" "$dest_prefix_hex_format")/$OPT_DEST_PREFIX_LENGTH_ARG
  local source_network_name
  local destination_network_name_default=""
  local destination_network_name
  if [ "$vlan_name" == "Public_v6" ]; then
    source_network_name="public_v6"
    destination_network_name_default="default_v6"
  else
    source_network_name=$(echo "$vlan_name" | ${CMD_AWK} '{ print tolower($0) }')
    destination_network_name="cust.*[1-2]_"
  fi
  #validating destination network
  local destination_network=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "$destination_network_name" | $CMD_AWK '{ print $4 }' | $CMD_GREP $destination_oldnetwork_id )

  if [[ "$destination_network_name_default" != "" ]] ; then
    local destination_network_default=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "$destination_network_name_default"  | $CMD_AWK '{ print $4 }' | $CMD_GREP $destination_oldnetwork_id )
  fi
  [[ "$destination_network" == "" ]] && [[ "$destination_network_default" == "" ]] && return $FALSE
  #Retrieve Node A, Node B, Cluster IP addresses  to compare with the given input values.
  local source_list=$($CMD_CLUSTER_CONF ip -D | $CMD_GREP -w "$source_network_name")
  [[ "$source_list" == "" ]] && return $FALSE
  local nodeA_IP=$(echo "$source_list" | $CMD_GREP '^\s\s*[0-9][0-9]*\s\s*ip 1\s\s*' | $CMD_AWK '{ print $6 }')
  local nodeB_IP=$(echo "$source_list"   | $CMD_GREP '^\s\s*[0-9][0-9]*\s\s*ip 2\s\s*' | $CMD_AWK '{ print $6 }')
  local mip_IP=$($CMD_CLUSTER_CONF mip -D | $CMD_GREP -i "$source_network_name" | $CMD_AWK '{ print $7 }')

  #validating source IP's
  [[ "$nodeA_IP" != "$OPT_NODEA_ARG" ]] && return $FALSE
  [[ "$nodeB_IP" != "$OPT_NODEB_ARG" ]] && return $FALSE
  [[ "$mip_IP"   != "$OPT_MIP_ARG" ]]  &&  return $FALSE

  local source_network=$($CMD_CLUSTER_CONF network -D | $CMD_GREP -w "$source_network_name" )
  [[ "$source_network" = "" ]] && return $FALSE

  #validating source subnetmask
  local source_network_id=$(echo "$source_network" | $CMD_AWK '{ print $4 }')
  local source_network_cidr=$(echo "$source_network_id" | $CMD_AWK -F'/' '{ print $2 }')
  [ $source_network_cidr != $OPT_PREFIX_LENGTH_ARG ] && return $FALSE

  #validating gateway
  local gateway_id=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "$destination_network_name" | $CMD_AWK '{ print $6 }' | $CMD_GREP -w "$OPT_GW_ARG")
  if [[ "$destination_network_name_default" != "" ]] ; then
    local gateway_id_default=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "$destination_network_name_default" | $CMD_AWK '{ print $6 }' | $CMD_GREP -w "$OPT_GW_ARG")
  fi
  [[ "$gateway_id" == "" ]] && [[ "$gateway_id_default" == "" ]] && return $FALSE
  if [ $OPT_DSCP -eq $TRUE ] ; then
    #if DSCp value is passed it is needed to check if it is in range or not
    dscp_value=$OPT_DSCP_ARG
    !(is_valid_dscp "$dscp_value") && console_abort "Unreasonable value < $dscp_value >" $exit_ures_valu
    update_dscp_value "$destination_oldnetwork_id" "$dscp_value"
    log "INFO: Network definition is completed. Please reboot cluster"
    # touch reboot needed temporary file
    create_reboot_needed_file
  else
    return $FALSE
  fi

  TRACE_LEAVE $FUNCNAME
  return $TRUE

}

##############################################################################################
# function netdef_remove_route();                                                            #
#                                                                                            #
# if -r option is specified, remove the specified static route                               #
# if -R option is specified, removes all the static routes present in one shot               #
#                                                                                            #
# Checks:                                                                                    #
#     Check if given static route is default one                                             #
#     Check if the specified gateway and destinaltion exists or not                          #
#                                                                                            #
# Returns:                                                                                   #
# - SUCCESS (0)                                                                              #
# - FAILURE (1)                                                                              #
##############################################################################################
function netdef_remove_route() {
  TRACE_ENTER $FUNCNAME
  local rCode=$exit_sucs
  local route_rule_no
  if isBSP || is_vAPG ; then
    console_abort "Illegal option in this system configuration" $exit_fail
  fi
  log "Removing static routes..."
  if [ $OPT_RM_ALL_STATIC_ROUTES -eq $TRUE ]; then
    local network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"public"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
    while [ "$network_rule_no" != "" ] ; do
      $CMD_CLUSTER_CONF network --m_delete $network_rule_no &> /dev/null
      network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"public"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
    done
    local route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"public"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
    while [ "$route_rule_no" != "" ] ; do
      $CMD_CLUSTER_CONF route --m_delete $route_rule_no &> /dev/null
      route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"public"_gw[0-9][0-9]*\s\s*" | tail -n -1 | $CMD_AWK '{ print $1 }')
    done
    local network_vlan_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"public_vlan*.*"_gw" | tail -n -1 | $CMD_AWK '{ print $1 }')
    while [ "$network_vlan_rule_no" != "" ] ; do
      $CMD_CLUSTER_CONF network --m_delete $network_vlan_rule_no &> /dev/null
      network_vlan_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP "\s\s*"public_vlan*.*"_gw" | tail -n -1 | $CMD_AWK '{ print $1 }')
    done
    local route_vlan_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"public_vlan*.*"_gw" | tail -n -1 | $CMD_AWK '{ print $1 }')
    while [ "$route_vlan_rule_no" != "" ] ; do
      $CMD_CLUSTER_CONF route --m_delete $route_vlan_rule_no &> /dev/null
      route_vlan_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP "\s\s*"public_vlan*.*"_gw" | tail -n -1 | $CMD_AWK '{ print $1 }')
    done
  else
    local destination_network_id=$(compute_network "$OPT_DEST_ARG" "$OPT_DMASK_ARG")
    local network_rule_no=$($CMD_CLUSTER_CONF network -D | $CMD_GREP $destination_network_id | $CMD_AWK '{ print $1 }')
    if [ "$network_rule_no" == "" ] ; then
      console_abort "Specified static route does not exist"
    fi
    local network_gateway_name=$($CMD_CLUSTER_CONF network -D | $CMD_GREP $destination_network_id | $CMD_AWK '{ print $3 }')
    route_gateway=$($CMD_CLUSTER_CONF route -D | $CMD_GREP $network_gateway_name | $CMD_AWK '{ print $6 }')
    if [ "$route_gateway" != "$OPT_GW_ARG" ] ; then
      console_abort "Specified static route does not exist"
    fi
    route_rule_no=$($CMD_CLUSTER_CONF route -D | $CMD_GREP $network_gateway_name | $CMD_AWK '{ print $1 }')
    local default_gateway=$($CMD_CLUSTER_CONF route -D | $CMD_GREP default | $CMD_AWK '{ print $1 }')
    if [ "$route_rule_no" == "$default_gateway" ] ; then
      console_abort "Cannot delete the default gateway"
    else
      $CMD_CLUSTER_CONF route --m_delete $route_rule_no &> /dev/null
      $CMD_CLUSTER_CONF network --m_delete $network_rule_no &> /dev/null
    fi
    fi
  #Verify cluster configuration is OK after update.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --verify &> /dev/null || rCode=$exit_fail

  # Verify seems to be OK. Reload the cluster now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --reload --verbose &>/dev/null || rCode=$exit_fail

  # Things seems to be OK so-far. Commit cluster configuration now.
  $CMD_CLUSTER_CONF $CLUS_MGMT_OPTS --commit &>/dev/null || rCode=$exit_fail
  log "...done"
  TRACE_LEAVE $FUNCNAME
  return $rCode
}


# _____________________
#|    _ _   _  .  _    |
#|   | ) ) (_| | | )   |
#|_____________________|
# Here begins the "main" function...

# Log the parameters in the system log
log "START: <$0 $*>"

# sanity check to see if things are in place
sanity_check

# parse the command-line paramters
parse_args $*

# invoke the command
invoke

log "END: <$0 $*>"

# the script returns the status of the last invoked function
exit $exit_sucs
