#!/bin/bash -u
##
# ------------------------------------------------------------------------
#     Copyright (C) 2014 Ericsson AB. All rights reserved.
# ------------------------------------------------------------------------
##
# Name:
#       clearrtfd
# Description:
#       The "set clearrtfd" sub-command of the bspmngr tool.
##
# Changelog:
# Fri Feb 21 2014 - Stefano V
#		Code cleanup and optimization
# Fri Feb 07 2014 - Rajeshwari Padavala (xcsrpad) 
#		First Version
##

. $BSPMNGR_DIR/$LIB_COMMON_DIR/bspmngr_common.sh

gpr_query=
check_debug

function is_verbose(){
	return $OPT_VERBOSE	
}

function set_clearrtfd(){
	
  is_slot $BOARD
  EXIT_CODE=$?
  if [ $EXIT_CODE -ne $TRUE ]; then
  	clean_xml
	abort "Board name specified is not supported"
  fi
	

  #fetch IP addresses of DMXC
  fetch_dmxc_ip

  #fetch shelf address
  fetch_shelf_address

  #fetch shelf id
  fetch_shelf_id

  # set default image on board
  bios_query=$(printf BIOS%02d%02dDIB2 $SHELF_ID $BOARD )
  #echo $bios_query

  $ironsidecmd -a $DMXC_IP_A -p $DMXC_PORT -s "$bios_query" -o $TMP_FILE > /dev/null
  EXIT_CODE=$?
  if [ $EXIT_CODE -ne $TRUE ]; then
	if [ $EXIT_CODE -eq $NC_SESSION_OPEN_FAILED ]; then
		$ironsidecmd -a $DMXC_IP_B -p $DMXC_PORT -s "$bios_query" -o $TMP_FILE > /dev/null
		EXIT_CODE=$?
                if [ $EXIT_CODE -ne $TRUE ]; then
		      clean_xml
	              abort "Setting default image on board $BOARD failed" 
            	fi
	else
	      clean_xml
	      abort "Setting default image on board $BOARD failed" 
        fi
  fi
  clean_xml

  # set bios pointer on board
  biosptr_query=$(printf BIOS%02d%02dPTB2 $SHELF_ID $BOARD )

  $ironsidecmd -a $DMXC_IP_A -p $DMXC_PORT -s "$biosptr_query" -o $TMP_FILE > /dev/null
  EXIT_CODE=$?
  if [ $EXIT_CODE -ne $TRUE ]; then
	if [ $EXIT_CODE -eq $NC_SESSION_OPEN_FAILED ]; then
		$ironsidecmd -a $DMXC_IP_B -p $DMXC_PORT -s "$biosptr_query" -o $TMP_FILE > /dev/null
		EXIT_CODE=$?
                if [ $EXIT_CODE -ne $TRUE ]; then
		      clean_xml
	              abort "Setting BIOS pointer on board $BOARD failed" 
            	fi
	else
	      clean_xml
	      abort "Setting BIOS pointer on board $BOARD failed" 
        fi
  fi
	
  printf "BIOS pointer and default image set to UPG.\n"
  clean_xml

  #construct the gpr command
  set_gpr
  #gpr_query="\x23\x07\x01\x00\x80\x00\x00\x00\x00\x00\x00\x00" 

  $ironsidecmd -a $DMXC_IP_A -p $DMXC_PORT -h "$gpr_query" -o $TMP_FILE > /dev/null
  EXIT_CODE=$?
  if [ $EXIT_CODE -ne $TRUE ]; then
	if [ $EXIT_CODE -eq $NC_SESSION_OPEN_FAILED ]; then
		$ironsidecmd -a $DMXC_IP_B -p $DMXC_PORT -h "$gpr_query" -o $TMP_FILE > /dev/null
		EXIT_CODE=$?
                if [ $EXIT_CODE -ne $TRUE ]; then
			clean_xml
			abort "Clearing of RTFD flag failed $EXIT_CODE\n"
            	fi
	else
		clean_xml
		abort "Clearing of RTFD flag failed $EXIT_CODE\n"
        fi
  fi


	if [ -s "$TMP_FILE" ];then
			retval=$(echo `cat $TMP_FILE` )
			if [ "$retval" == "ok" -o "$retval" == "OK" ]; then
				printf "RTFD flag successfully cleared\n"
			else
				abort "Clearing of RTFD flag failed $retval\n"
			fi
		else
			printf "Clearing of RTFD flag failed\n"
		fi
	clean_xml
}
function usage(){
	cat $MAN_DIR/set_clearrtfd.man   
}
# set_gpr is used to constuct the gpr command which is '#' followed by 3 bytes are formatted (MSB) as HHHHLLLL, LGGGGGGG, GGGGGGGG where H=shelf, L=slot, G=GPR ID and arg1 byte(0-4)bit mask and arg2 byte(0-4) value.In this function 2nd to 4th byte is first formed in binary and then converted to hex and finally formed the entire hex command is formed.
function set_gpr()
{
	gprvalue=$(echo "80:00:00:00:00:00:00:00" ) #gpr register 256
	gpr=256
	dot=":"
	bytes1="23"
	slot=$(echo "obase=2;$BOARD" | bc)
	slot=$(printf %05d $slot)
	shelf=$(echo "obase=2;$SHELF_ID" | bc)
	shelf=$(printf %04d $shelf)
	gpr=$(echo "obase=2;$gpr" | bc)
	slot1=${slot:0:4}
	slot2=${slot:4:1}
	x=$(echo $shelf$slot1)
	z=$(printf %d%015d $slot2 $gpr)
	z1=${z:0:8}
	z2=${z:8:8}
	temp1=$(echo "ibase=2;obase=10000;$x" | bc)
	
	temp2=$(echo "ibase=2; obase=10000; $z1 " | bc)
	temp3=$(echo "ibase=2; obase=10000; $z2 " | bc)
	gpr_query=$(echo $bytes1$dot$temp1$dot$temp2$dot$temp3$dot$gprvalue) 

}

function parse_cmdline(){
	# LONG_OPTIONS is a list of space-separated multi-character options.
	#  The string must be in the form:
	#   Example: 'option1 option2 ... optionN'.
	#  Options that takes an argument must be followed by a colon:
	#   Example: 'option1: option2 ... optionN:'
	#  Options with an optional argument must be followed by a double colon:
	#   Example: 'option1:: option2:: ... optionN'
	local LONG_OPTIONS='help verbose'
	
	[ $# -le 0 ] && usage && abort 'missing parameter'
	
	/usr/bin/getopt --quiet --quiet-output --longoptions="$LONG_OPTIONS" -- "$@"
	EXIT_CODE=$?
	if [ $EXIT_CODE -ne $TRUE ]; then
		usage
		abort "Command line parameter error"
	fi	
	local ARGS="$@"
	eval set -- "$ARGS"
	
	# Make sure to handle the cases for all the options listed in OPTIONS
	#  and LONG_OPTIONS and to fill up the right script-wide variables.
	while [ $# -gt 0 ]; do		
		case "$1" in
			$(check_board_format $1 && echo $1))				
				OPT_BOARD=$TRUE
				BOARD=$1
			;;
#			all-boards)
#				abort "this applies only to one board at a time"
#			;;
#			all-slots)
#				abort "this applies only to one board at a time"
#			;;
			--help)
				usage
				exit $TRUE
			;;
			--verbose)				
				OPT_VERBOSE=$TRUE				
			;;			
			--)
				# "end of argument list"
				shift
				break
			;;
			*)
				abort "unrecognized option ($1)"
			;;
		esac
		shift
	done
	[[ $OPT_BOARD -eq $FALSE && $OPT_ALL_SLOTS -eq $FALSE && $OPT_ALL_BOARDS -eq $FALSE ]] && abort 'missing parameter'
}

OPT_VERBOSE=$FALSE
OPT_BOARD=$FALSE
BOARD=''
parse_cmdline $@
set_clearrtfd
exit $?
