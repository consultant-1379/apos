#!/bin/bash
##
# ------------------------------------------------------------------------
#     Copyright (C) 2014 Ericsson AB. All rights reserved.
# ------------------------------------------------------------------------
##
# Name:
#       rifdef
# Description:
#       This script is to define Reliable Ethernet on the Public network using interface eth0 and eth1
##
# Usage:
#       rifdef [-f]
##
# Output:
#      rifdef Command Execution Completed
#

## Changelog:
# -  Thu May 05 2016 - Luca De Simone (xludesi) 
#         Updated to inhibit 'rifdef' command in SMX architecture 
#    PC3  06 Nov 2014 - by Fabio Imperato (xfabimp)
#         Call cluster_conf_commit function before restart of active node 
#    PC2  16 May 2014 - by Fabrizio Paglia (xfabpag)
#         Removed unused functions, variables and commented old code
#    PC1  7 May 2014 - by Fabrizio Paglia (xfabpag)
#         Changed "grep -r" in "grep -w" in newbondnamecheck
#         Changed "grep -i" in "grep -w" in newbondnamecheck
#    PB2  28 Mar 2014   by Torgny Wilhelmsson (xtorwil)
#         Updates for Public VLAN compatibility 
#    PB1  27 of February - by Gianluigi Crispino (XGIACRI)
#         added ModifyVLAN call
#    PA52 13 of December - by Marco Zambonelli (XMARZAM)
#         verifyPassivePing moved to rif_common
#    PA51 9nd of December - by Marco Zambonelli (XMARZAM)
#         changed verifyPassivePing to be more robust
#    PA50 2nd of December - by Marco Zambonelli (XMARZAM)
#         Changed PassiveNodeReboot to control passive node status
#         StartSupervisingPeriod logic moved to PassiveNodeReboot fn.
#         SupervisingPeriod logic PassiveNodeReboot fn.
#         aposconf updating moved into rif_common.PassiveNodeReboot fn.
#    PA49 28st of November - by Marco Zambonelli (XMARZAM)
#         update messages implementation according to 
#         1/190 80-CNZ 226 23 Uen PA8
#         3/190 80-CNZ 226 23 Uen PA7
#    PA48 21st of November - by Marco Zambonelli (XMARZAM)
#         rolling back and messages implementation according to
#         1/190 80-CNZ 226 23 Uen PA7
#    PA47 18th of November - by Marco Zambonelli (XMARZAM)
#         rif_imm_status movedo to rif_common (shared with rifrm)
#    PA46 14th of November - by Marco Zambonelli (XMARZAM)
#         use of Reload_Network_Conf to reload network parameters in function Start_first_config_round
#    PA45 14th of November - by Luca Ruffini (XLUCRUF)
#	  bug fixing
#    PA44 09th of November - by Marco Zambonelli (XMARZAM)
#         changed to return exit statment in RebootActive function
#         RebootActive moved to rif_common (shared function)
#    PA43 06th of November - by Marco Zambonelli (XMARZAM)
#         cleanup, move some output messages on calling funtions
#    PA42 30th of October - by (XMARZAM)
#         VerifyPassivePing functino implemented
#         rifdef_rollback function upgrade
#    PA41 28th of October - by (XMARZAM)
#         rifdef_status added to manage rifdef_rollback function
#         rifdef_rollback implementation started
#    PA40 23rd of October - by Luca Ruffini (XLUCRUF)
#        apos_rif.conf handling for intermediate states, is_rifdef_allowed function added
#    PA39 21s1 of October - by (XMARZAM)
#         moved common funtions and variables to rif_common
#         function ChangeNetwork2eth1 moved to rif_common with name ChangeNetwork2intf (shared with rifdef)
#    PA38 9th of October - by Torgny Wilhelmsson (XTORWIL)
#         in func ChangeNetwork2Bond changed 'grep public' to 'grep "public "'
#         to avoid problem with PS which names its network as public2     
#    PA37 4th of October - by Luca Ruffini (XLUCRUF)
#         removed exit_success_string at the end of the script, and changed printout on active node reboot
#    PA36 4th of October - by Torgny Wilhelmsson (XTORWIL)
#         Extended supervision time for passive node to reboot
#    PA35 2nd Oct by xgiacri and xmarzam
#         reboot on passive node solved
#    PA34 1st Oct by xmarzam
#         exit failure if rif_common doesn't exist 
#         check functions reordering
#         added some log messages
#    PA33 27th Sept  - by Dekitalia team
#         bug in log generation solved
#         added check on $PEER_NODE_STATUS var
#         rif_common file managment started
#    PA32 25th September - by Dekitalia team
#         Reordering exicode values
#         rifdef logfile management
#         added F_INFO var
#    PA25 20th of September - by Dekitalia team
#         Removed some messages according to doc 1/190 80-CNZ 222 263 Uen PA4
#    PA24 20th of September - by Dekitalia team
#         Removed some exit code
#    PA23 19th of September - by Marco Zambonelli (XMARZAM)    
#         Removed some messages according to doc 1/190 80-CNZ 222 263 Uen PA3
#    PA23 19th of September - by Marco Zambonelli (XMARZAM) 
#         Removed some messages according to doc 1/190 80-CNZ 222 263 Uen PA3
#    PA22 17th of September - by Torgny Wilhelmsson (XTORWIL)
#         Removed unused functions and redundant comments
#    PA21 16th of September - by Torgny Wilhelmsson (XTORWIL)
#         Changed code to supervice reboot of passive node, thereafter verify changes in passive
#         and reboot active node, functions added: StartSupervisingPeriod, SupervisingPeriod,
#         EndSupervisingPeriod, VerifyPassiveAfterReboot and RebootActive
#    PA20 13nd of September - by Torgny Wilhelmsson (XTORWIL)
#        one shoot aproch
#    PA19 2nd of September - by Torgny Wilhelmsson (XTORWIL)
#        Added info lines before success exits
#        Added a ssh rhost cd> /dev/null before any real ssh to try to avoid ssh connection error while node reboot
#    PA18 30th of August - by Fabrizio Paglia (XFABPAG)
#        Added new line before exit code 6 printout
#    PA17 29th of August - by Fabrizio Paglia (XFABPAG)
#        Change printouts from 'PARTLY CONFIGURED' to 'PARTLY DEFINED'
#        redirect cluster config -v stderr and stdout to /dev/null
#        changed [y(es)/n(o)] with [y=yes, n=no]?
#        handling of the -f option
#    PA15 - PA16 a bit of mess, exit codes and strings
#    PA14 28th of August
#        Added line breaks to error message in func PassiveNodeReboot
#        modified error printout  in func ModifyIPTABLES
#        modified exit to script_exit in rif_imm_set
#        added local_global_cluster_config_consistency_check
#    PA13 27 August - by Fabrizio Paglia (XFABPAG)
#        printouts updated
#        use ssh instead of rsh
#    PA12 27 August -
#        printouts updated,
#        var  alias_interface_properly_configured initialised properly,
#        extra space in search string removed
#        Added func script_exit, to remove lockfile before exit
#    PA11 26 August -
#        change of printouts,
#        tidied up code a bit
#    PA10 23 August -
#        change of printouts, reorder of function calls
#        tidied up code a bit
#    PA9 22 August -
#        change of printouts
#        tidied up code a bit
#    PA8 21 August -
#        change of printouts
#        tidied up code a bit
#        ignore pa7s alarm thingie
#        Added function ModifyIPTABLES to change from eth1 to bond1
#    PA7 20 August -
#        function to modify public network to point to bond1 added
#        Second part of script started.
#        remaining part is alarm changes for eth0
#    PA6 8 August -
#        updated error coding
#        lines added to create bond1 and bond1:1 alias
#    PA5 5 August -
#        updated error coding
#        added and changed printouts to match preliminary man page
#    PA4 2 August -
#        updated error coding for bunch of check
#        think checks should be fully working
#    PA2 30 July-
#        updates after meeting in Pagani; to be implemented
#        - Check for IP address defined on Eth0,
#          Cables to be connected before definition
#        - Cmd only to be executed from COM interface
#          so command only from Active node
#        - two step approach, alt 4 accordign to APG43L RE_RIFDEFflow_3alternatives.pptx
#    PA1 July 2013    by Torgny Wilhelmsson (xtorwil)
#        first draft with things copied from PSDEF and VLANDEF scripts
#        some checks implemented
###


RIF_COMMON=$(dirname $0)/rif_common
source $RIF_COMMON

exit_virtual_arch_string="Illegal command in this system configuration"
exit_virtual_arch=44

##########################################################
# Function ClusterConfigCheck
### Checking the cluster configuration before RE configuration ###############
function ClusterConfigCheck(){
    TRACE_ENTER $FUNCNAME

    INFO "$print_ClusterConfigCheck_string_check"
    INFO "Doing command cluster config -v"
    cluster config -v &> /dev/null
    if [ $? == 0 ] ; then
        :
    else
        INFO "$LINENO: $?: CMD cluster config -v failed, exiting with $exit_check_fail"
        echo -e "$exit_check_fail_string"
        exit $exit_check_fail
    fi

    INFO "Compare /cluster/etc/cluster.conf with /boot/.cluster.conf"
    CC_OWN_CONSISTENT=$(local_global_cluster_config_consistency_check "this")
    if [ $CC_OWN_CONSISTENT -eq 0 ] ; then
        log_error "$LINENO Inconsistent cluster configuration!"
        echo -e "$exit_check_fail_string"
        script_exit $exit_check_fail
    fi

    CC_PEER_CONSISTENT=$(local_global_cluster_config_consistency_check "peer")
    if [ $CC_PEER_CONSISTENT -eq 0 ] ; then
        log_error "$LINENO Inconsistent cluster configuration!"
        echo -e "$exit_check_fail_string"
        script_exit $exit_check_fail
    fi

    if [ $rif_status -eq 0 ] ; then

        INFO "Checking interface configuration"
        # Check if eth0 is defined correctly in the cluster conf
        Eth0InterfaceCheck1

        # Check if eth0 is found in ifconfig printout
        Eth0InterfaceCheck2
        INFO "Interface configuration valid"

        # check if the new bond name exist in the cluster conf file
        newbondnamecheck
    fi

    INFO "$print_ClusterConfigCheck_string_ok"

    TRACE_LEAVE $FUNCNAME
}


##########################################################
# Function newbondnamecheck
### Check if the new bond name, bond1, is found in cluster configuration #####
function newbondnamecheck () {
    TRACE_ENTER $FUNCNAME

    if [ "$($CMD_GREP -w $BOND_NAME $CLUSTER_CONF | tr -d ' ')" ] ; then
            INFO "$LINENO: $BOND_NAME already in use in $CLUSTER_CONF"
            echo -e "$exit_clus_bond_string"
            exit $exit_clus_bond
    fi

    if [ $($CMD_IFCONFIG | grep -w $BOND_NAME| tr -d ' ')  ] ; then
            INFO "$LINENO: $BOND_NAME already in use in ifconfig on local node"
            echo -e "$exit_clus_bond_string"
            exit $exit_clus_bond
    fi

    ssh $RHOST cd &> /dev/null
    if [ $? -eq 0 ] ; then
        if [ $(ssh $RHOST $CMD_IFCONFIG | grep -w $BOND_NAME | tr -d ' ')  ] ; then
            INFO "$LINENO: $BOND_NAME already in use in ifconfig in other node"
            echo -e "$exit_clus_bond_string"
            exit $exit_clus_bond
        fi
    else
        INFO "$LINENO: SSH to other node \"$RHOST\" failed"
        echo -e "$exit_failure_string"
        exit $exit_failure
    fi

    TRACE_LEAVE $FUNCNAME
}

##
# Name:
#    is_rifdef_allowed
# Description:
#    Compares timestamp of last change in the given node with the 
#    actual one, in order to know if a pre-existing incomplete configuration
#    is still ongoing or can be deleted
# Output:
#    0 if not configured -> rifdef allowed
#    1 if configured -> rifdef not allowed
#    2 if partly configured and timestamp older than MAX_LATENCY_TIME -> rifdef not allowed and rifrm is required
#    3 if partly configured and configuration ongoing -> rifdef not allowed
#    4 if unexpected state -> rifdef not allowed and rifrm is required

function is_rifdef_allowed(){
    TRACE_ENTER $FUNCNAME
    returnValue=1
    if [ ! -z $rif_status ] ; then
        if [ $rif_status -eq 0 ] ; then   # NOT CONFIGURED
        # If you are not here it means that RE is already configured, and the return value
        #     of this function is 1.
        # If you are here it means that rif_status == 0, and the return value is evaluated
        #     according to the following table ("xx" is any intermediate state):
        # _________________________________
        # | Node A | Node B | Return value |
        # |--------+--------+--------------|
        # |   0    |   0    |      0       |
        # |--------+--------+--------------|
        # |   1    |  xx    | 2 if TS>MAX* |
        # |  xx    |   1    | 3 if TS<MAX* |
        # |  xx    |  xx    |              |
        # |--------+--------+--------------|
        # |   0    |   1    |      4       |
        # |   1    |   0    |      4       |
        # |   1    |   1    |      4       |
        # |   0    |  xx    |      4       |
        # |  xx    |   0    |      4       |
        # |________________________________|
        #
        # *) TS=timestamp / MAX=MAX_LATENCY_TIME 
        
        get_apos_rif_state $LNODE
        localNodeStatus=$?
        get_apos_rif_state $RNODE
        remoteNodeStatus=$?
        get_apos_rif_timestamp $LNODE
        localNodeTimestamp=$ReturnTimestampValue
        get_apos_rif_timestamp $RNODE
        remoteNodeTimestamp=$ReturnTimestampValue
        timestamp=$(date +%s)
        
		if [ $localNodeStatus -eq 0 ] && [ $remoteNodeStatus -eq 0 ] ; then
		    returnValue=0
		elif ( [ $localNodeStatus -ne 0 ] && [ $remoteNodeStatus -eq 0 ] ) ||\
			       ( [ $localNodeStatus -eq 0 ] && [ $remoteNodeStatus -ne 0 ] ) ||\
			       ( [ $localNodeStatus -eq 1 ] && [ $remoteNodeStatus -eq 1 ] ) ; then
		    returnValue=4
		elif [ $localNodeStatus -eq 1  ] && [ $(($timestamp-$remoteNodeTimestamp)) -gt $MAX_LATENCY_TIME ] ; then
		    returnValue=2
		elif [ $remoteNodeStatus -eq 1  ] && [ $(($timestamp-$localNodeTimestamp)) -gt $MAX_LATENCY_TIME ] ; then
		    returnValue=2
		elif [ $(($timestamp-$remoteNodeTimestamp)) -gt $MAX_LATENCY_TIME ] || [ $(($timestamp-$localNodeTimestamp)) -gt $MAX_LATENCY_TIME ] ; then
		    returnValue=2
		else
		    returnValue=3
		fi        
        fi
    fi
    INFO  returnValueIs $returnValue
    TRACE_LEAVE $FUNCNAME
    return $returnValue
}

##########################################################
# Function Start_first_config_round
### Start configuration changes ##############################################
function Start_first_config_round () {
    TRACE_ENTER $FUNCNAME

    ## All checks are okay, IMM status 0, reconfiguration starting

    # add message to log file
    INFO "$print_rifdefstart"
    INFO "RIF COMMON VER  $_RIF_COMMON_VER"
  
    # add message to system log
    log "$print_rifdefstart"

    ## Create lock file so only one command instance can be executing
    lock

    echo -e "\n$print_UpdatingPassive"
    ## All ok, set teamingStatus to 10
    ## update cluster_rif.conf and remove rif_imm_set
    #rif_imm_set 10

    ## All ok, set status in apos_rif.conf to 10
    aposrifconf_update_both 10
    
    # Informing user we are now creating the bond interfaces
    INFO "$print_createBondInterface"
    # Create bond 1
    rifdef_status=$rifdef_createBond_status
    createBond
    result=$?
     if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "createBond $Done"
    
    # Add bond1:1 alias interface face in cluster config
    rifdef_status=$rifdef_createBondAlias_status
    createBondAlias
    result=$?
     if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "createBondAlias $Done"

	## Check if public interface has a VLAN tag set.
    PublicEth_VLAN_NO=''
	NETWORK='public'
	PublicEth_VLAN_NO=$(${CMD_GREP} ^ip $CLUSTER_CONF | ${CMD_GREP} -w $NETWORK | ${CMD_HEAD} -1 | ${CMD_AWK} '{ print $3}' | ${CMD_AWK} -F'.' '{ print $2 }')

	if [ -z $PublicEth_VLAN_NO ] ; then 
			# If public VLAN is configured, then ModifyVLAN will change
			# Interface names, IP and MIP from eth1 to bond1
			# then we skip these steps in such case

		# start of changing non-VLAN configuration
			
			
			# Change the Public network to point to bond1 IP
			rifdef_status=$rifdef_ChangeNetwork2intfRNODE_status
			ChangeNetwork2intf $RNODE $BOND_NAME
			result=$?
			 if  [ $result -ne 0 ]; then
				rifdef_rollback
				echo -e "\n$rif_not_defined_string"
				script_exit $exit_failure        
			fi
			INFO "ChangeNetwork2intf $RNODE $BOND_NAME $Done"

			rifdef_status=$rifdef_ChangeNetwork2intfLNODE_status
			ChangeNetwork2intf $LNODE $BOND_NAME
			result=$?
			 if  [ $result -ne 0 ]; then
				rifdef_rollback
				echo -e "\n$rif_not_defined_string"
				script_exit $exit_failure        
			fi
			INFO "ChangeNetwork2intf $LNODE $BOND_NAME $Done"


			# Find the Rule ID for the MIP and Change movable IP for public network to point to bond1:1
			rifdef_status=$rifdef_ChangeMIP2Alias_status
			ChangeMIP2Alias $ETH1_ALIAS_NAME $BOND_ALIAS_NAME
			result=$?
			if  [ $result -ne 0 ]; then
				rifdef_rollback
				echo -e "\n$rif_not_defined_string"
				script_exit $exit_failure        
			fi
			INFO "ChangeMIP2Alias $Done"

	fi
			
    rifdef_status=$rifdef_ModifyIPTABLES_status
    ModifyIPTABLES $ETH1_NAME $BOND_NAME
    result=$?
     if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "ChanModifyIPTABLES $Done"

    # Find the Rule ID for the VLAN interface, alias, ip, MIP to point to bond1:1
    rifdef_status=$rifdef_ModifyVLAN_status
    ModifyVLAN $ETH1_NAME $BOND_NAME
    result=$?
    if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure
    fi
    INFO "ModifyVLAN $ETH1_NAME $BOND_NAME $Done"


    # reload paramter configuration
    rifdef_status=$rifdef_Reload_Network_Conf_status
    Reload_Network_Conf
    result=$?
    if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "Reload_Network_Conf $Done"


    # Reboot passive node
    rifdef_status=$rifdef_PassiveNodeReboot_status
    echo -e "\n$print_RebootingPassive"
    PassiveNodeReboot $PASSIVE_REBOOT_TO_SECS
    result=$?
     if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "PassiveNodeReboot $Done"

    ## All ok, set passive status in apos_rif.conf to 13
    aposrifconf_update_single $RNODE 13
    
    # Verify new configuration of passive node after reboot
    rifdef_status=$rifdef_VerifyPassiveAfterReboot_status
    VerifyPassiveAfterReboot define
    result=$?
    if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "VerifyPassiveAfterReboot $Done"

    ## All ok, set passive status in apos_rif.conf to 1
    aposrifconf_update_single $RNODE 1
    
    # Verify ping on passive node
    rifdef_status=$rifdef_VerifyPassivePing_status
    VerifyPassivePing $RextIP
    result=$?
    if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "VerifyPassivePing $Done"

    # Reboot Active node with one minute delay
    echo -e "\n$print_UpdatingActive"
    rifdef_status=$rifdef_RebootActive_status
	cluster_conf_commit
    RebootActive
    result=$?
    if  [ $result -ne 0 ]; then
        rifdef_rollback
        echo -e "\n$rif_not_defined_string"
        script_exit $exit_failure        
    fi
    INFO "RebootActive $Done"

    ## Remove lock file
    unlock

    ## All ok on passive node, set teamingStatus to 1
    newteaminStatusValue=1
    rif_imm_set $newteaminStatusValue
    aposrifconf_update_both $newteaminStatusValue
    
    # add message to rifdef log:
    INFO "Configuration of RE finished"
    # add message to system log
    log "Configuration of RE finished. Reboot of active node ordered"

    TRACE_LEAVE $FUNCNAME
}


##############################################################################
##############################################################################
#################################### Main ####################################

# Set the interpreter to exit if a non-initialized variable is used.
set -u

shelf_arch_val=$(get_shelf_architecture_attr)

## New function for virtualization
if [ $shelf_arch_val -eq 3 ]; then
	echo -e "$exit_virtual_arch_string"
	echo -e
	exit $exit_virtual_arch
fi

## Inhibit command execution in SMX architecture
if [ $shelf_arch_val -eq 4 ]; then
	echo -e "$exit_CableLessDefined_string"
	echo -e
	exit $exit_CableLessDefined
fi

# trap keyboard interrupt (control-c)
trap 'rifdef_abort "CTRL-C"' SIGINT

#####   Initialization of some vars
initvar

#####   First a bunch of checks:
BunchOfChecks
# returns rif_status, if it is 0, and if everything else is OK

#### Now to configuration
is_rifdef_allowed
case $? in
    0 ) 
    # Checking cluster configuration
    ClusterConfigCheck
    Start_first_config_round 
    ;;
    1 )
    echo -e "$exit_AlreadyDefined_string"
    # RE already configured ( should have exited scripts earlier )
    exit $exit_AlreadyDefined
    ;;
    2 )
    #echo -e "$exit_clus_bond_string"
    # RE partly defined and rifrm required ( should have exited scripts earlier )
    # Checking cluster configuration
    ClusterConfigCheck
    Start_first_config_round 
    #exit $exit_clus_bond
    ;;
    3 )
    echo -e "$print_operation_ongoing_string"
    # RE partly defined and definition ongoing (should have exited scripts earlier )
    exit $exit_ifconfig_fail #indentify a new value!
    ;;
    4 )
    echo -e "$exit_failure_string"
    # RE unexpected status (should have exited scripts earlier )
    exit $exit_failure
    ;;
esac


INFO "$exit_success_string"
exit $exit_success
##############################################################################
### END OF SCRIPT ############################################################
##############################################################################


